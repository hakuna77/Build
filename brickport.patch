From 2fc0aa2a429e42fa2fcf344f2f88e0bea0bea217 Mon Sep 17 00:00:00 2001
From: backslashxx <118538522+backslashxx@users.noreply.github.com>
Date: Fri, 13 Jun 2025 21:25:49 +0800
Subject: [PATCH] BRICKPORT: sys_umount: refactor to extract path_umount

this is a brickport.

we have everything needed anyway.

adapted from the following:
`fs: add ksys_mount() helper; remove in-kernel calls to sys_mount()`
- https://github.com/torvalds/linux/commit/312db1aa1dc7bff133d95c92efcc5e42b57cefa6
`fs: refactor ksys_umount`
- https://github.com/torvalds/linux/commit/41525f56e2564c2feff4fb2824823900efb3a39f
`init: add an init_umount helper`
- https://github.com/torvalds/linux/commit/09267defa36aaff6ff829bd2fc8b043ec151cc3e
`fs: fix a struct path leak in path_umount`
- https://github.com/torvalds/linux/commit/25ccd24ffd9119c452d711efa2604a7a0c35956e

Signed-off-by: backslashxx <118538522+backslashxx@users.noreply.github.com>
---
 fs/internal.h  |  1 +
 fs/namespace.c | 55 +++++++++++++++++++++++++++++---------------------
 2 files changed, 33 insertions(+), 23 deletions(-)

diff --git a/fs/internal.h b/fs/internal.h
index 204e1e253283..f2b9b9caeebb 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -75,6 +75,7 @@ extern int mnt_want_write_file_path(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
 extern void mnt_drop_write_file_path(struct file *);
+int path_umount(struct path *path, int flags);
 
 /*
  * fs_struct.c
diff --git a/fs/namespace.c b/fs/namespace.c
index 6ca275c923c1..8015d54586bf 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -1739,37 +1739,19 @@ static inline bool may_mandlock(void)
 }
 #endif
 
-/*
- * Now umount can handle mount points as well as block devices.
- * This is important for filesystems which use unnamed block devices.
- *
- * We now support a flag for forced unmount like the other 'big iron'
- * unixes. Our API is identical to OSF/1 to avoid making a mess of AMD
- */
-
-SYSCALL_DEFINE2(umount, char __user *, name, int, flags)
+// caller is responsible for flags being sane
+int path_umount(struct path *path, int flags)
 {
-	struct path path;
 	struct mount *mnt;
 	int retval;
-	int lookup_flags = 0;
 	bool user_request = !(current->flags & PF_KTHREAD);
 
-	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
-		return -EINVAL;
-
 	if (!may_mount())
 		return -EPERM;
 
-	if (!(flags & UMOUNT_NOFOLLOW))
-		lookup_flags |= LOOKUP_FOLLOW;
-
-	retval = user_path_mountpoint_at(AT_FDCWD, name, lookup_flags, &path);
-	if (retval)
-		goto out;
-	mnt = real_mount(path.mnt);
+	mnt = real_mount(path->mnt);
 	retval = -EINVAL;
-	if (path.dentry != path.mnt->mnt_root)
+	if (path->dentry != path->mnt->mnt_root)
 		goto dput_and_out;
 	if (!check_mnt(mnt))
 		goto dput_and_out;
@@ -1786,7 +1768,7 @@ SYSCALL_DEFINE2(umount, char __user *, name, int, flags)
 	retval = do_umount(mnt, flags);
 dput_and_out:
 	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
-	dput(path.dentry);
+	dput(path->dentry);
 	if (user_request && (!retval || (flags & MNT_FORCE))) {
 		/* filesystem needs to handle unclosed namespaces */
 		if (mnt->mnt.mnt_sb->s_op->umount_end)
@@ -1813,6 +1795,33 @@ SYSCALL_DEFINE2(umount, char __user *, name, int, flags)
 	return retval;
 }
 
+/*
+ * Now umount can handle mount points as well as block devices.
+ * This is important for filesystems which use unnamed block devices.
+ *
+ * We now support a flag for forced unmount like the other 'big iron'
+ * unixes. Our API is identical to OSF/1 to avoid making a mess of AMD
+ */
+
+SYSCALL_DEFINE2(umount, char __user *, name, int, flags)
+{
+	struct path path;
+	int lookup_flags = 0;
+	int retval;
+
+	if (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))
+		return -EINVAL;
+
+	if (!(flags & UMOUNT_NOFOLLOW))
+		lookup_flags |= LOOKUP_FOLLOW;
+
+	retval = user_path_mountpoint_at(AT_FDCWD, name, lookup_flags, &path);
+	if (retval)
+		return retval;
+	
+	return path_umount(&path, flags);
+}
+
 #ifdef __ARCH_WANT_SYS_OLDUMOUNT
 
 /*
