From c353a86100b268a65295b8aebfeb2fa61adbdd58 Mon Sep 17 00:00:00 2001
From: hakuna77 <194330619+hakuna77@users.noreply.github.com>
Date: Wed, 17 Dec 2025 04:47:32 +0000
Subject: [PATCH] test

---
 kernel/Kbuild             |   1 +
 kernel/allowlist.c        |   3 +-
 kernel/app_profile.c      |   2 +
 kernel/app_profile.c.orig | 166 ++++++++++++++++++++++++++++
 kernel/kernel_compat.c    |  21 ++++
 kernel/ksud.c             |  14 +++
 kernel/su_mount_ns.c      | 225 ++++++++++++++++++++++++++++++++++++++
 kernel/su_mount_ns.h      |  15 +++
 8 files changed, 446 insertions(+), 1 deletion(-)
 create mode 100644 kernel/app_profile.c.orig
 create mode 100644 kernel/su_mount_ns.c
 create mode 100644 kernel/su_mount_ns.h

diff --git a/kernel/Kbuild b/kernel/Kbuild
index b49f1d85..79193933 100644
--- a/kernel/Kbuild
+++ b/kernel/Kbuild
@@ -9,6 +9,7 @@ ksu_obj-y += lsm_hook.o
 ksu_obj-y += kernel_compat.o
 ksu_obj-y += kernel_umount.o
 ksu_obj-y += supercalls.o
+ksu_obj-y += su_mount_ns.o
 ksu_obj-y += feature.o
 ksu_obj-y += ksud.o
 ksu_obj-y += seccomp_cache.o
diff --git a/kernel/allowlist.c b/kernel/allowlist.c
index 853fecb4..52850479 100644
--- a/kernel/allowlist.c
+++ b/kernel/allowlist.c
@@ -25,6 +25,7 @@
 #include "allowlist.h"
 #include "manager.h"
 #include "kernel_compat.h"
+#include "su_mount_ns.h"
 
 #define FILE_MAGIC 0x7f4b5355 // ' KSU', u32
 #define FILE_FORMAT_VERSION 3 // u32
@@ -81,7 +82,7 @@ static void init_default_profiles(void)
 	default_root_profile.groups[0] = 0;
 	memcpy(&default_root_profile.capabilities.effective, &full_cap,
 	       sizeof(default_root_profile.capabilities.effective));
-	default_root_profile.namespaces = 0;
+	default_root_profile.namespaces = KSU_NS_INHERITED;
 	strcpy(default_root_profile.selinux_domain, KSU_DEFAULT_SELINUX_DOMAIN);
 
 	// This means that we will umount modules by default!
diff --git a/kernel/app_profile.c b/kernel/app_profile.c
index 49e50146..b08e28ec 100644
--- a/kernel/app_profile.c
+++ b/kernel/app_profile.c
@@ -20,6 +20,7 @@
 #include "kernel_compat.h"
 #include "klog.h" // IWYU pragma: keep
 #include "selinux/selinux.h"
+#include "su_mount_ns.h"
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0) && defined(CONFIG_CC_IS_GCC))
 static struct group_info root_groups = {
@@ -158,6 +159,7 @@ void escape_with_root_profile(void)
 	spin_unlock_irq(&current->sighand->siglock);
 
 	setup_selinux(profile->selinux_domain);
+	setup_mount_ns(profile->namespaces);
 }
 
 void __maybe_unused escape_to_root_for_init(void)
diff --git a/kernel/app_profile.c.orig b/kernel/app_profile.c.orig
new file mode 100644
index 00000000..49e50146
--- /dev/null
+++ b/kernel/app_profile.c.orig
@@ -0,0 +1,166 @@
+#include <linux/version.h>
+#include <linux/capability.h>
+#include <linux/cred.h>
+#include <linux/err.h>
+#include <linux/fdtable.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#include <linux/sched/signal.h> // signal_struct
+#include <linux/sched/task.h>
+#endif
+#include <linux/sched.h>
+#include <linux/seccomp.h>
+#include <linux/thread_info.h>
+#include <linux/uidgid.h>
+
+#include "allowlist.h"
+#include "app_profile.h"
+#include "arch.h"
+#include "kernel_compat.h"
+#include "klog.h" // IWYU pragma: keep
+#include "selinux/selinux.h"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0) && defined(CONFIG_CC_IS_GCC))
+static struct group_info root_groups = {
+	.usage = REFCOUNT_INIT(2),
+};
+#else
+static struct group_info root_groups = { .usage = ATOMIC_INIT(2) };
+#endif
+
+void setup_groups(struct root_profile *profile, struct cred *cred)
+{
+	if (profile->groups_count > KSU_MAX_GROUPS) {
+		pr_warn("Failed to setgroups, too large group: %d!\n",
+			profile->uid);
+		return;
+	}
+
+	if (profile->groups_count == 1 && profile->groups[0] == 0) {
+		// setgroup to root and return early.
+		if (cred->group_info)
+			put_group_info(cred->group_info);
+		cred->group_info = get_group_info(&root_groups);
+		return;
+	}
+
+	u32 ngroups = profile->groups_count;
+	struct group_info *group_info = groups_alloc(ngroups);
+	if (!group_info) {
+		pr_warn("Failed to setgroups, ENOMEM for: %d\n", profile->uid);
+		return;
+	}
+
+	int i;
+	for (i = 0; i < ngroups; i++) {
+		gid_t gid = profile->groups[i];
+		kgid_t kgid = make_kgid(current_user_ns(), gid);
+		if (!gid_valid(kgid)) {
+			pr_warn("Failed to setgroups, invalid gid: %d\n", gid);
+			put_group_info(group_info);
+			return;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+		group_info->gid[i] = kgid;
+#else
+		GROUP_AT(group_info, i) = kgid;
+#endif
+	}
+
+	groups_sort(group_info);
+	set_groups(cred, group_info);
+	put_group_info(group_info);
+}
+
+// RKSU: Use it wisely, not static.
+void disable_seccomp(void)
+{
+	struct task_struct *tsk = current;
+	if (!tsk)
+		return;
+
+	assert_spin_locked(&tsk->sighand->siglock);
+
+	// disable seccomp
+#if defined(CONFIG_GENERIC_ENTRY) &&                                           \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+	clear_syscall_work(SECCOMP);
+#else
+	clear_thread_flag(TIF_SECCOMP);
+#endif
+
+#ifdef CONFIG_SECCOMP
+	// Skip releasing filter ref when its already NULL.
+	if (tsk->seccomp.filter == NULL)
+		return;
+
+	tsk->seccomp.mode = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0) ||                          \
+     defined(KSU_OPTIONAL_SECCOMP_FILTER_CNT))
+	atomic_set(&tsk->seccomp.filter_count, 0);
+#endif
+	tsk->seccomp.filter = NULL;
+#endif
+}
+
+void escape_with_root_profile(void)
+{
+	struct cred *cred;
+
+	if (current_euid().val == 0) {
+		pr_warn("Already root, don't escape!\n");
+		return;
+	}
+
+	cred = prepare_creds();
+	if (!cred) {
+		pr_warn("prepare_creds failed!\n");
+		return;
+	}
+
+	struct root_profile *profile = ksu_get_root_profile(cred->uid.val);
+
+	cred->uid.val = profile->uid;
+	cred->suid.val = profile->uid;
+	cred->euid.val = profile->uid;
+	cred->fsuid.val = profile->uid;
+
+	cred->gid.val = profile->gid;
+	cred->fsgid.val = profile->gid;
+	cred->sgid.val = profile->gid;
+	cred->egid.val = profile->gid;
+	cred->securebits = 0;
+
+	BUILD_BUG_ON(sizeof(profile->capabilities.effective) !=
+		     sizeof(kernel_cap_t));
+
+	// setup capabilities
+	// we need CAP_DAC_READ_SEARCH becuase `/data/adb/ksud` is not accessible for non root process
+	// we add it here but don't add it to cap_inhertiable, it would be dropped automaticly after exec!
+	u64 cap_for_ksud =
+		profile->capabilities.effective | CAP_DAC_READ_SEARCH;
+	memcpy(&cred->cap_effective, &cap_for_ksud,
+	       sizeof(cred->cap_effective));
+	memcpy(&cred->cap_permitted, &profile->capabilities.effective,
+	       sizeof(cred->cap_permitted));
+	memcpy(&cred->cap_bset, &profile->capabilities.effective,
+	       sizeof(cred->cap_bset));
+
+	setup_groups(profile, cred);
+
+	commit_creds(cred);
+
+	// Refer to kernel/seccomp.c: seccomp_set_mode_strict
+	// When disabling Seccomp, ensure that current->sighand->siglock is held during the operation.
+	spin_lock_irq(&current->sighand->siglock);
+	disable_seccomp();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	setup_selinux(profile->selinux_domain);
+}
+
+void __maybe_unused escape_to_root_for_init(void)
+{
+	setup_selinux(KERNEL_SU_CONTEXT);
+}
diff --git a/kernel/kernel_compat.c b/kernel/kernel_compat.c
index 9eabd01e..faa6d570 100644
--- a/kernel/kernel_compat.c
+++ b/kernel/kernel_compat.c
@@ -84,6 +84,27 @@ ssize_t ksu_kernel_write_compat(struct file *p, const void *buf, size_t count,
 #endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+__weak int path_mount(const char *dev_name, struct path *path, 
+	const char *type_page, unsigned long flags, void *data_page)
+{
+	// 384 is enough 
+	char buf[384] = {0};
+
+	// -1 on the size as implicit null termination
+	// as we zero init the thing
+	char *realpath = d_path(path, buf, sizeof(buf) - 1);
+	if (!(realpath && realpath != buf)) 
+		return -ENOENT;
+
+	mm_segment_t old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	long ret = do_mount(dev_name, (const char __user *)realpath, type_page, flags, data_page);
+	set_fs(old_fs);
+	return ret;
+}
+#endif
+
 static inline long
 do_strncpy_user_nofault(char *dst, const void __user *unsafe_addr, long count)
 {
diff --git a/kernel/ksud.c b/kernel/ksud.c
index 73b1852d..e2d4579a 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -462,6 +462,20 @@ int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
 	return 0;
 }
 
+#ifdef CONFIG_KSU_SUSFS
+int ksu_handle_sys_read(unsigned int fd, char __user **buf_ptr,
+			size_t *count_ptr)
+{
+	struct file *file = fget(fd);
+	if (!file) {
+		return 0;
+	}
+	int result = ksu_handle_vfs_read(&file, buf_ptr, count_ptr, NULL);
+	fput(file);
+	return result;
+}
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 static unsigned int volumedown_pressed_count = 0;
 
 static bool is_volumedown_enough(unsigned int count)
diff --git a/kernel/su_mount_ns.c b/kernel/su_mount_ns.c
new file mode 100644
index 00000000..1e104a20
--- /dev/null
+++ b/kernel/su_mount_ns.c
@@ -0,0 +1,225 @@
+#include <linux/dcache.h>
+#include <linux/errno.h>
+#include <linux/fdtable.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/fs_struct.h>
+#include <linux/limits.h>
+#include <linux/namei.h>
+#include <linux/proc_ns.h>
+#include <linux/pid.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+#include <linux/task_work.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#include <linux/sched/task.h>
+#else
+#include <linux/sched.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
+#include <uapi/linux/mount.h>
+#else
+#include <uapi/linux/fs.h>
+#endif
+
+#include "arch.h"
+#include "klog.h" // IWYU pragma: keep
+#include "ksu.h"
+#include "su_mount_ns.h"
+#include "kernel_compat.h"
+
+extern int path_mount(const char *dev_name, struct path *path,
+                      const char *type_page, unsigned long flags,
+                      void *data_page);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0)
+#if defined(__aarch64__)
+extern long __arm64_sys_setns(const struct pt_regs *regs);
+#elif defined(__x86_64__)
+extern long __x64_sys_setns(const struct pt_regs *regs);
+#endif
+
+static long ksu_sys_setns(int fd, int flags)
+{
+    struct pt_regs regs;
+    memset(&regs, 0, sizeof(regs));
+
+    PT_REGS_PARM1(&regs) = fd;
+    PT_REGS_PARM2(&regs) = flags;
+
+#if defined(__aarch64__)
+    return __arm64_sys_setns(&regs);
+#elif defined(__x86_64__)
+    return __x64_sys_setns(&regs);
+#else
+#error "Unsupported arch"
+#endif
+}
+#else
+static long ksu_sys_setns(int fd, int flags)
+{
+	return sys_setns(fd, flags);
+}
+__weak int ksys_unshare(unsigned long unshare_flags)
+{
+	return sys_unshare(unshare_flags);
+}
+#endif
+// global mode , need CAP_SYS_ADMIN and CAP_SYS_CHROOT to perform setns
+static void ksu_mnt_ns_global(void)
+{
+    // save current working directory as absolute path before setns
+    char *pwd_path = NULL;
+    char *pwd_buf = kmalloc(PATH_MAX, GFP_KERNEL);
+    if (!pwd_buf) {
+        pr_warn("no mem for pwd buffer, skip restore pwd!!\n");
+        goto try_setns;
+    }
+
+    struct path saved_pwd;
+    get_fs_pwd(current->fs, &saved_pwd);
+    pwd_path = d_path(&saved_pwd, pwd_buf, PATH_MAX);
+    path_put(&saved_pwd);
+
+    if (IS_ERR(pwd_path)) {
+        if (PTR_ERR(pwd_path) == -ENAMETOOLONG) {
+            pr_warn("absolute pwd longer than: %d, skip restore pwd!!\n",
+                    PATH_MAX);
+        } else {
+            pr_warn("get absolute pwd failed: %ld\n", PTR_ERR(pwd_path));
+        }
+        pwd_path = NULL;
+    }
+
+try_setns:
+
+    rcu_read_lock();
+    // &init_task is not init, but swapper/idle, which forks the init process
+    // so we need find init process
+    struct pid *pid_struct = find_pid_ns(1, &init_pid_ns);
+    if (unlikely(!pid_struct)) {
+        rcu_read_unlock();
+        pr_warn("failed to find pid_struct for PID 1\n");
+        goto out;
+    }
+
+    struct task_struct *pid1_task = get_pid_task(pid_struct, PIDTYPE_PID);
+    rcu_read_unlock();
+    if (unlikely(!pid1_task)) {
+        pr_warn("failed to get task_struct for PID 1\n");
+        goto out;
+    }
+    struct path ns_path;
+    long ret = ns_get_path(&ns_path, pid1_task, &mntns_operations);
+    put_task_struct(pid1_task);
+    if (ret) {
+        pr_warn("failed get path for init mount namespace: %ld\n", ret);
+        goto out;
+    }
+    struct file *ns_file = dentry_open(&ns_path, O_RDONLY, ksu_cred);
+
+    path_put(&ns_path);
+    if (IS_ERR(ns_file)) {
+        pr_warn("failed open file for init mount namespace: %ld\n",
+                PTR_ERR(ns_file));
+        goto out;
+    }
+
+    int fd = get_unused_fd_flags(O_CLOEXEC);
+    if (fd < 0) {
+        pr_warn("failed to get an unused fd: %d\n", fd);
+        fput(ns_file);
+        goto out;
+    }
+
+    fd_install(fd, ns_file);
+    ret = ksu_sys_setns(fd, CLONE_NEWNS);
+
+    do_close_fd(fd);
+
+    if (ret) {
+        pr_warn("call setns failed: %ld\n", ret);
+        goto out;
+    }
+    // try to restore working directory using absolute path after setns
+    if (pwd_path) {
+        struct path new_pwd;
+        int err = kern_path(pwd_path, 0, &new_pwd);
+        if (!err) {
+            set_fs_pwd(current->fs, &new_pwd);
+            path_put(&new_pwd);
+        } else {
+            pr_warn("restore pwd failed: %d, path: %s\n", err, pwd_path);
+        }
+    }
+out:
+    kfree(pwd_buf);
+}
+
+// individual mode , need CAP_SYS_ADMIN to perform unshare and remount
+static void ksu_mnt_ns_individual(void)
+{
+    long ret = ksys_unshare(CLONE_NEWNS);
+    if (ret) {
+        pr_warn("call ksys_unshare failed: %ld\n", ret);
+        return;
+    }
+
+    // make root mount private
+    struct path root_path;
+    get_fs_root(current->fs, &root_path);
+    int pm_ret = path_mount(NULL, &root_path, NULL, MS_PRIVATE | MS_REC, NULL);
+    path_put(&root_path);
+
+    if (pm_ret < 0) {
+        pr_err("failed to make root private, err: %d\n", pm_ret);
+    }
+}
+
+static void ksu_setup_mount_ns_tw_func(struct callback_head *cb)
+{
+    struct ksu_mns_tw *tw = container_of(cb, struct ksu_mns_tw, cb);
+    const struct cred *old_cred = override_creds(ksu_cred);
+    if (tw->ns_mode == KSU_NS_GLOBAL) {
+        ksu_mnt_ns_global();
+    } else {
+        ksu_mnt_ns_individual();
+    }
+    revert_creds(old_cred);
+    kfree(tw);
+}
+
+void setup_mount_ns(int32_t ns_mode)
+{
+    // inherit mode
+    if (ns_mode == KSU_NS_INHERITED) {
+        // do nothing
+        return;
+    }
+
+    if (ns_mode != KSU_NS_GLOBAL && ns_mode != KSU_NS_INDIVIDUAL) {
+        pr_warn("pid: %d ,unknown mount namespace mode: %d\n", current->pid,
+                ns_mode);
+        return;
+    }
+
+    if (!ksu_cred) {
+        pr_err("no ksu cred! skip mnt_ns magic for pid: %d.\n", current->pid);
+        return;
+    }
+
+    struct ksu_mns_tw *tw = kzalloc(sizeof(*tw), GFP_ATOMIC);
+    if (!tw) {
+        pr_err("no mem for tw! skip mnt_ns magic for pid: %d.\n", current->pid);
+        return;
+    }
+    tw->cb.func = ksu_setup_mount_ns_tw_func;
+    tw->ns_mode = ns_mode;
+    if (task_work_add(current, &tw->cb, TWA_RESUME)) {
+        kfree(tw);
+        pr_err("add task work failed! skip mnt_ns magic for pid: %d.\n",
+               current->pid);
+    }
+}
diff --git a/kernel/su_mount_ns.h b/kernel/su_mount_ns.h
new file mode 100644
index 00000000..d57a7df8
--- /dev/null
+++ b/kernel/su_mount_ns.h
@@ -0,0 +1,15 @@
+#ifndef __KSU_SU_MOUNT_NS_H
+#define __KSU_SU_MOUNT_NS_H
+
+#define KSU_NS_INHERITED 0
+#define KSU_NS_GLOBAL 1
+#define KSU_NS_INDIVIDUAL 2
+
+struct ksu_mns_tw {
+    struct callback_head cb;
+    int32_t ns_mode;
+};
+
+void setup_mount_ns(int32_t ns_mode);
+
+#endif
-- 
2.34.1

