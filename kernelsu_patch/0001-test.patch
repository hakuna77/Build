From 8e30e089ea0aaab5e46b04c0e67a39b2b67efe65 Mon Sep 17 00:00:00 2001
From: hakuna77 <194330619+hakuna77@users.noreply.github.com>
Date: Mon, 24 Nov 2025 19:38:53 +0000
Subject: [PATCH] test

---
 kernel/Makefile         |  1 -
 kernel/allowlist.c      |  2 ++
 kernel/app_profile.c    | 21 ++++++++++++---------
 kernel/ksu.c            |  4 +++-
 kernel/ksud.c           | 12 ++++++------
 kernel/supercalls.c     |  4 ----
 kernel/umount_manager.c |  1 +
 7 files changed, 24 insertions(+), 21 deletions(-)

diff --git a/kernel/Makefile b/kernel/Makefile
index f6824941..7f6ccf0d 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -4,7 +4,6 @@ kernelsu-objs += dynamic_manager.o
 kernelsu-objs += app_profile.o
 kernelsu-objs += apk_sign.o
 kernelsu-objs += sucompat.o
-kernelsu-objs += syscall_hook_manager.o
 kernelsu-objs += throne_tracker.o
 kernelsu-objs += pkg_observer.o
 kernelsu-objs += setuid_hook.o
diff --git a/kernel/allowlist.c b/kernel/allowlist.c
index 9a68e054..19fbf693 100644
--- a/kernel/allowlist.c
+++ b/kernel/allowlist.c
@@ -269,8 +269,10 @@ out:
 
 	if (persist) {
 		persistent_allow_list();
+#ifndef CONFIG_KSU_SUSFS
 		// FIXME: use a new flag
 		ksu_mark_running_process();
+#endif // #ifndef CONFIG_KSU_SUSFS
 	}
 
 	return result;
diff --git a/kernel/app_profile.c b/kernel/app_profile.c
index c7229860..abd4e9ea 100644
--- a/kernel/app_profile.c
+++ b/kernel/app_profile.c
@@ -127,19 +127,23 @@ void disable_seccomp(struct task_struct *tsk)
 void escape_with_root_profile(void)
 {
 	struct cred *cred;
+#ifndef CONFIG_KSU_SUSFS
 	// a bit useless, but we just want less ifdefs
 	struct task_struct *p = current;
-
-	if (current_euid().val == 0) {
-		pr_warn("Already root, don't escape!\n");
-		return;
-	}
+	struct task_struct *t;
+#endif // #ifndef CONFIG_KSU_SUSFS
 
 	cred = prepare_creds();
 	if (!cred) {
 		pr_warn("prepare_creds failed!\n");
 		return;
 	}
+	
+	if (current_euid().val == 0) {
+		pr_warn("Already root, don't escape!\n");
+		abort_creds(cred);
+		return;
+	}
 
 	struct root_profile *profile = ksu_get_root_profile(cred->uid.val);
 
@@ -175,9 +179,9 @@ void escape_with_root_profile(void)
 
 	// Refer to kernel/seccomp.c: seccomp_set_mode_strict
 	// When disabling Seccomp, ensure that current->sighand->siglock is held during the operation.
-	spin_lock_irq(&p->sighand->siglock);
-	disable_seccomp(p);
-	spin_unlock_irq(&p->sighand->siglock);
+	spin_lock_irq(&current->sighand->siglock);
+	disable_seccomp();
+	spin_unlock_irq(&current->sighand->siglock);
 
 	setup_selinux(profile->selinux_domain);
 #if __SULOG_GATE
@@ -185,7 +189,6 @@ void escape_with_root_profile(void)
 #endif
 
 #ifndef CONFIG_KSU_SUSFS
-	struct task_struct *t;
 	for_each_thread (p, t) {
 		ksu_set_task_tracepoint_flag(t);
 	}
diff --git a/kernel/ksu.c b/kernel/ksu.c
index e3244e52..70e88189 100644
--- a/kernel/ksu.c
+++ b/kernel/ksu.c
@@ -70,7 +70,9 @@ int __init kernelsu_init(void)
 
 	sukisu_custom_config_init();
 
+#ifndef CONFIG_KSU_SUSFS
 	ksu_syscall_hook_manager_init();
+#endif // #ifndef CONFIG_KSU_SUSFS
 
 	ksu_workqueue = alloc_ordered_workqueue("kernelsu_work_queue", 0);
 
@@ -107,9 +109,9 @@ void kernelsu_exit(void)
 
 #if defined(CONFIG_KPROBES) && !defined(CONFIG_KSU_SUSFS)
 	ksu_ksud_exit();
-#endif
 
 	ksu_syscall_hook_manager_exit();
+#endif
 
 	sukisu_custom_config_exit();
 
diff --git a/kernel/ksud.c b/kernel/ksud.c
index db494ad9..21e6c827 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -222,11 +222,11 @@ int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
 							 struct user_arg_ptr *argv,
 							 struct user_arg_ptr *envp, int *flags)
 {
-#ifndef KSU_KPROBES_HOOK
+#ifdef CONFIG_KSU_SUSFS
 	if (!ksu_execveat_hook) {
 		return 0;
 	}
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS
 	struct filename *filename;
 
 	static const char app_process[] = "/system/bin/app_process";
@@ -373,11 +373,11 @@ static ssize_t read_iter_proxy(struct kiocb *iocb, struct iov_iter *to)
 static int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
 							   size_t *count_ptr, loff_t **pos)
 {
-#ifndef KSU_KPROBES_HOOK
+#ifdef CONFIG_KSU_SUSFS
 	if (!ksu_vfs_read_hook) {
 		return 0;
 	}
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS
 	struct file *file;
 	char __user *buf;
 	size_t count;
@@ -486,11 +486,11 @@ static bool is_volumedown_enough(unsigned int count)
 int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code,
 								  int *value)
 {
-#ifndef KSU_KPROBES_HOOK
+#ifdef CONFIG_KSU_SUSFS
 	if (!ksu_input_hook) {
 		return 0;
 	}
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS
 	if (*type == EV_KEY && *code == KEY_VOLUMEDOWN) {
 		int val = *value;
 		pr_info("KEY_VOLUMEDOWN val: %d\n", val);
diff --git a/kernel/supercalls.c b/kernel/supercalls.c
index 1cdaec82..b43e4d5e 100644
--- a/kernel/supercalls.c
+++ b/kernel/supercalls.c
@@ -1147,7 +1147,6 @@ void ksu_supercalls_init(void)
 		pr_info("  %-18s = 0x%08x\n", ksu_ioctl_handlers[i].name, ksu_ioctl_handlers[i].cmd);
 	}
 #ifndef CONFIG_KSU_SUSFS
-#ifdef KSU_KPROBES_HOOK
 	int rc = register_kprobe(&reboot_kp);
 	if (rc) {
 		pr_err("reboot kprobe failed: %d\n", rc);
@@ -1155,15 +1154,12 @@ void ksu_supercalls_init(void)
 		pr_info("reboot kprobe registered successfully\n");
 	}
 #endif
-#endif
 }
 
 void ksu_supercalls_exit(void) 
 {
 #ifndef CONFIG_KSU_SUSFS
-#ifdef KSU_KPROBES_HOOK
 	unregister_kprobe(&reboot_kp);
-#endif
 #else
 	pr_info("susfs: do nothing\n");
 #endif
diff --git a/kernel/umount_manager.c b/kernel/umount_manager.c
index bd8be063..48c45906 100644
--- a/kernel/umount_manager.c
+++ b/kernel/umount_manager.c
@@ -5,6 +5,7 @@
 #include <linux/path.h>
 #include <linux/mount.h>
 #include <linux/cred.h>
+#include <linux/fs.h>
 
 #include "klog.h"
 #include "kernel_umount.h"
-- 
2.34.1

