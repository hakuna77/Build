From 83465ebd6419cfd5221c081c3ec62e3526a98464 Mon Sep 17 00:00:00 2001
From: hakuna77 <akuntrial045@gmail.com>
Date: Sat, 8 Nov 2025 17:43:01 +0000
Subject: [PATCH] fix sukisu for non-gki

---
 kernel/allowlist.c       |  5 ++++-
 kernel/file_wrapper.c    | 24 ++++++++++++------------
 kernel/ksud.c            |  4 ++++
 kernel/selinux/selinux.c |  8 ++++++++
 kernel/supercalls.c      |  8 +++++++-
 5 files changed, 35 insertions(+), 14 deletions(-)

diff --git a/kernel/allowlist.c b/kernel/allowlist.c
index 947048f2..439f6dbf 100644
--- a/kernel/allowlist.c
+++ b/kernel/allowlist.c
@@ -419,8 +419,11 @@ void persistent_allow_list()
         goto put_task;
     }
     cb->func = do_persistent_allow_list;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
     task_work_add(tsk, cb, TWA_RESUME);
-
+#else
+    task_work_add(tsk, cb, true);
+#endif
 put_task:
     put_task_struct(tsk);
 }
diff --git a/kernel/file_wrapper.c b/kernel/file_wrapper.c
index 24ae979c..6a830eee 100644
--- a/kernel/file_wrapper.c
+++ b/kernel/file_wrapper.c
@@ -249,7 +249,6 @@ static void ksu_wrapper_show_fdinfo(struct seq_file *m, struct file *f) {
 	}
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 static ssize_t ksu_wrapper_copy_file_range(struct file *f1, loff_t off1, struct file *f2,
 		loff_t off2, size_t sz, unsigned int flags) {
 	// TODO: determine which file to use
@@ -261,6 +260,7 @@ static ssize_t ksu_wrapper_copy_file_range(struct file *f1, loff_t off1, struct
 	return -EINVAL;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 static loff_t ksu_wrapper_remap_file_range(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out,
 				loff_t len, unsigned int remap_flags) {
@@ -272,11 +272,20 @@ static loff_t ksu_wrapper_remap_file_range(struct file *file_in, loff_t pos_in,
 	}
 	return -EINVAL;
 }
+
+static int ksu_wrapper_fadvise(struct file *fp, loff_t off1, loff_t off2, int flags) {
+	struct ksu_file_wrapper* data = fp->private_data;
+	struct file* orig = data->orig;
+	if (orig->f_op->fadvise) {
+		return orig->f_op->fadvise(orig, off1, off2, flags);
+	}
+	return -EINVAL;
+}
 #else
 static int ksu_wrapper_clone_file_range(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out, u64 len) {
 	// TODO: determine which file to use
-	struct ksu_file_proxy* data = file_in->private_data;
+	struct ksu_file_wrapper* data = file_in->private_data;
 	struct file* orig = data->orig;
 	if (orig->f_op->clone_file_range) {
 		return orig->f_op->clone_file_range(orig, pos_in, file_out, pos_out, len);
@@ -287,7 +296,7 @@ static int ksu_wrapper_clone_file_range(struct file *file_in, loff_t pos_in,
 static ssize_t ksu_wrapper_dedupe_file_range(struct file *src_file, u64 loff,
 				u64 len, struct file *dst_file, u64 dst_loff) {
 	// TODO: determine which file to use
-	struct ksu_file_proxy* data = src_file->private_data;
+	struct ksu_file_wrapper* data = src_file->private_data;
 	struct file* orig = data->orig;
 	if (orig->f_op->dedupe_file_range) {
 		return orig->f_op->dedupe_file_range(orig, loff, len, dst_file, dst_loff);
@@ -296,15 +305,6 @@ static ssize_t ksu_wrapper_dedupe_file_range(struct file *src_file, u64 loff,
 }
 #endif
 
-static int ksu_wrapper_fadvise(struct file *fp, loff_t off1, loff_t off2, int flags) {
-	struct ksu_file_wrapper* data = fp->private_data;
-	struct file* orig = data->orig;
-	if (orig->f_op->fadvise) {
-		return orig->f_op->fadvise(orig, off1, off2, flags);
-	}
-	return -EINVAL;
-}
-
 static int ksu_wrapper_release(struct inode *inode, struct file *filp) {
 	ksu_delete_file_wrapper(filp->private_data);
     return 0;
diff --git a/kernel/ksud.c b/kernel/ksud.c
index fefad007..f4a9fba5 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -214,7 +214,11 @@ first_app_process:
         rcu_read_lock();
         init_task = rcu_dereference(current->parent);
         if (init_task) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
             task_work_add(init_task, &on_post_fs_data_cb, TWA_RESUME);
+#else
+            task_work_add(init_task, &on_post_fs_data_cb, true);
+#endif
         }
         rcu_read_unlock();
 
diff --git a/kernel/selinux/selinux.c b/kernel/selinux/selinux.c
index 57c2be1b..4e2cdab5 100644
--- a/kernel/selinux/selinux.c
+++ b/kernel/selinux/selinux.c
@@ -116,7 +116,11 @@ bool is_task_ksu_domain(const struct cred* cred)
     if (!cred) {
         return false;
     }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
     const struct task_security_struct *tsec = selinux_cred(cred);
+#else
+    const struct task_security_struct *tsec = cred->security;
+#endif
     if (!tsec) {
         return false;
     }
@@ -140,7 +144,11 @@ bool is_zygote(const struct cred* cred)
     if (!cred) {
         return false;
     }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
     const struct task_security_struct * tsec = selinux_cred(cred);
+#else
+    const struct task_security_struct * tsec = cred->security;
+#endif
     if (!tsec) {
         return false;
     }
diff --git a/kernel/supercalls.c b/kernel/supercalls.c
index 897c7634..5fef0335 100644
--- a/kernel/supercalls.c
+++ b/kernel/supercalls.c
@@ -393,7 +393,13 @@ static int do_get_wrapper_fd(void __user *arg) {
     struct file* pf = fget(ret);
 
     struct inode* wrapper_inode = file_inode(pf);
-    struct inode_security_struct *sec = selinux_inode(wrapper_inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0) ||                           \
+	defined(KSU_OPTIONAL_SELINUX_INODE)
+	struct inode_security_struct *sec = selinux_inode(wrapper_inode);
+#else
+	struct inode_security_struct *sec =
+		(struct inode_security_struct *)wrapper_inode->i_security;
+#endif
     if (sec) {
         sec->sid = ksu_file_sid;
     }
-- 
2.34.1

