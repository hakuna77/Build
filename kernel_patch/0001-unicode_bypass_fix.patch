From 6d608ea9f228e478fa2dc008612d28305a4897fc Mon Sep 17 00:00:00 2001
From: hakuna77 <194330619+hakuna77@users.noreply.github.com>
Date: Sat, 14 Feb 2026 06:55:20 +0700
Subject: [PATCH] unicode_bypass_fix

---
 fs/unicode/utf8-norm.c | 26 +++++++++++++-------------
 1 file changed, 13 insertions(+), 13 deletions(-)

diff --git a/fs/unicode/utf8-norm.c b/fs/unicode/utf8-norm.c
index 801ed6d2e..43a21edb6 100644
--- a/fs/unicode/utf8-norm.c
+++ b/fs/unicode/utf8-norm.c
@@ -702,21 +702,21 @@ int utf8byte(struct utf8cursor *u8c)
 		if (utf8agetab[LEAF_GEN(leaf)] > u8c->data->maxage) {
 			ccc = STOPPER;
 		} else if (ccc == DECOMPOSE) {
-			u8c->len -= utf8clen(u8c->s);
-			u8c->p = u8c->s + utf8clen(u8c->s);
-			u8c->s = LEAF_STR(leaf);
-			/* Empty decomposition implies CCC 0. */
-			if (*u8c->s == '\0') {
-				if (u8c->ccc == STOPPER)
-					continue;
+			// Check if the decomposition result is empty (e.g., zero-width space)
+			if (*LEAF_STR(leaf) == '\0') {
 				ccc = STOPPER;
-				goto ccc_mismatch;
+			} else {
+				// Pointer movement and state modification are performed only when it is confirmed that the character is a normal character that needs to be decomposed.
+				u8c->len -= utf8clen(u8c->s);
+				u8c->p = u8c->s + utf8clen(u8c->s);
+				u8c->s = LEAF_STR(leaf);
+				
+				// Proceed to the next level of searching
+				leaf = utf8lookup(u8c->data, u8c->hangul, u8c->s);
+				if (!leaf)
+					return -1;
+				ccc = LEAF_CCC(leaf);
 			}
-
-			leaf = utf8lookup(u8c->data, u8c->hangul, u8c->s);
-			if (!leaf)
-				return -1;
-			ccc = LEAF_CCC(leaf);
 		}
 
 		/*
-- 
2.52.0

