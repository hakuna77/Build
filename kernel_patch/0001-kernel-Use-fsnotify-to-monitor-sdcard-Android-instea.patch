From 05f4dcd0b7f1174530849d0dafcf6e7d66d695a1 Mon Sep 17 00:00:00 2001
From: hakuna77 <194330619+hakuna77@users.noreply.github.com>
Date: Wed, 4 Feb 2026 08:01:30 +0700
Subject: [PATCH] kernel: Use fsnotify to monitor /sdcard/Android instead of 
 the kern_path loop

---
 fs/susfs.c                | 176 +++++++++++++++++++++++++++++---------
 include/linux/susfs_def.h |  41 +++++++++
 2 files changed, 176 insertions(+), 41 deletions(-)

diff --git a/fs/susfs.c b/fs/susfs.c
index a98c9f892..c1f95cc4e 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -16,6 +16,7 @@
 #include <linux/random.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
+#include <linux/fsnotify_backend.h>
 #include <linux/susfs.h>
 #include "mount.h"
 
@@ -986,22 +987,132 @@ out_copy_to_user:
 	SUSFS_LOGI("CMD_SUSFS_SHOW_VERSION -> ret: %d\n", info.err);
 }
 
-/* kthread for checking if /sdcard/Android/data is accessible */
-#define SDCARD_ANDROID_DATA_PATH "/sdcard/Android/data"
-#define SDCARD_MONITOR_INTERVAL_MS 5000
-#define SDCARD_MONITOR_MAX_ATTEMPTS 60 /* 60 x 5 = 300s = 5 mins */
+/* kthread for checking if /sdcard/Android is accessible via fsnoitfy */
+/* code is straightly borrowed from KernelSU's pkg_observer.c */
+#define SDCARD_ANDROID_DATA_PATH "/data/media/0/Android"
 extern void setup_selinux(const char *domain, struct cred *cred);
 extern bool susfs_is_current_ksu_domain(void);
 bool susfs_is_sdcard_android_data_decrypted __read_mostly = false;
-static struct task_struct *susfs_sdcard_monitor_thread;
+
+struct watch_dir {
+	const char *path;
+	u32 mask;
+	struct path kpath;
+	struct inode *inode;
+	struct fsnotify_mark *mark;
+};
+
+static struct fsnotify_group *g;
+
+static struct watch_dir g_watch = { .path = "/data/media/0", // we choose the underlying f2fs /data/media/0 instead of the FUSE /sdcard
+									.mask = (FS_EVENT_ON_CHILD | FS_ISDIR | FS_OPEN_PERM) };
+
+static int add_mark_on_inode(struct inode *inode, u32 mask,
+								struct fsnotify_mark **out);
+
+static int watch_one_dir(struct watch_dir *wd)
+{
+	int ret = kern_path(wd->path, LOOKUP_FOLLOW, &wd->kpath);
+	if (ret) {
+		SUSFS_LOGI("path not ready: %s (%d)\n", wd->path, ret);
+		return ret;
+	}
+	wd->inode = d_inode(wd->kpath.dentry);
+	ihold(wd->inode);
+
+	ret = add_mark_on_inode(wd->inode, wd->mask, &wd->mark);
+	if (ret) {
+		SUSFS_LOGE("Add mark failed for %s (%d)\n", wd->path, ret);
+		iput(wd->inode);
+		wd->inode = NULL;
+		path_put(&wd->kpath);
+		return ret;
+	}
+	SUSFS_LOGI("watching %s\n", wd->path);
+	return 0;
+}
+
+static SUSFS_DECL_FSNOTIFY_OPS(susfs_handle_sdcard_inode_event)
+{
+	static bool target_path_is_found = false;
+
+	if (target_path_is_found || !file_name)
+		return 0;
+	if (susfs_fname_len(file_name) == 7 && !memcmp(susfs_fname_arg(file_name), "Android", 7)) {
+		target_path_is_found = true;
+		SUSFS_LOGI("'%s' detected, mask: 0x%x\n", SDCARD_ANDROID_DATA_PATH, mask);
+		SUSFS_LOGI("sleeping for 5 more seconds just in case some other modules are still mounting stuff\n");
+		msleep(5000);
+		SUSFS_LOGI("set susfs_is_sdcard_android_data_decrypted to true\n");
+		WRITE_ONCE(susfs_is_sdcard_android_data_decrypted, true);
+		SUSFS_LOGI("cleaning up\n");
+		if (g) {
+			fsnotify_destroy_group(g);
+		}
+		if (g_watch.inode) {
+			iput(g_watch.inode);
+			g_watch.inode = NULL;
+		}
+		path_put(&g_watch.kpath);
+	}
+	return 0;
+}
+
+static const struct fsnotify_ops fsnotify_ops = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+	.handle_inode_event = susfs_handle_sdcard_inode_event,
+#else
+	.handle_event = susfs_handle_sdcard_inode_event,
+#endif
+};
+
+static void __maybe_unused m_free(struct fsnotify_mark *m)
+{
+	if (m) {
+		kfree(m);
+	}
+}
+
+static int add_mark_on_inode(struct inode *inode, u32 mask,
+								struct fsnotify_mark **out)
+{
+	struct fsnotify_mark *m;
+	int ret;
+
+	m = kzalloc(sizeof(*m), GFP_KERNEL);
+	if (!m)
+		return -ENOMEM;
+
+/* From KernelSU */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+	fsnotify_init_mark(m, g);
+	m->mask = mask;
+	ret = fsnotify_add_inode_mark(m, inode, 0);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	fsnotify_init_mark(m, g);
+	m->mask = mask;
+	ret = fsnotify_add_mark(m, inode, NULL, 0);
+#else
+	fsnotify_init_mark(m, m_free);
+	m->mask = mask;
+	ret = fsnotify_add_mark(m, g, inode, NULL, 0);
+#endif
+
+	if (ret) {
+		fsnotify_put_mark(m);
+		return -EINVAL;
+	}
+	*out = m;
+	return 0;
+}
+
 static int susfs_sdcard_monitor_fn(void *data)
 {
 	struct cred *cred = prepare_creds();
-	struct path path;
-	int err = 0, max_attempts = SDCARD_MONITOR_MAX_ATTEMPTS;
+	int ret = 0;
 
 	if (!cred) {
-		SUSFS_LOGE("Failed to prepare creds!\n");
+		SUSFS_LOGE("failed to prepare creds!\n");
 		return -ENOMEM;
 	}
 
@@ -1009,49 +1120,32 @@ static int susfs_sdcard_monitor_fn(void *data)
 	commit_creds(cred);
 
 	if (!susfs_is_current_ksu_domain()) {
-		SUSFS_LOGE("Domain is not su, exiting the thread\n");
-		susfs_sdcard_monitor_thread = NULL;
+		SUSFS_LOGE("domain is not su, exiting the thread\n");
 		return -EINVAL;
 	}
 
-	SUSFS_LOGI("Start monitoring path '%s' in loop per '%d' ms with maximum '%d' attempts\n",
-				SDCARD_ANDROID_DATA_PATH, SDCARD_MONITOR_INTERVAL_MS, SDCARD_MONITOR_MAX_ATTEMPTS);
+	SUSFS_LOGI("start monitoring path '%s' using fsnotify\n",
+				SDCARD_ANDROID_DATA_PATH);
 
-	while (!kthread_should_stop() && max_attempts > 0) {
-		err = kern_path(SDCARD_ANDROID_DATA_PATH, LOOKUP_FOLLOW, &path);
-
-		if (!err) {
-			SUSFS_LOGI("'%s' is now accessible\n", SDCARD_ANDROID_DATA_PATH);
-			path_put(&path);
-
-			SUSFS_LOGI("Sleeping for '%d' more ms just in case some other modules are still mounting stuff\n",
-						SDCARD_MONITOR_INTERVAL_MS);
-			msleep(SDCARD_MONITOR_INTERVAL_MS);
-
-			SUSFS_LOGI("set susfs_is_sdcard_android_data_decrypted to true\n");
-
-			err = 0;
-
-			goto out_finish;
-		}
-
-		max_attempts--;
-		SUSFS_LOGI("%d attempts left\n", max_attempts);
-		msleep(SDCARD_MONITOR_INTERVAL_MS);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	g = fsnotify_alloc_group(&fsnotify_ops, 0);
+#else
+	g = fsnotify_alloc_group(&fsnotify_ops);
+#endif
+	if (IS_ERR(g)) {
+		return PTR_ERR(g);
 	}
 
-	SUSFS_LOGI("No more attempts, assuming susfs_is_sdcard_android_data_decrypted is true now\n");
+	ret = watch_one_dir(&g_watch);
 
-out_finish:
-	WRITE_ONCE(susfs_is_sdcard_android_data_decrypted, true);
-	WRITE_ONCE(susfs_sdcard_monitor_thread, NULL);
-	return err;
+	SUSFS_LOGI("ret: %d\n", ret);
+
+	return 0;
 }
 
 void susfs_start_sdcard_monitor_fn(void) {
-	susfs_sdcard_monitor_thread = kthread_run(susfs_sdcard_monitor_fn, NULL, "susfs_sdcard_monitor");
-	if (IS_ERR(susfs_sdcard_monitor_thread)) {
-		SUSFS_LOGE("Failed to create thread susfs_sdcard_monitor\n");
+	if (IS_ERR(kthread_run(susfs_sdcard_monitor_fn, NULL, "susfs_sdcard_monitor"))) {
+		SUSFS_LOGE("failed to create thread susfs_sdcard_monitor\n");
 		SUSFS_LOGI("set susfs_is_sdcard_android_data_decrypted to true\n");
 		susfs_is_sdcard_android_data_decrypted = true;
 	}
diff --git a/include/linux/susfs_def.h b/include/linux/susfs_def.h
index 02761d8e0..57af04ebd 100644
--- a/include/linux/susfs_def.h
+++ b/include/linux/susfs_def.h
@@ -2,6 +2,7 @@
 #define KSU_SUSFS_DEF_H
 
 #include <linux/bits.h>
+#include <linux/version.h> // We need check kernel version.
 
 /********/
 /* ENUM */
@@ -76,6 +77,46 @@
  
 #define MAGIC_MOUNT_WORKDIR "/debug_ramdisk/workdir"
 
+/* From KernelSU */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)
+typedef const struct qstr *susfs_fname_t;
+#define susfs_fname_len(f) ((f)->len)
+#define susfs_fname_arg(f) ((f)->name)
+#else
+typedef const unsigned char *susfs_fname_t;
+#define susfs_fname_len(f) (strlen(f))
+#define susfs_fname_arg(f) (f)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+#define SUSFS_DECL_FSNOTIFY_OPS(name)                                            \
+int name(struct fsnotify_mark *mark, u32 mask, struct inode *inode,    \
+struct inode *dir, const struct qstr *file_name, u32 cookie)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)
+#define SUSFS_DECL_FSNOTIFY_OPS(name)                                            \
+int name(struct fsnotify_group *group, struct inode *inode, u32 mask,  \
+const void *data, int data_type, susfs_fname_t file_name,       \
+u32 cookie, struct fsnotify_iter_info *iter_info)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+#define SUSFS_DECL_FSNOTIFY_OPS(name)                                            \
+int name(struct fsnotify_group *group, struct inode *inode, u32 mask,  \
+const void *data, int data_type, susfs_fname_t file_name,       \
+u32 cookie, struct fsnotify_iter_info *iter_info)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+#define SUSFS_DECL_FSNOTIFY_OPS(name)                                            \
+int name(struct fsnotify_group *group, struct inode *inode,            \
+struct fsnotify_mark *inode_mark,                             \
+struct fsnotify_mark *vfsmount_mark, u32 mask,                \
+const void *data, int data_type, susfs_fname_t file_name,       \
+u32 cookie, struct fsnotify_iter_info *iter_info)
+#else
+#define SUSFS_DECL_FSNOTIFY_OPS(name)                                            \
+int name(struct fsnotify_group *group, struct inode *inode,            \
+struct fsnotify_mark *inode_mark,                             \
+struct fsnotify_mark *vfsmount_mark, u32 mask, void *data,    \
+int data_type, susfs_fname_t file_name, u32 cookie)
+#endif
+
 static inline bool susfs_is_current_proc_umounted(void) {
 	return test_ti_thread_flag(&current->thread_info, TIF_PROC_UMOUNTED);
 }
-- 
2.52.0

