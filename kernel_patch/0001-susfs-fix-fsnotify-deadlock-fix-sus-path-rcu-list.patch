From 48d13c9c5a4a2beadd42d51fb627b2422d1d665f Mon Sep 17 00:00:00 2001
From: hakuna77 <194330619+hakuna77@users.noreply.github.com>
Date: Fri, 13 Feb 2026 13:22:59 +0700
Subject: [PATCH] susfs: fix/fsnotify-deadlock & fix/sus-path-rcu-list

---
 fs/susfs.c | 93 ++++++++++++++++++++++++++++++++++++------------------
 1 file changed, 63 insertions(+), 30 deletions(-)

diff --git a/fs/susfs.c b/fs/susfs.c
index 9727e53bc..ccac9084f 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -16,6 +16,7 @@
 #include <linux/random.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
+#include <linux/workqueue.h>
 #include <linux/fsnotify_backend.h>
 #include <linux/susfs.h>
 #include "mount.h"
@@ -149,7 +150,7 @@ void susfs_add_sus_path(void __user **user_info) {
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
 		spin_lock(&susfs_spin_lock_sus_path);
-		list_add_tail(&new_list->list, &LH_SUS_PATH_ANDROID_DATA);
+		list_add_tail_rcu(&new_list->list, &LH_SUS_PATH_ANDROID_DATA);
 		spin_unlock(&susfs_spin_lock_sus_path);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_ANDROID_DATA\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
@@ -173,7 +174,7 @@ void susfs_add_sus_path(void __user **user_info) {
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
 		spin_lock(&susfs_spin_lock_sus_path);
-		list_add_tail(&new_list->list, &LH_SUS_PATH_SDCARD);
+		list_add_tail_rcu(&new_list->list, &LH_SUS_PATH_SDCARD);
 		spin_unlock(&susfs_spin_lock_sus_path);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_SDCARD\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
@@ -238,7 +239,7 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 	new_list->path_len = strlen(new_list->info.target_pathname);
 	INIT_LIST_HEAD(&new_list->list);
 	spin_lock(&susfs_spin_lock_sus_path);
-	list_add_tail(&new_list->list, &LH_SUS_PATH_LOOP);
+	list_add_tail_rcu(&new_list->list, &LH_SUS_PATH_LOOP);
 	spin_unlock(&susfs_spin_lock_sus_path);
 	SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_LOOP\n",
 				new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
@@ -261,7 +262,8 @@ void susfs_run_sus_path_loop(uid_t uid) {
 	struct path path;
 	struct inode *inode;
 
-	list_for_each_entry(cursor, &LH_SUS_PATH_LOOP, list) {
+	rcu_read_lock();
+	list_for_each_entry_rcu(cursor, &LH_SUS_PATH_LOOP, list) {
 		if (!kern_path(cursor->target_pathname, 0, &path)) {
 			inode = path.dentry->d_inode;
 			spin_lock(&inode->i_lock);
@@ -271,6 +273,7 @@ void susfs_run_sus_path_loop(uid_t uid) {
 			SUSFS_LOGI("re-flag '%s' as SUS_PATH for uid: %u\n", cursor->target_pathname, uid);
 		}
 	}
+	rcu_read_unlock();
 }
 
 static inline bool is_i_uid_in_android_data_not_allowed(uid_t i_uid) {
@@ -297,12 +300,14 @@ bool susfs_is_base_dentry_sdcard_dir(struct dentry* base) {
 
 bool susfs_is_sus_android_data_d_name_found(const char *d_name) {
 	struct st_susfs_sus_path_list *cursor = NULL;
+	bool found = false;
 
 	if (d_name[0] == '\0') {
 		return false;
 	}
 
-	list_for_each_entry(cursor, &LH_SUS_PATH_ANDROID_DATA, list) {
+	rcu_read_lock();
+	list_for_each_entry_rcu(cursor, &LH_SUS_PATH_ANDROID_DATA, list) {
 		// - we use strstr here because we cannot retrieve the dentry of fuse_dentry
 		//   and attacker can still use path travesal attack to detect the path, but
 		//   lucky we can check for the uid so it won't let them fool us
@@ -311,28 +316,34 @@ bool susfs_is_sus_android_data_d_name_found(const char *d_name) {
 			is_i_uid_in_android_data_not_allowed(cursor->info.i_uid))
 		{
 			SUSFS_LOGI("hiding path '%s'\n", cursor->target_pathname);
-			return true;
+			found = true;
+			break;
 		}
 	}
-	return false;
+	rcu_read_unlock();
+	return found;
 }
 
 bool susfs_is_sus_sdcard_d_name_found(const char *d_name) {
 	struct st_susfs_sus_path_list *cursor = NULL;
+	bool found = false;
 
 	if (d_name[0] == '\0') {
 		return false;
 	}
-	list_for_each_entry(cursor, &LH_SUS_PATH_SDCARD, list) {
+	rcu_read_lock();
+	list_for_each_entry_rcu(cursor, &LH_SUS_PATH_SDCARD, list) {
 		if (!strncmp(d_name, cursor->info.target_pathname, cursor->path_len) &&
 		    (d_name[cursor->path_len] == '\0' || d_name[cursor->path_len] == '/') &&
 			is_i_uid_in_sdcard_not_allowed())
 		{
 			SUSFS_LOGI("hiding path '%s'\n", cursor->target_pathname);
-			return true;
+			found = true;
+			break;
 		}
 	}
-	return false;
+	rcu_read_unlock();
+	return found;
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
@@ -1010,6 +1021,33 @@ static struct watch_dir g_watch = { .path = "/data/media/0", // we choose the un
 static int add_mark_on_inode(struct inode *inode, u32 mask,
 								struct fsnotify_mark **out);
 
+static unsigned long sdcard_cleanup_scheduled;
+static struct delayed_work sdcard_cleanup_dwork;
+
+static void susfs_sdcard_cleanup_fn(struct work_struct *work)
+{
+	struct fsnotify_group *grp;
+	struct inode *inode;
+
+	SUSFS_LOGI("set susfs_is_sdcard_android_data_decrypted to true\n");
+	WRITE_ONCE(susfs_is_sdcard_android_data_decrypted, true);
+
+	SUSFS_LOGI("cleaning up fsnotify sdcard watch\n");
+
+	grp = xchg(&g, NULL);
+	if (grp)
+		fsnotify_destroy_group(grp);
+
+	inode = xchg(&g_watch.inode, NULL);
+	if (inode)
+		iput(inode);
+
+	if (g_watch.kpath.mnt) {
+		path_put(&g_watch.kpath);
+		memset(&g_watch.kpath, 0, sizeof(g_watch.kpath));
+	}
+}
+
 static int watch_one_dir(struct watch_dir *wd)
 {
 	int ret = kern_path(wd->path, LOOKUP_FOLLOW, &wd->kpath);
@@ -1032,6 +1070,12 @@ static int watch_one_dir(struct watch_dir *wd)
 	return 0;
 }
 
+/*
+ * fsnotify handler â€” runs inside an SRCU read section held by fsnotify().
+ * Must not block or call fsnotify_destroy_group() (which internally calls
+ * synchronize_srcu on the same SRCU struct, causing a permanent deadlock).
+ * Cleanup is deferred to a delayed_work that runs outside the SRCU context.
+ */
 static int susfs_handle_sdcard_inode_event(struct fsnotify_group *group,
 											struct inode *inode,
 											struct fsnotify_mark *inode_mark,
@@ -1040,27 +1084,14 @@ static int susfs_handle_sdcard_inode_event(struct fsnotify_group *group,
 											const unsigned char *file_name, u32 cookie,
 											struct fsnotify_iter_info *iter_info)
 {
-	static bool target_path_is_found = false;
-
-	if (target_path_is_found || !file_name)
+	if (!file_name || strlen(file_name) != 7 || memcmp(file_name, "Android", 7))
 		return 0;
-	if (strlen(file_name) == 7 && !memcmp(file_name, "Android", 7)) {
-		target_path_is_found = true;
-		SUSFS_LOGI("'%s' detected, mask: 0x%x\n", SDCARD_ANDROID_DATA_PATH, mask);
-		SUSFS_LOGI("sleeping for 5 more seconds just in case some other modules are still mounting stuff\n");
-		msleep(5000);
-		SUSFS_LOGI("set susfs_is_sdcard_android_data_decrypted to true\n");
-		WRITE_ONCE(susfs_is_sdcard_android_data_decrypted, true);
-		SUSFS_LOGI("cleaning up\n");
-		if (g) {
-			fsnotify_destroy_group(g);
-		}
-		if (g_watch.inode) {
-			iput(g_watch.inode);
-			g_watch.inode = NULL;
-		}
-		path_put(&g_watch.kpath);
-	}
+	if (test_and_set_bit(0, &sdcard_cleanup_scheduled))
+		return 0;
+	
+	SUSFS_LOGI("'%s' detected, mask: 0x%x\n", SDCARD_ANDROID_DATA_PATH, mask);
+	SUSFS_LOGI("deferring cleanup for 5 seconds\n");
+	queue_delayed_work(system_unbound_wq, &sdcard_cleanup_dwork, 5 * HZ);
 	return 0;
 }
 
@@ -1108,6 +1139,8 @@ static int susfs_sdcard_monitor_fn(void *data)
 
 	SUSFS_LOGI("start monitoring path '%s' using fsnotify\n",
 				SDCARD_ANDROID_DATA_PATH);
+	
+	INIT_DELAYED_WORK(&sdcard_cleanup_dwork, susfs_sdcard_cleanup_fn);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	g = fsnotify_alloc_group(&fsnotify_ops, 0);
-- 
2.52.0

