From 77ca28a53924b5d3c63f29a35c51422253771681 Mon Sep 17 00:00:00 2001
From: sidex15 <24408329+sidex15@users.noreply.github.com>
Date: Sun, 10 Aug 2025 13:13:14 +0800
Subject: [PATCH] security: avc: susfs: Temp fix for avc log message being
 leaked by logd     - See full details:      
 https://android-review.googlesource.com/c/platform/system/logging/+/3725346/2
      
 https://github.com/aviraxp/ZN-AuditPatch/blob/master/module/src/main/cpp/hook.cpp

    - So this is just a temp fix implemented in kernel side

    - Bonus: Add new toggle for enabling or disabling avc log spoofing
---
 fs/susfs.c                |  8 ++++++++
 include/linux/susfs.h     |  1 +
 include/linux/susfs_def.h |  1 +
 security/selinux/avc.c    | 20 ++++++++++++++++++++
 4 files changed, 30 insertions(+)

diff --git a/fs/susfs.c b/fs/susfs.c
index 603aba889790..4736db202f2b 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -23,6 +23,7 @@ extern bool susfs_is_current_ksu_domain(void);
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 extern void ksu_try_umount(const char *mnt, bool check_mnt, int flags, uid_t uid);
 #endif
+extern bool susfs_is_avc_log_spoofing_enabled;
 
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
 bool susfs_is_log_enabled __read_mostly = true;
@@ -1290,6 +1291,13 @@ int susfs_get_enabled_features(char __user* buf, size_t bufsize) {
 	return err;
 }
 
+/* susfs avc log spoofing */
+void susfs_set_avc_log_spoofing(bool enabled) {
+	spin_lock(&susfs_spin_lock);
+	susfs_is_avc_log_spoofing_enabled = enabled;
+	spin_unlock(&susfs_spin_lock);
+	SUSFS_LOGI("enabled: %d\n", enabled);
+}
 
 /* susfs_init */
 void susfs_init(void) {
diff --git a/include/linux/susfs.h b/include/linux/susfs.h
index d1ca78b97ad4..4dca5b3e0ecb 100644
--- a/include/linux/susfs.h
+++ b/include/linux/susfs.h
@@ -194,6 +194,7 @@ int susfs_sus_su(struct st_sus_su* __user user_info);
 #endif
 
 int susfs_get_enabled_features(char __user* buf, size_t bufsize);
+void susfs_set_avc_log_spoofing(bool enabled);
 
 /* susfs_init */
 void susfs_init(void);
diff --git a/include/linux/susfs_def.h b/include/linux/susfs_def.h
index 9de638e7c403..21f91712f822 100644
--- a/include/linux/susfs_def.h
+++ b/include/linux/susfs_def.h
@@ -29,6 +29,7 @@
 #define CMD_SUSFS_SHOW_SUS_SU_WORKING_MODE 0x555e4
 #define CMD_SUSFS_IS_SUS_SU_READY 0x555f0
 #define CMD_SUSFS_SUS_SU 0x60000
+#define CMD_SUSFS_ENABLE_AVC_LOG_SPOOFING 0x60010
 
 #define SUSFS_MAX_LEN_PATHNAME 256 // 256 should address many paths already unless you are doing some strange experimental stuff, then set your own desired length
 #define SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE 4096
diff --git a/security/selinux/avc.c b/security/selinux/avc.c
index 06fef2e3f12c..917f6f9d9272 100644
--- a/security/selinux/avc.c
+++ b/security/selinux/avc.c
@@ -44,6 +44,13 @@
 #define avc_cache_stats_incr(field)	do {} while (0)
 #endif
 
+#ifdef CONFIG_KSU_SUSFS
+extern u32 susfs_ksu_sid;
+extern u32 susfs_kernel_sid;
+bool susfs_is_avc_log_spoofing_enabled = false;
+#endif
+
+
 struct avc_entry {
 	u32			ssid;
 	u32			tsid;
@@ -187,6 +194,16 @@ static void avc_dump_query(struct audit_buffer *ab, struct selinux_state *state,
 	}
 
 	rc = security_sid_to_context(state, tsid, &scontext, &scontext_len);
+#ifdef CONFIG_KSU_SUSFS
+	if (unlikely(tsid == susfs_ksu_sid && susfs_is_avc_log_spoofing_enabled)) {
+		if (rc)
+			audit_log_format(ab, " tsid=%d", susfs_kernel_sid);
+		else
+			audit_log_format(ab, " tcontext=%s", "u:r:kernel:s0");
+		goto bypass_orig_flow;
+	}
+#endif
+
 	if (rc)
 		audit_log_format(ab, " tsid=%d", tsid);
 	else {
@@ -194,6 +211,9 @@ static void avc_dump_query(struct audit_buffer *ab, struct selinux_state *state,
 		kfree(scontext);
 	}
 
+#ifdef CONFIG_KSU_SUSFS
+bypass_orig_flow:
+#endif
 	BUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));
 	audit_log_format(ab, " tclass=%s", secclass_map[tclass-1].name);
 }
