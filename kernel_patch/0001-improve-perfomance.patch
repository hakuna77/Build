From 63aa453baf4a2c80988823d398abeffcc56969a1 Mon Sep 17 00:00:00 2001
From: hakuna77 <194330619+hakuna77@users.noreply.github.com>
Date: Thu, 27 Nov 2025 22:26:52 +0700
Subject: [PATCH] improve perfomance

---
 arch/arm64/configs/begonia_user_defconfig     |  10 +-
 drivers/cpufreq/cpufreq.c                     |   4 +
 drivers/misc/mediatek/Kconfig.default         |   4 -
 drivers/misc/mediatek/Makefile                |   3 +-
 .../power/clkbuf_v1/mt6785/mtk_clkbuf_hw.c    |  68 +-
 .../base/power/clkbuf_v1/mtk_clkbuf_ctl.c     |   2 +-
 .../cm_mgr_v1/mt6785/mtk_cm_mgr_platform.c    |  18 +-
 .../mt6785/mtk_cm_mgr_platform_data.h         |   6 +-
 .../base/power/cm_mgr_v1/mtk_cm_mgr.c         |  58 +-
 .../src/mach/mt6785/mtk_cpufreq_platform.c    |   2 +-
 .../power/cpufreq_v1/src/mtk_cpufreq_hybrid.c |  68 +-
 .../cpufreq_v1/src/mtk_cpufreq_interface.c    |  42 +-
 .../power/cpufreq_v1/src/mtk_cpufreq_main.c   |  42 +-
 .../base/power/cpuhotplug/mtk_cpuhp_ppm.c     |   2 +-
 .../base/power/cpuidle_v3/mtk_cpuidle.c       |   2 +-
 .../misc/mediatek/base/power/dcm_v1/mtk_dcm.c |   2 +-
 .../eem_v2/mt6785/inc/mtk_eem_internal.h      |   2 +-
 .../base/power/eem_v2/mt6785/mtk_eem.c        |   4 +-
 .../base/power/include/ppm_v3/mtk_ppm_api.h   |   2 +
 .../power/leakage_table_v2/mtk_static_power.c |   2 +-
 .../mcdi/include/mcdi_v1/mtk_mcdi_util.h      |   2 +-
 .../base/power/mcdi/mcdi_v1/mtk_mcdi_main.c   |   6 +-
 .../base/power/mcdi/mcdi_v1/mtk_mcdi_mcupm.c  |   2 +-
 .../power/mcdi/mcdi_v1/mtk_mcdi_profile.c     |   2 +-
 .../base/power/mcdi/mt6785/mtk_mcdi_plat.c    |   8 +-
 .../base/power/mcdi/mt6785/mtk_mcdi_state.c   |   4 +-
 .../base/power/mcdi/mtk_mcdi_governor.c       |   2 +-
 .../power/mdpm_v2/mt6785/mtk_mdpm_platform.c  |  82 +-
 .../base/power/mdpm_v2/mtk_mdpm_common.c      |  14 +-
 .../misc/mediatek/base/power/mt6785/Makefile  |  20 +-
 .../mediatek/base/power/mt6785/mtk_gpufreq.h  |   5 +
 .../base/power/mt6785/mtk_gpufreq_core.c      |  30 +-
 .../mediatek/base/power/mt6785/mtk_picachu.c  |   9 +-
 .../misc/mediatek/base/power/pbm_v4/mtk_pbm.c |  44 +-
 .../base/power/power_gs_v1/mtk_power_gs.c     |   6 +-
 .../base/power/power_gs_v1/mtk_power_gs_api.c |  12 +-
 .../base/power/ppm_v3/inc/mtk_ppm_internal.h  |   2 +-
 .../base/power/ppm_v3/src/mtk_ppm_main.c      |   4 +
 .../ppm_v3/src/mtk_ppm_policy_sys_boost.c     |   5 +-
 .../mediatek/base/power/qos/mtk_qos_bound.c   |   8 +-
 .../mediatek/base/power/qos/mtk_qos_ipi.c     |   2 +-
 .../mediatek/base/power/qos/mtk_qos_ipi_v2.c  |  20 +-
 .../mediatek/base/power/spm/common/mtk_idle.c |   4 +-
 .../power/spm/common/mtk_idle_export_legacy.c |   2 +-
 .../base/power/spm/common/mtk_idle_internal.c |   6 +-
 .../base/power/spm/common/mtk_idle_module.c   |   4 +-
 .../base/power/spm/common/mtk_idle_profile.c  |  14 +-
 .../base/power/spm/common/mtk_idle_select.c   |   2 +-
 .../base/power/spm/common/mtk_idle_twam.c     |   2 +-
 .../base/power/spm/common/mtk_sleep.c         |  42 +-
 .../power/spm/common/mtk_spm_resource_req.c   |   6 +-
 .../power/spm/mt6785/mtk_idle_cond_check.c    |  12 +-
 .../mediatek/base/power/spm/mt6785/mtk_spm.c  |  32 +-
 .../base/power/spm/mt6785/mtk_spm_dram.c      |   4 +-
 .../base/power/spm/mt6785/mtk_spm_fs.c        |   4 +-
 .../base/power/spm/mt6785/mtk_spm_idle.c      |   4 +-
 .../base/power/spm/mt6785/mtk_spm_internal.c  |  18 +-
 .../base/power/spm/mt6785/mtk_spm_irq.c       |  24 +-
 .../base/power/spm/mt6785/mtk_spm_power.c     |   8 +-
 .../base/power/spm/mt6785/mtk_spm_suspend.c   |  32 +-
 .../spm/mt6785/mtk_spm_suspend_process.c      |  20 +-
 .../base/power/spm/mt6785/mtk_spm_twam.c      |   4 +-
 .../base/power/spm/mt6785/mtk_spm_utils.c     |  12 +-
 .../mediatek/base/power/spm/mt6785/mtk_sspm.c |  32 +-
 drivers/misc/mediatek/blocktag/Kconfig        |   2 +-
 .../cameraisp/dip/isp_50/camera_dip.c         |   6 +-
 .../cameraisp/dpe/isp_50/camera_dpe.c         |   2 +-
 .../cameraisp/dpe/isp_60/camera_dpe.c         |   8 +-
 .../cameraisp/dpe/isp_60/engine_request.c     |   6 +-
 .../mediatek/cameraisp/fdvt/3.5/camera_fdvt.c |   6 +-
 .../mediatek/cameraisp/fdvt/4.0/camera_fdvt.c |   6 +-
 .../mediatek/cameraisp/fdvt/5.0/camera_fdvt.c |  14 +-
 .../mediatek/cameraisp/fdvt/5.1/camera_fdvt.c |  14 +-
 drivers/misc/mediatek/cameraisp/fdvt/Makefile |   2 +-
 .../cameraisp/mfb/isp_50/camera_mfb.c         |   2 +-
 .../cameraisp/owe/isp_50/camera_owe.c         |   8 +-
 .../cameraisp/owe/mt6785/camera_owe.c         |   8 +-
 .../mediatek/cameraisp/rsc/engine_request.c   |   6 +-
 .../cameraisp/rsc/isp_50/camera_rsc.c         |   6 +-
 .../cameraisp/rsc/mt6785/camera_rsc.c         |   6 +-
 .../cameraisp/src/isp_50/camera_isp.c         | 604 +++++++--------
 .../mediatek/cameraisp/src/mt6785/cam_qos.c   |  74 +-
 .../cameraisp/src/mt6785/camera_isp.c         | 712 +++++++++---------
 .../cameraisp/tsf/isp_50/camera_tsf.c         |   4 +-
 .../cameraisp/wpe/isp_50/camera_wpe.c         |   6 +-
 .../mediatek/ccci_util/ccci_util_lib_fo.c     | 184 ++---
 .../ccci_util/ccci_util_lib_load_img.c        | 116 +--
 .../mediatek/ccci_util/ccci_util_lib_sys.c    |  22 +-
 .../misc/mediatek/ccci_util/ccci_util_log.h   |  35 +-
 drivers/misc/mediatek/ccmni/ccmni.c           |   2 +-
 drivers/misc/mediatek/ccu/src/1.1/ccu_i2c.c   |  58 --
 drivers/misc/mediatek/ccu/src/1.2/ccu_i2c.c   |  59 +-
 drivers/misc/mediatek/ccu/src/2.0/ccu_i2c.c   |  60 --
 drivers/misc/mediatek/ccu/src/2.1/ccu_i2c.c   |  61 --
 drivers/misc/mediatek/ccu/src/Makefile        |   2 +-
 .../misc/mediatek/ccu/src/mt6873/ccu_i2c.c    |  61 --
 drivers/misc/mediatek/cmdq/v2/cmdq_core.h     |   8 +-
 .../misc/mediatek/cmdq/v3/cmdq_helper_ext.h   |   8 +-
 .../misc/mediatek/cmdq/v3/cmdq_mdp_common.c   |   2 +-
 .../misc/mediatek/eccci/hif/ccci_hif_cldma.c  |   2 +-
 .../misc/mediatek/eccci/hif/ccci_hif_dpmaif.c |   4 +-
 drivers/misc/mediatek/eccci/inc/ccci_debug.h  |   6 +-
 .../misc/mediatek/eccci/mixdev/mix_event.c    |   8 +-
 drivers/misc/mediatek/eccci/port/port_proxy.c |   2 +-
 drivers/misc/mediatek/eccci/udc/udc.c         |  56 +-
 .../mediatek/geniezone/mtee-kree/Makefile     |   2 +-
 drivers/misc/mediatek/gpu/Makefile            |   2 +-
 drivers/misc/mediatek/gpu/ged/Makefile        |   3 +
 .../misc/mediatek/gpu/ged/include/ged_ski.h   |  28 +
 drivers/misc/mediatek/gpu/ged/src/ged_main.c  |  16 +
 drivers/misc/mediatek/gpu/ged/src/ged_ski.c   | 310 ++++++++
 drivers/misc/mediatek/gpu/gpu_mali/Makefile   |   2 +-
 .../gpu/gpu_mali/mali_bifrost/Makefile        |   2 +-
 .../gpu/arm/midgard/Kbuild-mtk-custom-env     |   8 +-
 .../gpu/arm/midgard/Kbuild-mtk-custom-env     |   4 +-
 .../gpu/arm/midgard/mali_kbase_core_linux.c   |  21 +-
 .../s5k3t2_mipi_raw/s5k3t2mipiraw_Sensor.c    |   2 +-
 .../mediatek/imgsensor/src/mt6785/Makefile    |   6 +-
 drivers/misc/mediatek/io_boost/mtk_io_boost.c |   8 +-
 drivers/misc/mediatek/m4u/mt6785/m4u_priv.h   |   6 +-
 drivers/misc/mediatek/mdp/mdp_common.c        |   7 +-
 drivers/misc/mediatek/mlog/Kconfig            |   2 +-
 drivers/misc/mediatek/mlog/Makefile           |   2 +-
 drivers/misc/mediatek/mmdvfs/Makefile         |   3 -
 drivers/misc/mediatek/mmdvfs/mmdvfs_pmqos.c   | 264 +++----
 drivers/misc/mediatek/mmdvfs/swpm_me.c        |  12 +-
 .../mediatek/pmic/mt6359/v1/mt6359_gauge.c    | 106 +--
 .../mediatek/pmic/mt6359/v1/pmic_auxadc.c     |   4 +-
 .../misc/mediatek/pmic/mt6359/v1/pmic_irq.c   |   2 +-
 .../pmic/mt6360/pmu/mt6360_pmu_chg_begonia.c  | 114 +--
 .../misc/mediatek/pseudo_m4u/pseudo_m4u_log.h |   4 +-
 .../misc/mediatek/pseudo_m4u/pseudo_m4u_ut.c  |   8 +-
 .../misc/mediatek/selinux_warning/Makefile    |   2 +-
 drivers/misc/mediatek/smi/smi_drv.c           |   8 +-
 drivers/misc/mediatek/systracker/Kconfig      |   6 +
 drivers/misc/mediatek/systracker/Makefile     |   3 +-
 drivers/misc/mediatek/teei/300/Makefile       |  12 +-
 .../misc/mediatek/teei/300/tz_driver/Makefile |   1 -
 drivers/misc/mediatek/teei/Kconfig            |   4 +-
 drivers/misc/mediatek/teei/Makefile           |   2 +-
 .../thermal/common/ap_thermal_limit.c         |  10 +-
 .../common/coolers/mtk_cooler_3Gmutt.c        |   2 +-
 .../thermal/common/coolers/mtk_cooler_NR.c    |   4 +-
 .../common/coolers/mtk_cooler_VR_FPS.c        |   4 +-
 .../thermal/common/coolers/mtk_cooler_amutt.c |   2 +-
 .../thermal/common/coolers/mtk_cooler_atm.c   |  36 +-
 .../thermal/common/coolers/mtk_cooler_bcct.c  |  24 +-
 .../common/coolers/mtk_cooler_bcct_2nd.c      |  14 +-
 .../common/coolers/mtk_cooler_bcct_v1.c       |  56 +-
 .../common/coolers/mtk_cooler_char_curr_cus.c |   2 +-
 .../thermal/common/coolers/mtk_cooler_dtm.c   |   4 +-
 .../thermal/common/coolers/mtk_cooler_fps.c   |  12 +-
 .../common/coolers/mtk_cooler_gpu_cus.c       |   2 +-
 .../common/coolers/mtk_cooler_md_cus.c        |   2 +-
 .../thermal/common/coolers/mtk_cooler_mutt.c  |   8 +-
 .../common/coolers/mtk_cooler_mutt_gen97.c    |   4 +-
 .../common/coolers/mtk_cooler_sysrst.c        |   8 +-
 .../common/coolers/mtk_cooler_vpu_cus.c       |   2 +-
 .../mediatek/thermal/common/coolers/mtk_ta.c  |  16 +-
 .../thermal/common/mtk_change_policy.c        |   2 +-
 .../thermal/common/mtk_thermal_platform.c     |   8 +-
 .../thermal/common/mtk_thermal_timer.c        |   8 +-
 .../thermal/common/thermal_zones/mtk_tsAll.c  |   6 +-
 .../common/thermal_zones/mtk_ts_backlight.c   |  10 +-
 .../common/thermal_zones/mtk_ts_battery.c     |   4 +-
 .../thermal/common/thermal_zones/mtk_ts_bts.c |  14 +-
 .../common/thermal_zones/mtk_ts_btscharger.c  |  12 +-
 .../common/thermal_zones/mtk_ts_btsmdpa.c     |  12 +-
 .../common/thermal_zones/mtk_ts_btsnrpa.c     |  12 +-
 .../common/thermal_zones/mtk_ts_charger.c     |  10 +-
 .../common/thermal_zones/mtk_ts_charger2.c    |   2 +-
 .../thermal/common/thermal_zones/mtk_ts_cpu.c |  72 +-
 .../common/thermal_zones/mtk_ts_cpu_noBank.c  |  60 +-
 .../common/thermal_zones/mtk_ts_dctm.c        |   4 +-
 .../common/thermal_zones/mtk_ts_imgsensor.c   |   6 +-
 .../thermal/common/thermal_zones/mtk_ts_tsx.c |   2 +-
 .../thermal/common/thermal_zones/mtk_ts_wmt.c |   2 +-
 .../thermal/mt6785/inc/tscpu_settings.h       |  20 +-
 .../thermal/mt6785/inc/tspmic_settings.h      |   4 +-
 .../mediatek/thermal/mt6785/src/mtk_lvts_tc.c |   2 +-
 .../misc/mediatek/thermal/mt6785/src/mtk_tc.c |  46 +-
 .../mediatek/thermal/mtk_cooler_backlight.c   |   2 +-
 .../thermal/mtk_cooler_backlight_cus.c        |   2 +-
 .../misc/mediatek/thermal/mtk_cooler_cam.c    |   4 +-
 .../thermal/mtk_cooler_flashlight_cus.c       |   2 +-
 .../mediatek/thermal/mtk_cooler_kshutdown.c   |   2 +-
 .../mediatek/thermal/mtk_cooler_shutdown.c    |   2 +-
 .../mediatek/thermal/mtk_thermal_monitor.c    |   4 +-
 .../mediatek/trusted_mem/Makefile.configs     |   8 +-
 .../video/mt6785/videox/disp_drv_log.h        |  10 +-
 .../video/mt6785/videox/disp_recovery.c       |   3 +-
 .../video/mt6785/videox/primary_display.c     |  39 +-
 .../video/mt6853/cmdq/v3/cmdq_helper_ext.h    |   8 +-
 .../video/mt6853/cmdq/v3/cmdq_mdp_common.c    |   2 +-
 drivers/misc/mediatek/vpu/2.0/vpu_algo.c      |  10 +-
 drivers/misc/mediatek/vpu/2.0/vpu_cmn.h       |   6 +-
 drivers/misc/mediatek/vpu/2.0/vpu_dbg.c       |  22 +-
 drivers/misc/mediatek/vpu/2.0/vpu_drv.c       |  48 +-
 drivers/misc/mediatek/vpu/3.0/vpu_algo.c      |  10 +-
 drivers/misc/mediatek/vpu/3.0/vpu_cmn.h       |   8 +-
 drivers/misc/mediatek/vpu/3.0/vpu_dbg.c       |   6 +-
 drivers/misc/mediatek/vpu/3.0/vpu_drv.c       |  64 +-
 drivers/misc/mediatek/vpu/mt6785/apu_dvfs.c   |  44 +-
 drivers/misc/mediatek/vpu/mt6785/vpu_hw.c     | 198 ++---
 .../misc/mediatek/vpu/mt6785/vpu_profile.c    |   6 +-
 drivers/misc/mediatek/vpu/mt6785/vpu_qos.c    |   4 +-
 drivers/misc/mediatek/vpu/mt6785/vpu_reg.c    |   2 +-
 .../mediatek/zone_movable_cma/single_cma.c    |  42 +-
 .../mediatek/battery_begonia/mtk_battery.c    |  72 +-
 .../battery_begonia/mtk_battery_core.c        |  12 +-
 .../battery_begonia/mtk_battery_internal.h    |   8 +-
 .../battery_begonia/mtk_battery_recovery.c    |  20 +-
 .../battery_begonia/mtk_gauge_class.c         |   2 +-
 .../mtk_gauge_coulomb_service.c               |  30 +-
 .../power/supply/mediatek/battery_common.c    |  26 +-
 .../supply/mediatek/battery_common_fg_20.c    |   2 +-
 drivers/power/supply/mediatek/battery_meter.c |   4 +-
 .../supply/mediatek/battery_meter_fg_20.c     |  64 +-
 .../mediatek/charger_begonia/adapter_class.c  |   4 +-
 .../supply/mediatek/charger_begonia/bq25601.c |  88 +--
 .../mediatek/charger_begonia/charger_class.c  |   2 +-
 .../supply/mediatek/charger_begonia/hl7005.c  |  18 +-
 .../mediatek/charger_begonia/mtk_charger.c    |  18 +-
 .../charger_begonia/mtk_charger_intf.h        |   2 +-
 .../charger_begonia/mtk_chg_type_det.c        |  62 +-
 .../mtk_dual_switch_charging.c                |  28 +-
 .../charger_begonia/mtk_linear_charging.c     |  20 +-
 .../mediatek/charger_begonia/mtk_pd_adapter.c |   6 +-
 .../mediatek/charger_begonia/mtk_pdc_intf.c   |   2 +-
 .../mediatek/charger_begonia/mtk_pe20_intf.c  |   6 +-
 .../mediatek/charger_begonia/mtk_pe_intf.c    |   4 +-
 .../charger_begonia/mtk_switch_charging.c     |   4 +-
 .../supply/mediatek/charger_begonia/rt9465.c  |  10 +-
 .../supply/mediatek/charger_begonia/rt9467.c  |  14 +-
 .../supply/mediatek/charger_begonia/rt9471.c  |   2 +-
 .../charger_begonia/smb1351-charger.c         |  72 +-
 .../mediatek/misc/mtk_gauge_time_service.c    |   8 +-
 .../power/supply/mediatek/mtk_pep20_intf.c    |   4 +-
 drivers/power/supply/mediatek/mtk_pep_intf.c  |   4 +-
 drivers/thermal/cpu_cooling.c                 |  73 +-
 drivers/thermal/thermal_core.c                | 286 ++++++-
 include/linux/cpufreq.h                       |   2 +
 net/ipv6/addrconf.c                           |   4 +-
 net/sched/cls_bpf.c                           |   2 +
 244 files changed, 3346 insertions(+), 2891 deletions(-)
 create mode 100644 drivers/misc/mediatek/gpu/ged/include/ged_ski.h
 create mode 100644 drivers/misc/mediatek/gpu/ged/src/ged_ski.c

diff --git a/arch/arm64/configs/begonia_user_defconfig b/arch/arm64/configs/begonia_user_defconfig
index e4e9a2788..c09cbef31 100644
--- a/arch/arm64/configs/begonia_user_defconfig
+++ b/arch/arm64/configs/begonia_user_defconfig
@@ -209,12 +209,12 @@ CONFIG_TCPC_CLASS=y
 CONFIG_USB_POWER_DELIVERY=y
 CONFIG_MTK_LOAD_TRACKER=y
 CONFIG_MTK_CPU_CTRL_CFP=y
-CONFIG_MTK_PERF_OBSERVER=y
+# CONFIG_MTK_PERF_OBSERVER is not set
 CONFIG_MTK_RESYM=y
 CONFIG_MTK_FPSGO_V3=y
 CONFIG_MTK_EARA_THERMAL=y
-CONFIG_MTK_PERF_TRACKER=y
-CONFIG_MTK_LOWMEM_HINT=y
+# CONFIG_MTK_PERF_TRACKER is not set
+# CONFIG_MTK_LOWMEM_HINT is not set
 CONFIG_MTPROF=y
 CONFIG_ANDROID_DEFAULT_SETTING=y
 CONFIG_MTK_ANDROID_DEFAULT_SETTING=y
@@ -446,8 +446,8 @@ CONFIG_SCHEDSTATS=y
 # CONFIG_DEBUG_BUGVERBOSE is not set
 CONFIG_RCU_CPU_STALL_TIMEOUT=60
 CONFIG_FAULT_INJECTION=y
-CONFIG_ENABLE_DEFAULT_TRACERS=y
-CONFIG_MTK_SCHED_TRACERS=y
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_MTK_SCHED_TRACERS is not set
 CONFIG_STATIC_USERMODEHELPER_PATH="/system_ext/bin/aee_core_forwarder"
 CONFIG_SECURITY_SELINUX_DEVELOP=y
 CONFIG_CRYPTO_TWOFISH=y
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index d136c503d..15e380c21 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -2239,6 +2239,10 @@ static int cpufreq_set_policy(struct cpufreq_policy *policy,
 	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
 			CPUFREQ_ADJUST, new_policy);
 
+	/* the adjusted frequency should not exceed thermal limit*/
+	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+			CPUFREQ_THERMAL, new_policy);
+
 	/*
 	 * verify the cpu speed can be set within this limit, which might be
 	 * different to the first one
diff --git a/drivers/misc/mediatek/Kconfig.default b/drivers/misc/mediatek/Kconfig.default
index 1c358767c..b60eb0074 100644
--- a/drivers/misc/mediatek/Kconfig.default
+++ b/drivers/misc/mediatek/Kconfig.default
@@ -42,9 +42,6 @@ config ANDROID_DEFAULT_SETTING
 	select CRYPTO_SHA256
 	select CRYPTO_SHA512
 	select CRYPTO_XCBC
-	select DEBUG_LIST
-	select DEBUG_RODATA
-	select DEBUG_SET_MODULE_RONX
 	select DEFAULT_SECURITY_SELINUX
 	select DM_SNAPSHOT
 	select DM_VERITY
@@ -233,7 +230,6 @@ config ANDROID_DEFAULT_SETTING
 	select STAGING
 	select STATIC_USERMODEHELPER
 	select STRICT_KERNEL_RWX
-	select STRICT_MODULE_RWX
 	select SUSPEND
 	select SWP_EMULATION if ARMV8_DEPRECATED
 	select SYNC_FILE
diff --git a/drivers/misc/mediatek/Makefile b/drivers/misc/mediatek/Makefile
index 9fa3c8607..fec7c9bbc 100755
--- a/drivers/misc/mediatek/Makefile
+++ b/drivers/misc/mediatek/Makefile
@@ -13,7 +13,6 @@
 
 #$(call all-subdir-src-or-makefile)
 export MTK_PLATFORM := $(subst ",,$(CONFIG_MTK_PLATFORM))
-subdir-ccflags-y += -Werror
 
 subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/include
 subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/
@@ -32,7 +31,9 @@ obj-$(CONFIG_MTK_M4U)   += m4u/
 obj-$(CONFIG_MTK_PSEUDO_M4U)   += pseudo_m4u/
 obj-$(CONFIG_MTK_ICE_DEBUG) += ice_debug/
 obj-y += mmdvfs/
+ifneq ($(CONFIG_MTK_SYSTRACKER_DISABLE),y)
 obj-$(CONFIG_MTK_SYSTRACKER_V2)   += systracker/
+endif
 
 obj-$(CONFIG_MTK_IRRX) += irrx/
 
diff --git a/drivers/misc/mediatek/base/power/clkbuf_v1/mt6785/mtk_clkbuf_hw.c b/drivers/misc/mediatek/base/power/clkbuf_v1/mt6785/mtk_clkbuf_hw.c
index 1cf168389..3cc2eb3d6 100644
--- a/drivers/misc/mediatek/base/power/clkbuf_v1/mt6785/mtk_clkbuf_hw.c
+++ b/drivers/misc/mediatek/base/power/clkbuf_v1/mt6785/mtk_clkbuf_hw.c
@@ -301,7 +301,7 @@ static void clk_buf_ctrl_bblpm_mask(enum clk_buf_id id, bool onoff)
 			PMIC_XO_EXTBUF7_BBLPM_EN_MASK_SHIFT);
 		break;
 	default:
-		pr_info("%s: id=%d isn't supported\n", __func__, id);
+		pr_debug("%s: id=%d isn't supported\n", __func__, id);
 		break;
 	}
 
@@ -407,7 +407,7 @@ static void clk_buf_ctrl_internal(enum clk_buf_id id, enum clk_buf_onff onoff)
 				(pwrap_dcxo_en_init & DCXO_CONN_ENABLE);
 			clkbuf_writel(DCXO_ENABLE, pwrap_dcxo_en);
 		}
-		pr_info("%s: id=%d, onoff=%d, DCXO_ENABLE=0x%x\n",
+		pr_debug("%s: id=%d, onoff=%d, DCXO_ENABLE=0x%x\n",
 			__func__, id, onoff, clkbuf_readl(DCXO_ENABLE));
 
 		break;
@@ -448,7 +448,7 @@ static void clk_buf_ctrl_internal(enum clk_buf_id id, enum clk_buf_onff onoff)
 				(pwrap_dcxo_en_init & DCXO_NFC_ENABLE);
 			clkbuf_writel(DCXO_ENABLE, pwrap_dcxo_en);
 		}
-		pr_info("%s: id=%d, onoff=%d, DCXO_ENABLE=0x%x\n",
+		pr_debug("%s: id=%d, onoff=%d, DCXO_ENABLE=0x%x\n",
 			__func__, id, onoff, clkbuf_readl(DCXO_ENABLE));
 		break;
 	case CLK_BUF_RF:
@@ -478,7 +478,7 @@ static void clk_buf_ctrl_internal(enum clk_buf_id id, enum clk_buf_onff onoff)
 				PMIC_XO_EXTBUF4_MODE_MASK,
 				PMIC_XO_EXTBUF4_MODE_SHIFT);
 		}
-		pr_info("%s: id=%d, onoff=%d\n", __func__, id, onoff);
+		pr_debug("%s: id=%d, onoff=%d\n", __func__, id, onoff);
 		break;
 	case CLK_BUF_UFS:
 		if (onoff == CLK_BUF_FORCE_ON) {
@@ -510,10 +510,10 @@ static void clk_buf_ctrl_internal(enum clk_buf_id id, enum clk_buf_onff onoff)
 				PMIC_XO_EXTBUF7_MODE_SHIFT);
 			clk_buf7_ctrl = true;
 		}
-		pr_info("%s: id=%d, onoff=%d\n", __func__, id, onoff);
+		pr_debug("%s: id=%d, onoff=%d\n", __func__, id, onoff);
 		break;
 	default:
-		pr_info("%s: id=%d isn't supported\n", __func__, id);
+		pr_debug("%s: id=%d isn't supported\n", __func__, id);
 		break;
 	}
 
@@ -536,7 +536,7 @@ static void pmic_clk_buf_ctrl(enum CLK_BUF_SWCTRL_STATUS_T *status)
 		PMIC_REG_MASK, PMIC_REG_SHIFT);
 	pmic_read_interface(PMIC_DCXO_CW09, &pmic_cw09,
 		PMIC_REG_MASK, PMIC_REG_SHIFT);
-	pr_info("%s DCXO_CW00=0x%x, CW09=0x%x, clk_buf_swctrl=[%u %u %u %u 0 0 %u]\n",
+	pr_debug("%s DCXO_CW00=0x%x, CW09=0x%x, clk_buf_swctrl=[%u %u %u %u 0 0 %u]\n",
 		__func__, pmic_cw00, pmic_cw09, status[XO_SOC], status[XO_WCN],
 		status[XO_NFC], status[XO_CEL], status[XO_EXT]);
 }
@@ -583,7 +583,7 @@ static int clk_buf_mode_set(enum clk_buf_id id)
 		break;
 	default:
 		ret = -5;
-		pr_info("%s: id=%d isn't supported\n", __func__, id);
+		pr_debug("%s: id=%d isn't supported\n", __func__, id);
 		break;
 	}
 
@@ -615,7 +615,7 @@ bool clk_buf_ctrl_combine(enum clk_buf_id id, bool onoff)
 	case CLK_BUF_BB_MD:
 		if (CLK_BUF1_STATUS != CLOCK_BUFFER_SW_CONTROL) {
 			ret = -1;
-			pr_info("%s: id=%d isn't controlled by SW\n",
+			pr_debug("%s: id=%d isn't controlled by SW\n",
 				__func__, id);
 			break;
 		}
@@ -679,7 +679,7 @@ bool clk_buf_ctrl_combine(enum clk_buf_id id, bool onoff)
 					PMIC_XO_EXTBUF4_MODE_SHIFT);
 			else if (val < 0) {
 				val = 0 - val;
-				pr_info("%s val = %d\n", __func__, val);
+				pr_debug("%s val = %d\n", __func__, val);
 				pmic_config_interface(PMIC_DCXO_CW00_SET,
 					val,
 					PMIC_XO_EXTBUF4_MODE_MASK,
@@ -711,7 +711,7 @@ bool clk_buf_ctrl_combine(enum clk_buf_id id, bool onoff)
 		break;
 	default:
 		ret = -1;
-		pr_info("%s: id=%d isn't supported\n", __func__, id);
+		pr_debug("%s: id=%d isn't supported\n", __func__, id);
 		break;
 	}
 
@@ -749,7 +749,7 @@ bool clk_buf_ctrl(enum clk_buf_id id, bool onoff)
 	case CLK_BUF_BB_MD:
 		if (CLK_BUF1_STATUS != CLOCK_BUFFER_SW_CONTROL) {
 			ret = -1;
-			pr_info("%s: id=%d isn't controlled by SW\n",
+			pr_debug("%s: id=%d isn't controlled by SW\n",
 				__func__, id);
 			break;
 		}
@@ -757,7 +757,7 @@ bool clk_buf_ctrl(enum clk_buf_id id, bool onoff)
 	case CLK_BUF_CONN:
 		if (CLK_BUF2_STATUS != CLOCK_BUFFER_SW_CONTROL) {
 			ret = -1;
-			pr_info("%s: id=%d isn't controlled by SW\n",
+			pr_debug("%s: id=%d isn't controlled by SW\n",
 				__func__, id);
 			break;
 		}
@@ -767,7 +767,7 @@ bool clk_buf_ctrl(enum clk_buf_id id, bool onoff)
 	case CLK_BUF_NFC:
 		if (CLK_BUF3_STATUS != CLOCK_BUFFER_SW_CONTROL) {
 			ret = -1;
-			pr_info("%s: id=%d isn't controlled by SW\n",
+			pr_debug("%s: id=%d isn't controlled by SW\n",
 				__func__, id);
 			break;
 		}
@@ -777,7 +777,7 @@ bool clk_buf_ctrl(enum clk_buf_id id, bool onoff)
 	case CLK_BUF_RF:
 		if (CLK_BUF4_STATUS != CLOCK_BUFFER_SW_CONTROL) {
 			ret = -1;
-			pr_info("%s: id=%d isn't controlled by SW\n",
+			pr_debug("%s: id=%d isn't controlled by SW\n",
 				__func__, id);
 			break;
 		}
@@ -786,7 +786,7 @@ bool clk_buf_ctrl(enum clk_buf_id id, bool onoff)
 		if ((CLK_BUF7_STATUS != CLOCK_BUFFER_SW_CONTROL) ||
 			(clk_buf7_ctrl != true)) {
 			ret = -1;
-			pr_info("%s: id=%d isn't controlled by SW\n",
+			pr_debug("%s: id=%d isn't controlled by SW\n",
 				__func__, id);
 			break;
 		}
@@ -795,7 +795,7 @@ bool clk_buf_ctrl(enum clk_buf_id id, bool onoff)
 		break;
 	default:
 		ret = -1;
-		pr_info("%s: id=%d isn't supported\n", __func__, id);
+		pr_debug("%s: id=%d isn't supported\n", __func__, id);
 		break;
 	}
 
@@ -811,12 +811,12 @@ EXPORT_SYMBOL(clk_buf_ctrl);
 
 void clk_buf_dump_dts_log(void)
 {
-	pr_info("%s: CLK_BUF?_STATUS=%d %d %d %d %d %d %d\n", __func__,
+	pr_debug("%s: CLK_BUF?_STATUS=%d %d %d %d %d %d %d\n", __func__,
 		     CLK_BUF1_STATUS, CLK_BUF2_STATUS,
 		     CLK_BUF3_STATUS, CLK_BUF4_STATUS,
 		     CLK_BUF5_STATUS, CLK_BUF6_STATUS,
 		     CLK_BUF7_STATUS);
-	pr_info("%s: CLK_BUF?_OUTPUT_IMPEDANCE=%d %d %d %d %d %d %d\n",
+	pr_debug("%s: CLK_BUF?_OUTPUT_IMPEDANCE=%d %d %d %d %d %d %d\n",
 		     __func__,
 		     CLK_BUF1_OUTPUT_IMPEDANCE,
 		     CLK_BUF2_OUTPUT_IMPEDANCE,
@@ -825,7 +825,7 @@ void clk_buf_dump_dts_log(void)
 		     CLK_BUF5_OUTPUT_IMPEDANCE,
 		     CLK_BUF6_OUTPUT_IMPEDANCE,
 		     CLK_BUF7_OUTPUT_IMPEDANCE);
-	pr_info("%s: CLK_BUF?_CONTROLS_DESENSE=%d %d %d %d %d %d %d\n",
+	pr_debug("%s: CLK_BUF?_CONTROLS_DESENSE=%d %d %d %d %d %d %d\n",
 		     __func__,
 		     CLK_BUF1_CONTROLS_DESENSE,
 		     CLK_BUF2_CONTROLS_DESENSE,
@@ -867,10 +867,10 @@ void clk_buf_dump_clkbuf_log(void)
 		PMIC_RG_LDO_VRFCK_EN_MASK, PMIC_RG_LDO_VRFCK_EN_SHIFT);
 	pmic_read_interface(PMIC_RG_LDO_VBBCK_EN_ADDR, &ldo_vbbck_en,
 		 PMIC_RG_LDO_VBBCK_EN_MASK, PMIC_RG_LDO_VBBCK_EN_SHIFT);
-	pr_info("%s DCXO_CW00/09/12/13/15/19=0x%x %x %x %x %x %x\n",
+	pr_debug("%s DCXO_CW00/09/12/13/15/19=0x%x %x %x %x %x %x\n",
 		     __func__, pmic_cw00, pmic_cw09, pmic_cw12, pmic_cw13,
 		     pmic_cw15, pmic_cw19);
-	pr_info("%s in3_en/rf_op/bb_op/rf_en/bb_en=0x%x %x %x %x %x\n",
+	pr_debug("%s in3_en/rf_op/bb_op/rf_en/bb_en=0x%x %x %x %x %x\n",
 		     __func__, top_spi_con1, ldo_vrfck_op, ldo_vbbck_op,
 		     ldo_vrfck_en, ldo_vbbck_en);
 }
@@ -905,7 +905,7 @@ static void clk_buf_get_xo_en(void)
 	xo_en_stat[XO_PD] = (rg_auxout & (0x1 << 5)) >> 5;
 	xo_en_stat[XO_EXT] = (rg_auxout & (0x1 << 3)) >> 3;
 
-	pr_info("%s: EN_STAT=%d %d %d %d %d %d\n",
+	pr_debug("%s: EN_STAT=%d %d %d %d %d %d\n",
 		__func__,
 		xo_en_stat[XO_SOC],
 		xo_en_stat[XO_WCN],
@@ -929,7 +929,7 @@ static void clk_buf_get_bblpm_en(void)
 		__func__, rg_auxout);
 	xo_bb_lpm_en_o = (rg_auxout & (0x1 << 15)) >> 15;
 
-	pr_info("%s: bblpm %d %d\n",
+	pr_debug("%s: bblpm %d %d\n",
 		__func__,
 		xo_bb_lpm_en_stat,
 		xo_bb_lpm_en_o);
@@ -1128,11 +1128,11 @@ void clk_buf_show_status_info(void)
 		len = clk_buf_show_status_info_internal(buf);
 		str = buf;
 		while ((str_sep = strsep(&str, ".")) != NULL)
-			pr_info("%s\n", str_sep);
+			pr_debug("%s\n", str_sep);
 
 		vfree(buf);
 	} else
-		pr_info("%s: allocate memory fail\n", __func__);
+		pr_debug("%s: allocate memory fail\n", __func__);
 }
 
 #ifdef CONFIG_PM
@@ -1179,7 +1179,7 @@ static ssize_t clk_buf_ctrl_store(struct kobject *kobj,
 		}
 
 		clkbuf_writel(DCXO_ENABLE, pwrap_dcxo_en);
-		pr_info("%s: DCXO_ENABLE=0x%x, pwrap_dcxo_en=0x%x\n",
+		pr_debug("%s: DCXO_ENABLE=0x%x, pwrap_dcxo_en=0x%x\n",
 			__func__, clkbuf_readl(DCXO_ENABLE),
 			pwrap_dcxo_en);
 
@@ -1269,7 +1269,7 @@ static ssize_t clk_buf_debug_store(struct kobject *kobj,
 
 	return count;
 ERROR_CMD:
-	pr_info("bad argument!! please follow correct format\n");
+	pr_debug("bad argument!! please follow correct format\n");
 	return -EPERM;
 }
 
@@ -1291,10 +1291,10 @@ static ssize_t clk_buf_bblpm_store(struct kobject *kobj,
 	int ret = 0;
 
 	if ((kstrtouint(buf, 10, &onoff))) {
-		pr_info("bblpm input error\n");
+		pr_debug("bblpm input error\n");
 		return -EPERM;
 	}
-	pr_info("bblpm input = %d\n", onoff);
+	pr_debug("bblpm input = %d\n", onoff);
 	if (onoff == 1)
 		ret = clk_buf_ctrl_bblpm_sw(true);
 	else if (onoff == 0)
@@ -1355,7 +1355,7 @@ int clk_buf_fs_init(void)
 	/* create /sys/power/clk_buf/xxx */
 	r = sysfs_create_group(power_kobj, &clk_buf_attr_group);
 	if (r)
-		pr_notice("FAILED TO CREATE /sys/power/clk_buf (%d)\n", r);
+		pr_debug("FAILED TO CREATE /sys/power/clk_buf (%d)\n", r);
 
 	return r;
 }
@@ -1411,7 +1411,7 @@ int clk_buf_dts_map(void)
 			CLK_BUF7_CONTROLS_DESENSE = vals[6];
 		}
 	} else {
-		pr_notice("%s can't find compatible node for pmic_clock_buffer\n",
+		pr_debug("%s can't find compatible node for pmic_clock_buffer\n",
 			__func__);
 		return -1;
 	}
@@ -1419,7 +1419,7 @@ int clk_buf_dts_map(void)
 	if (node)
 		pwrap_base = of_iomap(node, 0);
 	else {
-		pr_notice("%s can't find compatible node for pwrap\n",
+		pr_debug("%s can't find compatible node for pwrap\n",
 			__func__);
 		return -1;
 	}
@@ -1492,7 +1492,7 @@ void clk_buf_init_pmic_swctrl(void)
 short is_clkbuf_bringup(void)
 {
 #ifdef CLKBUF_BRINGUP
-	pr_info("%s: skipped for bring up\n", __func__);
+	pr_debug("%s: skipped for bring up\n", __func__);
 	return 1;
 #else
 	return 0;
diff --git a/drivers/misc/mediatek/base/power/clkbuf_v1/mtk_clkbuf_ctl.c b/drivers/misc/mediatek/base/power/clkbuf_v1/mtk_clkbuf_ctl.c
index ffe8e0809..7d2422154 100644
--- a/drivers/misc/mediatek/base/power/clkbuf_v1/mtk_clkbuf_ctl.c
+++ b/drivers/misc/mediatek/base/power/clkbuf_v1/mtk_clkbuf_ctl.c
@@ -54,7 +54,7 @@ void __attribute__((weak)) clk_buf_dump_clkbuf_log(void)
 
 int __attribute__((weak)) clk_buf_fs_init(void)
 {
-	pr_info("%s: dummy func\n", __func__);
+	pr_debug("%s: dummy func\n", __func__);
 	return 0;
 }
 
diff --git a/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform.c b/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform.c
index 57914942a..45b5aa0d2 100644
--- a/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform.c
+++ b/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform.c
@@ -97,7 +97,7 @@ static int *vcore_opp_bw_ptr(int idx)
 		return VCORE_OPP_BW_PTR(0);
 	}
 
-	pr_info("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
+	pr_debug("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
 	return NULL;
 };
 
@@ -302,11 +302,11 @@ static int cm_mgr_check_dram_type(void)
 
 	if (ddr_type == TYPE_LPDDR4X || ddr_type == TYPE_LPDDR4)
 		cm_mgr_idx = CM_MGR_LP4;
-	pr_info("#@# %s(%d) ddr_type 0x%x, ddr_hz %d, cm_mgr_idx 0x%x\n",
+	pr_debug("#@# %s(%d) ddr_type 0x%x, ddr_hz %d, cm_mgr_idx 0x%x\n",
 			__func__, __LINE__, ddr_type, ddr_hz, cm_mgr_idx);
 #else
 	cm_mgr_idx = 0;
-	pr_info("#@# %s(%d) NO CONFIG_MTK_DRAMC !!! set cm_mgr_idx to 0x%x\n",
+	pr_debug("#@# %s(%d) NO CONFIG_MTK_DRAMC !!! set cm_mgr_idx to 0x%x\n",
 			__func__, __LINE__, cm_mgr_idx);
 #endif /* CONFIG_MTK_DRAMC */
 
@@ -566,14 +566,14 @@ static int cm_mgr_fb_notifier_callback(struct notifier_block *self,
 
 	switch (blank) {
 	case FB_BLANK_UNBLANK:
-		pr_info("#@# %s(%d) SCREEN ON\n", __func__, __LINE__);
+		pr_debug("#@# %s(%d) SCREEN ON\n", __func__, __LINE__);
 		cm_mgr_blank_status = 0;
 #if defined(CONFIG_MTK_TINYSYS_SSPM_SUPPORT) && defined(USE_CM_MGR_AT_SSPM)
 		cm_mgr_to_sspm_command(IPI_CM_MGR_BLANK, 0);
 #endif /* CONFIG_MTK_TINYSYS_SSPM_SUPPORT */
 		break;
 	case FB_BLANK_POWERDOWN:
-		pr_info("#@# %s(%d) SCREEN OFF\n", __func__, __LINE__);
+		pr_debug("#@# %s(%d) SCREEN OFF\n", __func__, __LINE__);
 		cm_mgr_blank_status = 1;
 		cm_mgr_set_dram_level(-1);
 		cm_mgr_dram_opp_base = -1;
@@ -768,10 +768,10 @@ int cm_mgr_register_init(void)
 	node = of_find_compatible_node(NULL, NULL,
 			"mediatek,mcucfg_mp0_counter");
 	if (!node)
-		pr_info("find mcucfg_mp0_counter node failed\n");
+		pr_debug("find mcucfg_mp0_counter node failed\n");
 	mcucfg_mp0_counter_base = of_iomap(node, 0);
 	if (!mcucfg_mp0_counter_base) {
-		pr_info("base mcucfg_mp0_counter_base failed\n");
+		pr_debug("base mcucfg_mp0_counter_base failed\n");
 		return -1;
 	}
 
@@ -806,7 +806,7 @@ int cm_mgr_platform_init(void)
 
 	r = cm_mgr_register_init();
 	if (r) {
-		pr_info("FAILED TO CREATE REGISTER(%d)\n", r);
+		pr_debug("FAILED TO CREATE REGISTER(%d)\n", r);
 		return r;
 	}
 
@@ -814,7 +814,7 @@ int cm_mgr_platform_init(void)
 
 	r = fb_register_client(&cm_mgr_fb_notifier);
 	if (r) {
-		pr_info("FAILED TO REGISTER FB CLIENT (%d)\n", r);
+		pr_debug("FAILED TO REGISTER FB CLIENT (%d)\n", r);
 		return r;
 	}
 
diff --git a/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform_data.h b/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform_data.h
index 8ae7b0762..872b914f6 100644
--- a/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform_data.h
+++ b/drivers/misc/mediatek/base/power/cm_mgr_v1/mt6785/mtk_cm_mgr_platform_data.h
@@ -117,7 +117,7 @@ static int vcore_power_array_size(int idx)
 		return VCORE_POWER_ARRAY_SIZE(0);
 	}
 
-	pr_info("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
+	pr_debug("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
 	return 0;
 };
 
@@ -128,7 +128,7 @@ static int *vcore_power_gain_ptr(int idx)
 		return VCORE_POWER_GAIN_PTR(0);
 	}
 
-	pr_info("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
+	pr_debug("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
 	return NULL;
 };
 
@@ -287,7 +287,7 @@ static unsigned int *_cpu_power_gain_ptr(int isUP, int isLow, int idx)
 		break;
 	}
 
-	pr_info("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
+	pr_debug("#@# %s(%d) warning value %d\n", __func__, __LINE__, idx);
 	return NULL;
 };
 
diff --git a/drivers/misc/mediatek/base/power/cm_mgr_v1/mtk_cm_mgr.c b/drivers/misc/mediatek/base/power/cm_mgr_v1/mtk_cm_mgr.c
index aa60df2b1..40672c2bd 100644
--- a/drivers/misc/mediatek/base/power/cm_mgr_v1/mtk_cm_mgr.c
+++ b/drivers/misc/mediatek/base/power/cm_mgr_v1/mtk_cm_mgr.c
@@ -191,7 +191,7 @@ static int cm_mgr_check_up_status(int level, int *cpu_ratio_idx)
 		if (vcore_dram_opp != CM_MGR_EMI_OPP) {
 			vcore_dram_opp = CM_MGR_EMI_OPP;
 #ifdef DEBUG_CM_MGR
-			pr_info("#@# %s(%d) vcore_dram_opp %d->%d\n",
+			pr_debug("#@# %s(%d) vcore_dram_opp %d->%d\n",
 					__func__, __LINE__,
 					vcore_dram_opp_cur, vcore_dram_opp);
 #endif /* DEBUG_CM_MGR */
@@ -205,7 +205,7 @@ static int cm_mgr_check_up_status(int level, int *cpu_ratio_idx)
 	idx = level;
 	vcore_power_up = vcore_power_gain(vcore_power_gain, total_bw, idx);
 #ifdef DEBUG_CM_MGR
-	pr_info("#@# vcore_power_up %d < cpu_power_total %d\n",
+	pr_debug("#@# vcore_power_up %d < cpu_power_total %d\n",
 			vcore_power_up, cpu_power_total);
 #endif /* DEBUG_CM_MGR */
 	if ((vcore_power_up * vcore_power_ratio_up[idx]) <
@@ -216,7 +216,7 @@ static int cm_mgr_check_up_status(int level, int *cpu_ratio_idx)
 				debounce_times_up = 0;
 			vcore_dram_opp = vcore_dram_opp_cur - 1;
 #ifdef DEBUG_CM_MGR
-			pr_info("#@# %s(%d) vcore_dram_opp up %d->%d\n",
+			pr_debug("#@# %s(%d) vcore_dram_opp up %d->%d\n",
 					__func__, __LINE__,
 					vcore_dram_opp_cur, vcore_dram_opp);
 #endif /* DEBUG_CM_MGR */
@@ -277,7 +277,7 @@ static int cm_mgr_check_down_status(int level, int *cpu_ratio_idx)
 		if (vcore_dram_opp != CM_MGR_EMI_OPP) {
 			vcore_dram_opp = CM_MGR_EMI_OPP;
 #ifdef DEBUG_CM_MGR
-			pr_info("#@# %s(%d) vcore_dram_opp %d->%d\n",
+			pr_debug("#@# %s(%d) vcore_dram_opp %d->%d\n",
 					__func__, __LINE__,
 					vcore_dram_opp_cur, vcore_dram_opp);
 #endif /* DEBUG_CM_MGR */
@@ -291,7 +291,7 @@ static int cm_mgr_check_down_status(int level, int *cpu_ratio_idx)
 	idx = level - 1;
 	vcore_power_down = vcore_power_gain(vcore_power_gain, total_bw, idx);
 #ifdef DEBUG_CM_MGR
-	pr_info("#@# vcore_power_down %d > cpu_power_total %d\n",
+	pr_debug("#@# vcore_power_down %d > cpu_power_total %d\n",
 			vcore_power_down, cpu_power_total);
 #endif /* DEBUG_CM_MGR */
 	if ((vcore_power_down * vcore_power_ratio_down[idx]) >
@@ -302,7 +302,7 @@ static int cm_mgr_check_down_status(int level, int *cpu_ratio_idx)
 				debounce_times_down = 0;
 			vcore_dram_opp = vcore_dram_opp_cur + 1;
 #ifdef DEBUG_CM_MGR
-			pr_info("#@# %s(%d) vcore_dram_opp down %d->%d\n",
+			pr_debug("#@# %s(%d) vcore_dram_opp down %d->%d\n",
 					__func__, __LINE__,
 					vcore_dram_opp_cur, vcore_dram_opp);
 #endif /* DEBUG_CM_MGR */
@@ -778,16 +778,16 @@ int cm_mgr_to_sspm_command(u32 cmd, int val)
 		ret = sspm_ipi_send_sync(IPI_ID_CM, IPI_OPT_POLLING,
 				&cm_mgr_d, CM_MGR_D_LEN, &ack_data, 1);
 		if (ret != 0) {
-			pr_info("#@# %s(%d) cmd(%d) error, return %d\n",
+			pr_debug("#@# %s(%d) cmd(%d) error, return %d\n",
 					__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			pr_info("#@# %s(%d) cmd(%d) return %d\n",
+			pr_debug("#@# %s(%d) cmd(%d) return %d\n",
 					__func__, __LINE__, cmd, ret);
 		}
 		break;
 	default:
-		pr_info("#@# %s(%d) wrong cmd(%d)!!!\n",
+		pr_debug("#@# %s(%d) wrong cmd(%d)!!!\n",
 				__func__, __LINE__, cmd);
 		break;
 	}
@@ -1046,25 +1046,25 @@ static void cm_mgr_update_fw(void)
 				CPU_FW_FILE, j);
 		err = request_firmware(&fw, CPU_FW_FILE, &cm_mgr_device);
 		if (err)
-			pr_info("Failed to load %s, err = %d.\n",
+			pr_debug("Failed to load %s, err = %d.\n",
 					CPU_FW_FILE, err);
 	} while (err == -EAGAIN && j < 5);
 	if (err)
-		pr_info("Failed to load %s, err = %d.\n",
+		pr_debug("Failed to load %s, err = %d.\n",
 				CPU_FW_FILE, err);
 
 	if (!err) {
-		pr_info("request_firmware() %s, size 0x%x\n",
+		pr_debug("request_firmware() %s, size 0x%x\n",
 				CPU_FW_FILE, (int)fw->size);
 		update++;
 
 		for (count = 0; count < CM_MGR_MAX; count++) {
 			copy_size = vcore_power_array_size(count) *
 				VCORE_ARRAY_SIZE * sizeof(unsigned int);
-			pr_info("offset 0x%x, copy_size 0x%x\n",
+			pr_debug("offset 0x%x, copy_size 0x%x\n",
 					offset, copy_size);
 			if (fw->size < (copy_size + offset)) {
-				pr_info("vcore_power_gain_%d 0x%x, 0x%x",
+				pr_debug("vcore_power_gain_%d 0x%x, 0x%x",
 						count, (int)fw->size,
 						copy_size + offset);
 				goto out_fw;
@@ -1079,10 +1079,10 @@ static void cm_mgr_update_fw(void)
 
 			offset += copy_size;
 			copy_size = sizeof(cpu_power_gain_UpLow0);
-			pr_info("offset 0x%x, copy_size 0x%x\n",
+			pr_debug("offset 0x%x, copy_size 0x%x\n",
 					offset, copy_size);
 			if (fw->size < (copy_size + offset)) {
-				pr_info("cpu_power_gain_UpLow%d 0x%x, 0x%x",
+				pr_debug("cpu_power_gain_UpLow%d 0x%x, 0x%x",
 						count,
 						(int)fw->size,
 						copy_size + offset);
@@ -1094,10 +1094,10 @@ static void cm_mgr_update_fw(void)
 
 			offset += copy_size;
 			copy_size = sizeof(cpu_power_gain_DownLow0);
-			pr_info("offset 0x%x, copy_size 0x%x\n",
+			pr_debug("offset 0x%x, copy_size 0x%x\n",
 					offset, copy_size);
 			if (fw->size < (copy_size + offset)) {
-				pr_info("cpu_power_gain_DownLow%d 0x%x, 0x%x",
+				pr_debug("cpu_power_gain_DownLow%d 0x%x, 0x%x",
 						count,
 						(int)fw->size,
 						copy_size + offset);
@@ -1109,10 +1109,10 @@ static void cm_mgr_update_fw(void)
 
 			offset += copy_size;
 			copy_size = sizeof(cpu_power_gain_UpHigh0);
-			pr_info("offset 0x%x, copy_size 0x%x\n",
+			pr_debug("offset 0x%x, copy_size 0x%x\n",
 					offset, copy_size);
 			if (fw->size < (copy_size + offset)) {
-				pr_info("cpu_power_gain_UpHigh%d 0x%x, 0x%x",
+				pr_debug("cpu_power_gain_UpHigh%d 0x%x, 0x%x",
 						count,
 						(int)fw->size,
 						copy_size + offset);
@@ -1124,10 +1124,10 @@ static void cm_mgr_update_fw(void)
 
 			offset += copy_size;
 			copy_size = sizeof(cpu_power_gain_DownHigh0);
-			pr_info("offset 0x%x, copy_size 0x%x\n",
+			pr_debug("offset 0x%x, copy_size 0x%x\n",
 					offset, copy_size);
 			if (fw->size < (copy_size + offset)) {
-				pr_info("cpu_power_gain_DownHigh%d 0x%x, 0x%x",
+				pr_debug("cpu_power_gain_DownHigh%d 0x%x, 0x%x",
 						count,
 						(int)fw->size,
 						copy_size + offset);
@@ -1141,9 +1141,9 @@ static void cm_mgr_update_fw(void)
 
 		offset += copy_size;
 		copy_size = sizeof(_v2f_all);
-		pr_info("offset 0x%x, copy_size 0x%x\n", offset, copy_size);
+		pr_debug("offset 0x%x, copy_size 0x%x\n", offset, copy_size);
 		if (fw->size < (copy_size + offset)) {
-			pr_info("_v2f_all 0x%x, 0x%x",
+			pr_debug("_v2f_all 0x%x, 0x%x",
 					(int)fw->size, copy_size + offset);
 			goto out_fw;
 		}
@@ -1394,7 +1394,7 @@ static int create_cm_mgr_debug_fs(void)
 	/* create /proc/cm_mgr */
 	dir = proc_mkdir("cm_mgr", NULL);
 	if (!dir) {
-		pr_info("fail to create /proc/cm_mgr @ %s()\n", __func__);
+		pr_debug("fail to create /proc/cm_mgr @ %s()\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -1402,7 +1402,7 @@ static int create_cm_mgr_debug_fs(void)
 		if (!proc_create_data
 		    (entries[i].name, 0660,
 		     dir, entries[i].fops, entries[i].data))
-			pr_info("%s(), create /proc/cm_mgr/%s failed\n",
+			pr_debug("%s(), create /proc/cm_mgr/%s failed\n",
 					__func__,
 				    entries[i].name);
 	}
@@ -1423,13 +1423,13 @@ int __init cm_mgr_module_init(void)
 
 	r = create_cm_mgr_debug_fs();
 	if (r) {
-		pr_info("FAILED TO CREATE DEBUG FILESYSTEM (%d)\n", r);
+		pr_debug("FAILED TO CREATE DEBUG FILESYSTEM (%d)\n", r);
 		return r;
 	}
 
 	r = device_register(&cm_mgr_device);
 	if (r) {
-		pr_info("FAILED TO CREATE DEVICE(%d)\n", r);
+		pr_debug("FAILED TO CREATE DEVICE(%d)\n", r);
 		return r;
 	}
 
@@ -1452,7 +1452,7 @@ int __init cm_mgr_module_init(void)
 
 	r = cm_mgr_platform_init();
 	if (r) {
-		pr_info("FAILED TO INIT PLATFORM(%d)\n", r);
+		pr_debug("FAILED TO INIT PLATFORM(%d)\n", r);
 		return r;
 	}
 
diff --git a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mach/mt6785/mtk_cpufreq_platform.c b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mach/mt6785/mtk_cpufreq_platform.c
index 0e2b3f7a8..c107ff5e9 100644
--- a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mach/mt6785/mtk_cpufreq_platform.c
+++ b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mach/mt6785/mtk_cpufreq_platform.c
@@ -634,7 +634,7 @@ unsigned int _mt_cpufreq_get_cpu_level(void)
 	if (efuse_ver == 0x5200)
 		lv = CPU_LEVEL_0;
 
-	tag_pr_info("%d, %d, (%d, %d) efuse_val = 0x%x\n",
+	tag_pr_debug("%d, %d, (%d, %d) efuse_val = 0x%x\n",
 		lv, turbo_flag, UP_SRATE, DOWN_SRATE, val);
 	return lv;
 }
diff --git a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_hybrid.c b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_hybrid.c
index db75d126a..6a8c0a811 100644
--- a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_hybrid.c
+++ b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_hybrid.c
@@ -167,33 +167,33 @@ int Ripi_cpu_dvfs_thread(void *data)
 	int ret;
 #endif
 	memset(pwdata, 0, sizeof(pwdata));
-	/* tag_pr_info("CPU DVFS received thread\n"); */
+	/* tag_pr_debug("CPU DVFS received thread\n"); */
 #ifndef CONFIG_MTK_TINYSYS_MCUPM_SUPPORT
 	cpufreq_act.data = (void *)cpufreq_buf;
 	ret = sspm_ipi_recv_registration_ex(IPI_ID_CPU_DVFS,
 						&cpudvfs_lock, &cpufreq_act);
 	if (ret != 0) {
-		tag_pr_notice
+		tag_pr_debug
 		("Error: ipi_recv_registration CPU DVFS error: %d\n", ret);
 		do {
 			msleep(1000);
 		} while (!kthread_should_stop());
 		return (-1);
 	}
-	/* tag_pr_info("sspm_ipi_recv_registration */
+	/* tag_pr_debug("sspm_ipi_recv_registration */
 	/*IPI_ID_CPU_DVFS pass!!(%d)\n", ret); */
 #else
 	wait_for_completion(&cpuhvfs_setup_done);
 #endif
 	/* an endless loop in which we are doing our work */
 	do {
-		/* tag_pr_info("sspm_ipi_recv_wait IPI_ID_CPU_DVFS\n"); */
+		/* tag_pr_debug("sspm_ipi_recv_wait IPI_ID_CPU_DVFS\n"); */
 #ifdef CONFIG_MTK_TINYSYS_MCUPM_SUPPORT
 		mtk_ipi_recv(&mcupm_ipidev, CH_S_CPU_DVFS);
 #else
 		sspm_ipi_recv_wait(IPI_ID_CPU_DVFS);
 #endif
-		/* tag_pr_info("Info: CPU DVFS thread received ID=%d,*/
+		/* tag_pr_debug("Info: CPU DVFS thread received ID=%d,*/
 		/* i=%d\n", cpufreq_act.id, i); */
 		spin_lock_irqsave(&cpudvfs_lock, flags);
 		if (((cpufreq_buf[0] >= OFFS_LOG_S) &&
@@ -429,7 +429,7 @@ int dvfs_to_mcupm_command(u32 cmd, struct cdvfs_data *cdvfs_d)
 
 		aee_record_cpu_dvfs_cb(7);
 		if (ret != 0) {
-			tag_pr_notice
+			tag_pr_debug
 			("ret = %d, set cluster%d ON/OFF state to %d\n",
 				ret, cdvfs_d->u.set_fv.arg[0],
 				cdvfs_d->u.set_fv.arg[1]);
@@ -438,7 +438,7 @@ int dvfs_to_mcupm_command(u32 cmd, struct cdvfs_data *cdvfs_d)
 			__func__, __LINE__, ret);
 #endif
 		} else if (ack_data < 0) {
-			tag_pr_notice
+			tag_pr_debug
 			("ret = %d, set cluster%d ON/OFF state to %d\n",
 			ret, cdvfs_d->u.set_fv.arg[0],
 			cdvfs_d->u.set_fv.arg[1]);
@@ -662,7 +662,7 @@ int dvfs_to_spm2_command(u32 cmd, struct cdvfs_data *cdvfs_d)
 		cdvfs_d, len, &ack_data, 1);
 		aee_record_cpu_dvfs_cb(7);
 		if (ret != 0) {
-			tag_pr_notice
+			tag_pr_debug
 			("ret = %d, set cluster%d ON/OFF state to %d\n",
 				ret, cdvfs_d->u.set_fv.arg[0],
 				cdvfs_d->u.set_fv.arg[1]);
@@ -671,7 +671,7 @@ int dvfs_to_spm2_command(u32 cmd, struct cdvfs_data *cdvfs_d)
 			__func__, __LINE__, ret);
 #endif
 		} else if (ack_data < 0) {
-			tag_pr_notice
+			tag_pr_debug
 			("ret = %d, set cluster%d ON/OFF state to %d\n",
 			ret, cdvfs_d->u.set_fv.arg[0],
 			cdvfs_d->u.set_fv.arg[1]);
@@ -898,7 +898,7 @@ void srate_doe(void)
 	ret = of_property_read_u32(node, "change_flag", &d->change_flag);
 
 	if (ret)
-		tag_pr_info("Cant find change_flag attr\n");
+		tag_pr_debug("Cant find change_flag attr\n");
 
 	if (!d->change_flag)
 		return;
@@ -906,7 +906,7 @@ void srate_doe(void)
 	/* little up srate */
 	ret = of_property_read_u32(node,
 			"little-rise-time", &d->lt_rs_t);
-	tag_pr_notice("@@~%s DVFS little rise time = %d\n",
+	tag_pr_debug("@@~%s DVFS little rise time = %d\n",
 			__func__, d->lt_rs_t);
 	if (ret)
 		csram_write(OFFS_VOLT2_RISE, UP_SRATE);
@@ -915,7 +915,7 @@ void srate_doe(void)
 	/* little fall srate */
 	ret = of_property_read_u32(node, "little-down-time",
 			&d->lt_dw_t);
-	tag_pr_notice("@@~%s DVFS little down time = %d\n", __func__,
+	tag_pr_debug("@@~%s DVFS little down time = %d\n", __func__,
 			d->lt_dw_t);
 	if (ret)
 		csram_write(OFFS_VOLT2_FALL, DOWN_SRATE);
@@ -924,7 +924,7 @@ void srate_doe(void)
 	/* big raise srate */
 	ret = of_property_read_u32(node, "big-rise-time",
 			&d->bg_rs_t);
-	tag_pr_notice("@@~%s DVFS big raise time = %d\n", __func__,
+	tag_pr_debug("@@~%s DVFS big raise time = %d\n", __func__,
 			d->bg_rs_t);
 	if (ret)
 		csram_write(OFFS_VOLT1_RISE, UP_SRATE);
@@ -934,7 +934,7 @@ void srate_doe(void)
 	/* big fall srate */
 	ret = of_property_read_u32(node, "big-down-time",
 			&d->bg_dw_t);
-	tag_pr_notice("@@~%s DVFS big down time = %d\n", __func__,
+	tag_pr_debug("@@~%s DVFS big down time = %d\n", __func__,
 			d->bg_dw_t);
 	if (ret)
 		csram_write(OFFS_VOLT1_FALL, DOWN_SRATE);
@@ -959,7 +959,7 @@ static int _mt_dvfsp_pdrv_probe(struct platform_device *pdev)
 	ret = of_property_read_u32(pdev->dev.of_node,
 			"change_flag", &d->change_flag);
 	if (ret)
-		tag_pr_info("Cant find change_flag attr\n");
+		tag_pr_debug("Cant find change_flag attr\n");
 	if (d->change_flag) {
 		for (i = 0; i < NR_MT_CPU_DVFS; i++) {
 			flag = 0;
@@ -967,12 +967,12 @@ static int _mt_dvfsp_pdrv_probe(struct platform_device *pdev)
 					d->dtsn[i],
 			d->dts_opp_tbl[i], ARRAY_SIZE(d->dts_opp_tbl[i]));
 			if (ret)
-				tag_pr_info("Cant find %s node\n", d->dtsn[i]);
+				tag_pr_debug("Cant find %s node\n", d->dtsn[i]);
 		else {
 			for (j = 0; j < ARRAY_SIZE(d->dts_opp_tbl[i]); j++) {
 				if (!d->dts_opp_tbl[i][j]) {
 					flag = 1;
-					tag_pr_info
+					tag_pr_debug
 					("@@ %s contain illegal value\n",
 					d->dtsn[i]);
 					break;
@@ -983,7 +983,7 @@ static int _mt_dvfsp_pdrv_probe(struct platform_device *pdev)
 		}
 #if 0
 		for (j = 0; j < NR_FREQ * ARRAY_COL_SIZE; j++)
-			tag_pr_info("@@@ %d pvt[%d] = %u\n",
+			tag_pr_debug("@@@ %d pvt[%d] = %u\n",
 					i, j, d->dts_opp_tbl[i][j]);
 #endif
 	}
@@ -1512,7 +1512,7 @@ void update_pvt_tbl_by_doe(void)
 			memcpy(&(*(recordTbl + (NR_FREQ * i) * ARRAY_COL_SIZE)),
 				d->dts_opp_tbl[i], sizeof(d->dts_opp_tbl[i]));
 #if 0
-			tag_pr_info("@@@[%s] %d update doe_flag = %d\n",
+			tag_pr_debug("@@@[%s] %d update doe_flag = %d\n",
 					__func__, i, d->doe_flag);
 #endif
 		}
@@ -1537,7 +1537,7 @@ void cpuhvfs_pvt_tbl_create(void)
 #endif
 
 	recordRef = ioremap_nocache(DBG_REPO_TBL_S, PVT_TBL_SIZE);
-	tag_pr_info("DVFS - @(Record)%s----->(%p)\n", __func__, recordRef);
+	tag_pr_debug("DVFS - @(Record)%s----->(%p)\n", __func__, recordRef);
 	memset_io((u8 *)recordRef, 0x00, PVT_TBL_SIZE);
 
 	recordTbl = xrecordTbl[lv];
@@ -1633,7 +1633,7 @@ void cpuhvfs_pvt_tbl_create(void)
 
 #ifdef CCI_MAP_TBL_SUPPORT
 	record_CCI_Ref = ioremap_nocache(DBG_REPO_CCI_TBL_S, PVT_CCI_TBL_SIZE);
-	tag_pr_info("DVFS - @(Record)%s----->(%p)\n", __func__, record_CCI_Ref);
+	tag_pr_debug("DVFS - @(Record)%s----->(%p)\n", __func__, record_CCI_Ref);
 	memset_io((u8 *)record_CCI_Ref, 0x00, PVT_CCI_TBL_SIZE);
 
 	record_CCI_Tbl = xrecord_CCI_Tbl[lv];
@@ -1654,11 +1654,11 @@ void cpuhvfs_pvt_tbl_create(void)
 	node = of_find_compatible_node(NULL, NULL, DVFSP_DT_NODE);
 	ret = of_property_read_u32(node, "imax_state", &imax_state);
 	if (ret)
-		tag_pr_info(" %s Cant find imax state node\n", __func__);
+		tag_pr_debug(" %s Cant find imax state node\n", __func__);
 #endif
 	record_IMAX_Ref = ioremap_nocache(DBG_REPO_IMAX_TBL_S,
 			PVT_IMAX_TBL_SIZE);
-	tag_pr_info("DVFS - @(IMAX Record)%s----->(%p)\n", __func__,
+	tag_pr_debug("DVFS - @(IMAX Record)%s----->(%p)\n", __func__,
 			record_IMAX_Ref);
 	memset_io((u8 *)record_IMAX_Ref, 0x00, PVT_IMAX_TBL_SIZE);
 
@@ -1733,7 +1733,7 @@ static int create_cpuhvfs_debug_fs(void)
 	/* create /proc/cpuhvfs */
 	dir = proc_mkdir("cpuhvfs", NULL);
 	if (!dir) {
-		tag_pr_notice("fail to create /proc/cpuhvfs @ %s()\n",
+		tag_pr_debug("fail to create /proc/cpuhvfs @ %s()\n",
 								__func__);
 		return -ENOMEM;
 	}
@@ -1741,7 +1741,7 @@ static int create_cpuhvfs_debug_fs(void)
 	for (i = 0; i < ARRAY_SIZE(entries); i++) {
 		if (!proc_create_data(entries[i].name, 0664,
 		    dir, entries[i].fops, entries[i].data))
-			tag_pr_notice("%s(), create /proc/cpuhvfs/%s failed\n",
+			tag_pr_debug("%s(), create /proc/cpuhvfs/%s failed\n",
 						__func__, entries[i].name);
 	}
 
@@ -1753,13 +1753,13 @@ int cpuhvfs_module_init(void)
 	int r;
 
 	if (!log_repo) {
-		tag_pr_notice("FAILED TO PRE-INIT CPUHVFS\n");
+		tag_pr_debug("FAILED TO PRE-INIT CPUHVFS\n");
 		return -ENODEV;
 	}
 
 	r = create_cpuhvfs_debug_fs();
 	if (r) {
-		tag_pr_notice("FAILED TO CREATE DEBUG FILESYSTEM (%d)\n", r);
+		tag_pr_debug("FAILED TO CREATE DEBUG FILESYSTEM (%d)\n", r);
 		return r;
 	}
 
@@ -1775,19 +1775,19 @@ static int dvfsp_module_init(void)
 {
 	int r;
 
-	tag_pr_notice("@@!start %s\n", __func__);
+	tag_pr_debug("@@!start %s\n", __func__);
 	r = platform_driver_register(&_mt_dvfsp_pdrv);
 	if (r)
-		tag_pr_notice("fail to register dvfs driver @ %s()\n",
+		tag_pr_debug("fail to register dvfs driver @ %s()\n",
 								__func__);
 
 	if (!dvfsp_probe_done) {
-		tag_pr_notice("fail to probe dvfs\n");
+		tag_pr_debug("fail to probe dvfs\n");
 		return -ENODEV;
 	}
 
 	log_repo = csram_base;
-	tag_pr_notice("@@!end %s\n", __func__);
+	tag_pr_debug("@@!end %s\n", __func__);
 	return 0;
 }
 
@@ -1841,16 +1841,16 @@ static int cpuhvfs_pre_module_init(void)
 	node = of_find_compatible_node(NULL, NULL, DVFSP_DT_NODE);
 	ret = of_property_read_u32(node, "state", &d->state);
 	if (ret)
-		tag_pr_info(" %s Cant find state node\n", __func__);
+		tag_pr_debug(" %s Cant find state node\n", __func__);
 
-	tag_pr_notice("@@~%s DVFS state = %d\n", __func__, d->state);
+	tag_pr_debug("@@~%s DVFS state = %d\n", __func__, d->state);
 	if (!d->state)
 		return 0;
 #endif
 
 	r = dvfsp_module_init();
 	if (r) {
-		tag_pr_notice("FAILED TO INIT DVFS MODULE(%d)\n", r);
+		tag_pr_debug("FAILED TO INIT DVFS MODULE(%d)\n", r);
 		return r;
 	}
 #ifdef CONFIG_MTK_TINYSYS_MCUPM_SUPPORT
diff --git a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_interface.c b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_interface.c
index 7df6fd108..b44197275 100644
--- a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_interface.c
+++ b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_interface.c
@@ -91,7 +91,7 @@ static ssize_t cpufreq_debug_proc_write(struct file *file,
 
 	rc = kstrtoint(buf, 10, &dbg_lv);
 	if (rc < 0)
-		tag_pr_info
+		tag_pr_debug
 		("echo dbg_lv (dec) > /proc/cpufreq/cpufreq_debug\n");
 	else
 		func_lv_mask = dbg_lv;
@@ -124,7 +124,7 @@ static ssize_t cpufreq_power_mode_proc_write(struct file *file,
 		dvfs_power_mode = mode;
 		tag_pr_debug("%s start\n", power_mode_str[mode]);
 	} else {
-		tag_pr_info
+		tag_pr_debug
 		("echo 0/1/2/3 > /proc/cpufreq/cpufreq_power_mode\n");
 	}
 
@@ -150,7 +150,7 @@ static ssize_t cpufreq_stress_test_proc_write(struct file *file,
 		return -EINVAL;
 	rc = kstrtoint(buf, 10, &do_stress);
 	if (rc < 0)
-		tag_pr_info("echo 0/1 > /proc/cpufreq/cpufreq_stress_test\n");
+		tag_pr_debug("echo 0/1 > /proc/cpufreq/cpufreq_stress_test\n");
 	else {
 		do_dvfs_stress_test = do_stress;
 #ifdef CONFIG_HYBRID_CPU_DVFS
@@ -199,7 +199,7 @@ static ssize_t cpufreq_oppidx_proc_write(struct file *file,
 	rc = kstrtoint(buf, 10, &oppidx);
 	if (rc < 0) {
 		p->dvfs_disable_by_procfs = false;
-		tag_pr_info("echo oppidx > /proc/cpufreq/%s/cpufreq_oppidx\n",
+		tag_pr_debug("echo oppidx > /proc/cpufreq/%s/cpufreq_oppidx\n",
 		p->name);
 	} else {
 		if (oppidx >= 0 && oppidx < p->nr_opp_tbl) {
@@ -215,7 +215,7 @@ static ssize_t cpufreq_oppidx_proc_write(struct file *file,
 #endif
 		} else {
 			p->dvfs_disable_by_procfs = false;
-			tag_pr_info
+			tag_pr_debug
 			("echo oppidx > /proc/cpufreq/%s/cpufreq_oppidx\n",
 			p->name);
 		}
@@ -255,7 +255,7 @@ static ssize_t cpufreq_freq_proc_write(struct file *file,
 	rc = kstrtoint(buf, 10, &freq);
 	if (rc < 0) {
 		p->dvfs_disable_by_procfs = false;
-		tag_pr_info
+		tag_pr_debug
 		("echo khz > /proc/cpufreq/%s/cpufreq_freq\n", p->name);
 	} else {
 #ifdef CONFIG_MTK_CPU_MSSV
@@ -294,7 +294,7 @@ static ssize_t cpufreq_freq_proc_write(struct file *file,
 #else
 		if (freq < p->opp_tbl[p->nr_opp_tbl - 1].cpufreq_khz) {
 			if (freq != 0)
-				tag_pr_info
+				tag_pr_debug
 				("frequency should higher than %dKHz!\n",
 				p->opp_tbl[p->nr_opp_tbl - 1].cpufreq_khz);
 
@@ -320,7 +320,7 @@ static ssize_t cpufreq_freq_proc_write(struct file *file,
 #endif
 			} else {
 				p->dvfs_disable_by_procfs = false;
-				tag_pr_info
+				tag_pr_debug
 			("frequency %dKHz! is not found in CPU opp table\n",
 					    freq);
 			}
@@ -372,7 +372,7 @@ static ssize_t cpufreq_volt_proc_write(struct file *file,
 	rc = kstrtoint(buf, 10, &uv);
 	if (rc < 0) {
 		p->dvfs_disable_by_procfs = false;
-		tag_pr_info
+		tag_pr_debug
 		("echo uv > /proc/cpufreq/%s/cpufreq_volt\n", p->name);
 	} else {
 		p->dvfs_disable_by_procfs = true;
@@ -392,7 +392,7 @@ static ssize_t cpufreq_volt_proc_write(struct file *file,
 		vproc_p->fix_volt = uv / 10;
 		ret = set_cur_volt_wrapper(p, vproc_p->fix_volt);
 		if (ret)
-			tag_pr_info("%s err to set_cur_volt_wrapper ret = %d\n",
+			tag_pr_debug("%s err to set_cur_volt_wrapper ret = %d\n",
 					__func__, ret);
 #endif
 		cpufreq_unlock(flags);
@@ -428,7 +428,7 @@ static ssize_t cpufreq_turbo_mode_proc_write(struct file *file,
 		return -EINVAL;
 	rc = kstrtoint(buf, 10, &turbo_mode);
 	if (rc < 0)
-		tag_pr_info
+		tag_pr_debug
 		("echo 0/1 > /proc/cpufreq/%s/cpufreq_turbo_mode\n", p->name);
 	else {
 		p->turbo_mode = turbo_mode;
@@ -471,7 +471,7 @@ static ssize_t cpufreq_sched_disable_proc_write(struct file *file,
 		return -EINVAL;
 	rc = kstrtoint(buf, 10, &sched_disable);
 	if (rc < 0)
-		tag_pr_info
+		tag_pr_debug
 		("echo 0/1 > /proc/cpufreq/cpufreq_sched_disable\n");
 	else {
 #ifdef CONFIG_HYBRID_CPU_DVFS
@@ -517,7 +517,7 @@ static ssize_t cpufreq_dvfs_time_profile_proc_write(struct file *file,
 
 	rc = kstrtoint(buf, 10, &temp);
 	if (rc < 0)
-		tag_pr_info
+		tag_pr_debug
 		("echo 1 > /proc/cpufreq/cpufreq_dvfs_time_profile\n");
 	else {
 		if (temp == 1) {
@@ -583,7 +583,7 @@ static ssize_t cpufreq_cci_map_table_proc_write(struct file *file,
 			idx_2, result, mode, 0);
 #endif
 	} else
-		tag_pr_info(
+		tag_pr_debug(
 		"Usage: echo <L_idx> <B_idx> <result> <mode>\n");
 
 	return count;
@@ -618,7 +618,7 @@ static ssize_t cpufreq_cci_mode_proc_write(struct file *file,
 	rc = kstrtoint(buf, 10, &mode);
 
 	if (rc < 0)
-		tag_pr_info(
+		tag_pr_debug(
 		"Usage: echo <mode>(0:Nom 1:Perf)\n");
 	else {
 #ifdef CONFIG_HYBRID_CPU_DVFS
@@ -659,7 +659,7 @@ static ssize_t cpufreq_imax_enable_proc_write(struct file *file,
 	rc = kstrtoint(buf, 10, &state);
 
 	if (rc < 0)
-		tag_pr_info(
+		tag_pr_debug(
 		"Usage: echo ON/OFF(0:Disable 1:Enable 2:Enable MPMM)\n");
 	else {
 #ifdef CONFIG_HYBRID_CPU_DVFS
@@ -711,7 +711,7 @@ static ssize_t cpufreq_imax_thermal_protect_proc_write(struct file *file,
 	rc = kstrtoint(buf, 10, &state);
 
 	if (rc < 0)
-		tag_pr_info(
+		tag_pr_debug(
 		"Usage: echo ON/OFF(0:Disable 1:Enable)\n");
 	else {
 #ifdef CONFIG_HYBRID_CPU_DVFS
@@ -785,7 +785,7 @@ int cpufreq_procfs_init(void)
 	dir = proc_mkdir("cpufreq", NULL);
 
 	if (!dir) {
-		tag_pr_notice("fail to create /proc/cpufreq @ %s()\n",
+		tag_pr_debug("fail to create /proc/cpufreq @ %s()\n",
 								__func__);
 		return -ENOMEM;
 	}
@@ -793,7 +793,7 @@ int cpufreq_procfs_init(void)
 	for (i = 0; i < ARRAY_SIZE(entries); i++) {
 		if (!proc_create
 		    (entries[i].name, 0664, dir, entries[i].fops))
-			tag_pr_notice("%s(), create /proc/cpufreq/%s failed\n",
+			tag_pr_debug("%s(), create /proc/cpufreq/%s failed\n",
 				__func__, entries[i].name);
 	}
 
@@ -801,7 +801,7 @@ int cpufreq_procfs_init(void)
 		cpu_dir = proc_mkdir(p->name, dir);
 
 		if (!cpu_dir) {
-			tag_pr_notice
+			tag_pr_debug
 				("fail to create /proc/cpufreq/%s @ %s()\n",
 				p->name, __func__);
 			return -ENOMEM;
@@ -811,7 +811,7 @@ int cpufreq_procfs_init(void)
 			if (!proc_create_data
 			    (cpu_entries[i].name, 0664,
 			    cpu_dir, cpu_entries[i].fops, p))
-				tag_pr_notice
+				tag_pr_debug
 				("%s(), create /proc/cpufreq/%s/%s failed\n",
 				__func__, p->name, entries[i].name);
 		}
diff --git a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_main.c b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_main.c
index 3e9e86cc5..f040b2aaf 100644
--- a/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_main.c
+++ b/drivers/misc/mediatek/base/power/cpufreq_v1/src/mtk_cpufreq_main.c
@@ -51,7 +51,7 @@ static void modify_kernel_opp_table_by_doe
 			vproc_p->buck_ops->transfer2volt
 			(d->dts_opp_tbl[j][i * ARRAY_COL_SIZE + 1]);
 #if 0
-			tag_pr_notice("@@%s cluster = %d flag = %d opp[%d] = %d\n",
+			tag_pr_debug("@@%s cluster = %d flag = %d opp[%d] = %d\n",
 			__func__, j, d->doe_flag, i, opp[i].cpufreq_khz);
 #endif
 
@@ -72,7 +72,7 @@ static void modify_kernel_opp_div_by_doe
 			opp_tbl_m[i].pos_div =
 			d->dts_opp_tbl[j][i * ARRAY_COL_SIZE + 2];
 #if 0
-			tag_pr_info("@@%s cls = %d posdiv = %d clk_div = %d\n",
+			tag_pr_debug("@@%s cls = %d posdiv = %d clk_div = %d\n",
 					__func__, j, opp_tbl_m[i].pos_div,
 					opp_tbl_m[i].clk_div);
 #endif
@@ -175,7 +175,7 @@ static int _cpufreq_set_locked_secure(struct cpufreq_policy *policy,
 	aee_record_cpu_dvfs_step(1);
 
 	if (!policy) {
-		tag_pr_notice("Can't get policy of %s\n",
+		tag_pr_debug("Can't get policy of %s\n",
 		cpu_dvfs_get_name(p));
 		goto out;
 	}
@@ -290,7 +290,7 @@ void set_cur_freq_wrapper(struct mt_cpu_dvfs *p, unsigned int cur_khz,
 		cpu_dvfs_get_name(p), idx, cpu_dvfs_get_freq_by_idx(p, idx));
 
 	if (!p->armpll_is_available) {
-		tag_pr_notice
+		tag_pr_debug
 		("%s: armpll not available, cur_khz = %d, target_khz = %d\n",
 			cpu_dvfs_get_name(p), cur_khz, target_khz);
 	}
@@ -396,7 +396,7 @@ static inline void assert_volt_valid(int line, unsigned int volt,
 {
 	if (unlikely(cur_vsram < cur_vproc ||
 		     cur_vsram - cur_vproc > MAX_DIFF_VSRAM_VPROC)) {
-		tag_pr_notice
+		tag_pr_debug
 		("@%d, volt = %u, cur_vsram = %u (%u), cur_vproc = %u (%u)\n",
 		   line, volt, cur_vsram, old_vsram, cur_vproc, old_vproc);
 		WARN_ON(1);
@@ -426,7 +426,7 @@ int set_cur_volt_wrapper(struct mt_cpu_dvfs *p, unsigned int volt)
 		cpu_dvfs_get_name(vsram_p), cur_vsram);
 
 	if (cur_vproc == 0) {
-		tag_pr_notice("@%s():%d, can not use ext buck!\n",
+		tag_pr_debug("@%s():%d, can not use ext buck!\n",
 		__func__, __LINE__);
 		return -1;
 	}
@@ -575,10 +575,10 @@ __func__, old_vsram, cur_vsram, old_vproc, cur_vproc, delay_us);
 
 	aee_record_cpu_volt(p, volt);
 #if 0
-	tag_pr_info("DVFS: End @%s(): %s, cur_vsram = %d, cur_vproc = %d\n",
+	tag_pr_debug("DVFS: End @%s(): %s, cur_vsram = %d, cur_vproc = %d\n",
 		__func__, cpu_dvfs_get_name(p), cur_vsram, cur_vproc);
 
-	tag_pr_info("DVS: End @%s(): %s, vsram(%s) = %d, cur_vproc(%s) = %d\n",
+	tag_pr_debug("DVS: End @%s(): %s, vsram(%s) = %d, cur_vproc(%s) = %d\n",
 		__func__, cpu_dvfs_get_name(p),
 		cpu_dvfs_get_name(vsram_p), get_cur_volt_wrapper(p, vsram_p),
 		cpu_dvfs_get_name(vproc_p), get_cur_volt_wrapper(p, vproc_p));
@@ -664,7 +664,7 @@ static void dump_all_opp_table(void)
 	struct mt_cpu_dvfs *p;
 
 	for_each_cpu_dvfs(i, p) {
-		tag_pr_notice("[%s/%d] available = %d, oppidx = %d (%u, %u)\n",
+		tag_pr_debug("[%s/%d] available = %d, oppidx = %d (%u, %u)\n",
 			      p->name, p->cpu_id,
 			      p->armpll_is_available, p->idx_opp_tbl,
 			      cpu_dvfs_get_freq_by_idx(p, p->idx_opp_tbl),
@@ -673,7 +673,7 @@ static void dump_all_opp_table(void)
 #ifndef ONE_CLUSTER
 		if (i == MT_CPU_DVFS_CCI) {
 			for (i = 0; i < p->nr_opp_tbl; i++) {
-				tag_pr_notice("%-2d (%u, %u)\n",
+				tag_pr_debug("%-2d (%u, %u)\n",
 					i, cpu_dvfs_get_freq_by_idx(p, i),
 					cpu_dvfs_get_volt_by_idx(p, i));
 			}
@@ -715,12 +715,12 @@ static int _cpufreq_set_locked(struct cpufreq_policy *policy,
 
 	dvfs_disable_flag = 1;
 	if (dvfs_disable_flag == 1) {
-		tag_pr_info("DVFS_DISABLE");
+		tag_pr_debug("DVFS_DISABLE");
 		return 0;
 	}
 
 	if (!policy) {
-		tag_pr_notice("Can't get policy of %s\n",
+		tag_pr_debug("Can't get policy of %s\n",
 				cpu_dvfs_get_name(p));
 		goto out;
 	}
@@ -735,7 +735,7 @@ static int _cpufreq_set_locked(struct cpufreq_policy *policy,
 	new_opp_idx =
 	_search_available_freq_idx(p, target_khz, CPUFREQ_RELATION_L);
 	if (new_opp_idx == -1) {
-		tag_pr_info("%s cant find freq idx new_opp_idx = %d\n",
+		tag_pr_debug("%s cant find freq idx new_opp_idx = %d\n",
 				__func__, new_opp_idx);
 		goto out;
 	}
@@ -848,7 +848,7 @@ target_khz, target_volt, num_online_cpus(), cur_khz);
 		unsigned int freq = pll_p->pll_ops->get_cur_freq(pll_p);
 
 		if (volt < target_volt || freq != target_khz) {
-			tag_pr_notice
+			tag_pr_debug
 		("volt = %u, target_volt = %u, freq = %u, target_khz = %u\n",
 				volt, target_volt, freq, target_khz);
 			dump_all_opp_table();
@@ -1352,7 +1352,7 @@ static int _mt_cpufreq_init(struct cpufreq_policy *policy)
 	srate_doe();
 #endif
 	if (ret)
-		tag_pr_notice("failed to setup frequency table\n");
+		tag_pr_debug("failed to setup frequency table\n");
 
 	dvfs_init_flag = 1;
 	FUNC_EXIT(FUNC_LV_MODULE);
@@ -1668,7 +1668,7 @@ static int _mt_cpufreq_pdrv_probe(struct platform_device *pdev)
 
 	ret = mt_cpufreq_regulator_map(pdev);
 	if (ret)
-		tag_pr_notice("%s regulator map fail\n", __func__);
+		tag_pr_debug("%s regulator map fail\n", __func__);
 
 #ifdef CONFIG_HYBRID_CPU_DVFS
 #ifdef INIT_MCUPM_VOLTAGE_SETTING
@@ -1790,7 +1790,7 @@ static int __init _mt_cpufreq_tbl_init(void)
 #ifdef ENABLE_DOE
 	struct cpudvfs_doe *d = &dvfs_doe;
 
-	tag_pr_notice("@@~%s DVFS state = %d\n", __func__, dvfs_doe.state);
+	tag_pr_debug("@@~%s DVFS state = %d\n", __func__, dvfs_doe.state);
 	if (!d->state)
 		return 0;
 #endif
@@ -1838,7 +1838,7 @@ static int __init _mt_cpufreq_pdrv_init(void)
 	int i;
 
 #ifdef ENABLE_DOE
-	tag_pr_notice("@@~ %s DVFS state = %d\n", __func__, dvfs_doe.state);
+	tag_pr_debug("@@~ %s DVFS state = %d\n", __func__, dvfs_doe.state);
 	if (!dvfs_doe.state)
 		return 0;
 #endif
@@ -1863,7 +1863,7 @@ static int __init _mt_cpufreq_pdrv_init(void)
 		arch_get_cluster_cpus(&cpu_mask, i);
 #endif
 		cpu_dvfs[i].cpu_id = cpumask_first(&cpu_mask);
-		tag_pr_info("cluster_id = %d, cluster_cpuid = %d\n",
+		tag_pr_debug("cluster_id = %d, cluster_cpuid = %d\n",
 		i, cpu_dvfs[i].cpu_id);
 	}
 
@@ -1876,7 +1876,7 @@ static int __init _mt_cpufreq_pdrv_init(void)
 	ret = platform_device_register(&_mt_cpufreq_pdev);
 
 	if (ret) {
-		tag_pr_notice("fail to register cpufreq device @ %s()\n",
+		tag_pr_debug("fail to register cpufreq device @ %s()\n",
 		__func__);
 	}
 #endif
@@ -1884,7 +1884,7 @@ static int __init _mt_cpufreq_pdrv_init(void)
 	ret = platform_driver_register(&_mt_cpufreq_pdrv);
 
 	if (ret) {
-		tag_pr_notice("fail to register cpufreq driver @ %s()\n",
+		tag_pr_debug("fail to register cpufreq driver @ %s()\n",
 		__func__);
 #ifndef CPU_DVFS_DT_REG
 		platform_device_unregister(&_mt_cpufreq_pdev);
diff --git a/drivers/misc/mediatek/base/power/cpuhotplug/mtk_cpuhp_ppm.c b/drivers/misc/mediatek/base/power/cpuhotplug/mtk_cpuhp_ppm.c
index 7eb9ba616..1f1247ac5 100644
--- a/drivers/misc/mediatek/base/power/cpuhotplug/mtk_cpuhp_ppm.c
+++ b/drivers/misc/mediatek/base/power/cpuhotplug/mtk_cpuhp_ppm.c
@@ -172,7 +172,7 @@ void ppm_notifier(void)
 	/* create a kthread to serve the requests from PPM */
 	ppm_kthread = kthread_create(ppm_thread_fn, NULL, "cpuhp-ppm");
 	if (IS_ERR(ppm_kthread)) {
-		pr_notice("error creating ppm kthread (%ld)\n",
+		pr_debug("error creating ppm kthread (%ld)\n",
 		       PTR_ERR(ppm_kthread));
 		return;
 	}
diff --git a/drivers/misc/mediatek/base/power/cpuidle_v3/mtk_cpuidle.c b/drivers/misc/mediatek/base/power/cpuidle_v3/mtk_cpuidle.c
index c5effd267..9ca68d10e 100644
--- a/drivers/misc/mediatek/base/power/cpuidle_v3/mtk_cpuidle.c
+++ b/drivers/misc/mediatek/base/power/cpuidle_v3/mtk_cpuidle.c
@@ -286,7 +286,7 @@ static int wakeup_source_lookup(void)
 
 		irq_nr = of_irq_get(of_args.np, of_args.args[0]);
 		if (irq_nr <= 0) {
-			pr_notice("cpuidle: wake up IRQ not found: %d\n",
+			pr_debug("cpuidle: wake up IRQ not found: %d\n",
 				irq_nr);
 			goto fail;
 		}
diff --git a/drivers/misc/mediatek/base/power/dcm_v1/mtk_dcm.c b/drivers/misc/mediatek/base/power/dcm_v1/mtk_dcm.c
index 65f28b2d1..4c4e2776e 100644
--- a/drivers/misc/mediatek/base/power/dcm_v1/mtk_dcm.c
+++ b/drivers/misc/mediatek/base/power/dcm_v1/mtk_dcm.c
@@ -436,7 +436,7 @@ static ssize_t dcm_state_store(struct kobject *kobj,
 				 */
 				if (mask & STALL_DCM_TYPE) {
 					if (mode)
-						dcm_pr_info("stall dcm is enabled forDefault(Normal) mode started\n");
+						dcm_pr_info("stall dcm is enabled for Default(Normal) mode started\n");
 					else
 						dcm_pr_info("stall dcm is disabled for Performance(Sports) mode started\n");
 				}
diff --git a/drivers/misc/mediatek/base/power/eem_v2/mt6785/inc/mtk_eem_internal.h b/drivers/misc/mediatek/base/power/eem_v2/mt6785/inc/mtk_eem_internal.h
index 3ce4d2aee..67b61ec7c 100644
--- a/drivers/misc/mediatek/base/power/eem_v2/mt6785/inc/mtk_eem_internal.h
+++ b/drivers/misc/mediatek/base/power/eem_v2/mt6785/inc/mtk_eem_internal.h
@@ -46,7 +46,7 @@
  */
 #define EEM_TAG	 "[xxxxEEM] "
 #if 1
-	#define eem_error(fmt, args...)		pr_notice(EEM_TAG fmt, ##args)
+	#define eem_error(fmt, args...)		pr_err(EEM_TAG fmt, ##args)
 	#define eem_warning(fmt, args...)
 	#define eem_notice(fmt, args...)
 	#define eem_info(fmt, args...)
diff --git a/drivers/misc/mediatek/base/power/eem_v2/mt6785/mtk_eem.c b/drivers/misc/mediatek/base/power/eem_v2/mt6785/mtk_eem.c
index f06567dd4..bdc4e0d4f 100644
--- a/drivers/misc/mediatek/base/power/eem_v2/mt6785/mtk_eem.c
+++ b/drivers/misc/mediatek/base/power/eem_v2/mt6785/mtk_eem.c
@@ -266,9 +266,9 @@ static int get_devinfo(void)
 	if (rtc_dev) {
 		err = rtc_read_time(rtc_dev, &tm);
 		if (err < 0)
-			pr_info("fail to read time\n");
+			pr_debug("fail to read time\n");
 	} else
-		pr_info("[systimer] rtc_class_open rtc_dev fail\n");
+		pr_debug("[systimer] rtc_class_open rtc_dev fail\n");
 
 	val = (int *)&eem_devinfo;
 
diff --git a/drivers/misc/mediatek/base/power/include/ppm_v3/mtk_ppm_api.h b/drivers/misc/mediatek/base/power/include/ppm_v3/mtk_ppm_api.h
index c63918a74..1d08c9789 100644
--- a/drivers/misc/mediatek/base/power/include/ppm_v3/mtk_ppm_api.h
+++ b/drivers/misc/mediatek/base/power/include/ppm_v3/mtk_ppm_api.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2015 MediaTek Inc.
+ * Copyright (C) 2021 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -50,6 +51,7 @@ enum ppm_sysboost_user {
 	BOOST_BY_DEBUGD = 5,
 	BOOST_BY_DEBUGD_64,
 	BOOST_BY_BOOT_TIME_OPT,
+	BOOST_BY_XM_THERMAL,
 
 	NR_PPM_SYSBOOST_USER,
 };
diff --git a/drivers/misc/mediatek/base/power/leakage_table_v2/mtk_static_power.c b/drivers/misc/mediatek/base/power/leakage_table_v2/mtk_static_power.c
index 43daaa84d..bd3ae7fb4 100644
--- a/drivers/misc/mediatek/base/power/leakage_table_v2/mtk_static_power.c
+++ b/drivers/misc/mediatek/base/power/leakage_table_v2/mtk_static_power.c
@@ -178,7 +178,7 @@ int mtk_spower_make_table(struct sptab_s *spt, int voltage, int degree,
 			  unsigned int id, struct sptab_list *all_tab[])
 {
 	int i, j;
-	struct sptab_s *tab[MAX_TABLE_SIZE], *tab1, *tab2, *tspt;
+	struct sptab_s *tab[MAX_TABLE_SIZE] = { NULL }, *tab1, *tab2, *tspt;
 	int wat; /* leakage that reads from efuse */
 	int devinfo_domain;
 	int c[MAX_TABLE_SIZE] = {0};
diff --git a/drivers/misc/mediatek/base/power/mcdi/include/mcdi_v1/mtk_mcdi_util.h b/drivers/misc/mediatek/base/power/mcdi/include/mcdi_v1/mtk_mcdi_util.h
index 216785c24..ad4a60281 100644
--- a/drivers/misc/mediatek/base/power/mcdi/include/mcdi_v1/mtk_mcdi_util.h
+++ b/drivers/misc/mediatek/base/power/mcdi/include/mcdi_v1/mtk_mcdi_util.h
@@ -59,7 +59,7 @@ static const struct file_operations mcdi_ ## name ## _fops = {		\
 #define PROC_CREATE_MCDI(parent, name)					\
 do {									\
 	if (!proc_create(#name, 0644, parent, &mcdi_ ## name ## _fops))	\
-		pr_notice("%s(), create /proc/mcdi/%s failed\n",	\
+		pr_debug("%s(), create /proc/mcdi/%s failed\n",	\
 			__func__, #name);				\
 } while (0)
 
diff --git a/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_main.c b/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_main.c
index b466327e6..e705d6847 100644
--- a/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_main.c
+++ b/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_main.c
@@ -182,7 +182,7 @@ static void mcdi_stress_start(void)
 	for (i = 0; i < NF_CPU; i++) {
 		ret = scnprintf(name, sizeof(name), "mcdi_stress_task%d", i);
 		if (ret == 0)
-			pr_info("[mcdi]%s task naming fail\n", __func__);
+			pr_debug("[mcdi]%s task naming fail\n", __func__);
 
 		mcdi_stress_tsk[i] =
 			kthread_create(mcdi_stress_task, NULL, name);
@@ -537,7 +537,7 @@ static int mcdi_procfs_init(void)
 	mcdi_dir = proc_mkdir(mcdi_procfs_dir_name, NULL);
 
 	if (!mcdi_dir) {
-		pr_notice("fail to create /proc/mcdi @ %s()\n", __func__);
+		pr_debug("fail to create /proc/mcdi @ %s()\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -882,7 +882,7 @@ subsys_initcall(mcdi_sysram_init);
 static int __init mcdi_init(void)
 {
 	/* Activate MCDI after SMP */
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	/* Register CPU up/down callbacks */
 	mcdi_hotplug_cb_init();
diff --git a/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_mcupm.c b/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_mcupm.c
index d85113bd6..9fea68c92 100644
--- a/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_mcupm.c
+++ b/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_mcupm.c
@@ -87,7 +87,7 @@ static void mcdi_enable_mcupm_cluster_counter(void)
 		thre = s->target_residency;
 		mcdi_write((mcdi_mcupm_base + MCUPM_CFGREG_MP_SLEEP_TH[idx]),
 			(thre | (CLUSTER_COUNTER_ENABLE << 31)));
-		pr_info("[mcdi] [%s] cls_thre(%d)=0x%08x\n", __func__, idx,
+		pr_debug("[mcdi] [%s] cls_thre(%d)=0x%08x\n", __func__, idx,
 			mcdi_read(mcdi_mcupm_base +
 				  MCUPM_CFGREG_MP_SLEEP_TH[idx]));
 	}
diff --git a/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_profile.c b/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_profile.c
index c5288b925..69eb77815 100644
--- a/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_profile.c
+++ b/drivers/misc/mediatek/base/power/mcdi/mcdi_v1/mtk_mcdi_profile.c
@@ -596,7 +596,7 @@ static ssize_t mcdi_profile_write(struct file *filp,
 		if (param >= MCDI_SYSRAM_SIZE || (param % 4) != 0)
 			return -EINVAL;
 
-		pr_info("mcdi_reg: 0x%lx=0x%x(%d)\n",
+		pr_debug("mcdi_reg: 0x%lx=0x%x(%d)\n",
 			param, mcdi_read(mcdi_sysram_base + param),
 			mcdi_read(mcdi_sysram_base + param));
 	} else if (!strncmp(cmd_str, "enable", sizeof("enable"))) {
diff --git a/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_plat.c b/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_plat.c
index 696be49f7..e97898f4f 100644
--- a/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_plat.c
+++ b/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_plat.c
@@ -109,7 +109,7 @@ void mcdi_of_init(void **base)
 	node = of_find_compatible_node(NULL, NULL, mcdi_node_name);
 
 	if (!node) {
-		pr_info("node '%s' not found!\n", mcdi_node_name);
+		pr_debug("node '%s' not found!\n", mcdi_node_name);
 		cpc_base = NULL;
 		goto fail;
 	}
@@ -117,14 +117,14 @@ void mcdi_of_init(void **base)
 	*base = of_iomap(node, 0);
 
 	if (!*base)
-		pr_info("node '%s' can not iomap!\n", mcdi_node_name);
+		pr_debug("node '%s' can not iomap!\n", mcdi_node_name);
 
 	cpc_base = of_iomap(node, 1);
 
 	if (!cpc_base)
-		pr_info("node cpc_base can not iomap!\n");
+		pr_debug("node cpc_base can not iomap!\n");
 
-	pr_info("mcdi_sysram_base = %p, cpc_base = %p\n",
+	pr_debug("mcdi_sysram_base = %p, cpc_base = %p\n",
 			*base,
 			cpc_base);
 
diff --git a/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_state.c b/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_state.c
index 48308fe01..e5ddd4b80 100644
--- a/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_state.c
+++ b/drivers/misc/mediatek/base/power/mcdi/mt6785/mtk_mcdi_state.c
@@ -278,13 +278,13 @@ int mtk_cpuidle_register_driver(void)
 
 	ret = cpuidle_register_driver(&mtk_cpuidle_driver_set_0);
 	if (ret) {
-		pr_info("Failed to register cpuidle driver 0\n");
+		pr_debug("Failed to register cpuidle driver 0\n");
 		return ret;
 	}
 
 	ret = cpuidle_register_driver(&mtk_cpuidle_driver_set_1);
 	if (ret) {
-		pr_info("Failed to register cpuidle driver 1\n");
+		pr_debug("Failed to register cpuidle driver 1\n");
 		return ret;
 	}
 
diff --git a/drivers/misc/mediatek/base/power/mcdi/mtk_mcdi_governor.c b/drivers/misc/mediatek/base/power/mcdi/mtk_mcdi_governor.c
index b51727251..ab252b39c 100644
--- a/drivers/misc/mediatek/base/power/mcdi/mtk_mcdi_governor.c
+++ b/drivers/misc/mediatek/base/power/mcdi/mtk_mcdi_governor.c
@@ -836,7 +836,7 @@ void set_mcdi_s_state(int state)
 		return;
 	}
 
-	pr_info("%s:  %d\n", __func__, state);
+	pr_debug("%s:  %d\n", __func__, state);
 
 	spin_lock_irqsave(&mcdi_feature_stat_spin_lock, flags);
 
diff --git a/drivers/misc/mediatek/base/power/mdpm_v2/mt6785/mtk_mdpm_platform.c b/drivers/misc/mediatek/base/power/mdpm_v2/mt6785/mtk_mdpm_platform.c
index 6b7c1485c..0a8e9ba54 100644
--- a/drivers/misc/mediatek/base/power/mdpm_v2/mt6785/mtk_mdpm_platform.c
+++ b/drivers/misc/mediatek/base/power/mdpm_v2/mt6785/mtk_mdpm_platform.c
@@ -330,7 +330,7 @@ static int get_md1_scenario_internal(u32 share_reg)
 	}
 
 	if  (hit == -1)
-		pr_notice("[%s] ERROR, unknown scenario [%d]\n",
+		pr_debug("[%s] ERROR, unknown scenario [%d]\n",
 			__func__, share_reg);
 #endif
 
@@ -345,7 +345,7 @@ static int get_shm_idx(enum tx_power_table tx_dbm, int sec_shift, bool get_dbm)
 
 	if (idx >= DBM_TABLE_SIZE || idx < 0 || tx_dbm >= TX_DBM_NUM
 		|| tx_dbm < 0) {
-		pr_notice("[%s] ERROR, exceed index %d %d %d\n",
+		pr_debug("[%s] ERROR, exceed index %d %d %d\n",
 			__func__, idx, sec_shift, tx_dbm);
 			WARN_ON_ONCE(1);
 		return mem_idx;
@@ -356,7 +356,7 @@ static int get_shm_idx(enum tx_power_table tx_dbm, int sec_shift, bool get_dbm)
 		mem_idx = mdpm_tx_pwr[tx_dbm].shm_dbm_idx[idx];
 		if (mem_idx > DBM_TABLE_END
 			|| mem_idx < DBM_TABLE_START) {
-			pr_notice("[%s] ERROR, not in dbm table %d %d %d\n",
+			pr_debug("[%s] ERROR, not in dbm table %d %d %d\n",
 				__func__, idx, tx_dbm, mem_idx);
 				WARN_ON_ONCE(1);
 		}
@@ -365,7 +365,7 @@ static int get_shm_idx(enum tx_power_table tx_dbm, int sec_shift, bool get_dbm)
 		mem_idx = mdpm_tx_pwr[tx_dbm].shm_sec_idx[idx];
 		if (mem_idx > SECTION_LEVEL_END
 			|| mem_idx < SECTION_LEVEL_START) {
-			pr_notice("[%s] ERROR, not in section level %d %d %d\n",
+			pr_debug("[%s] ERROR, not in section level %d %d %d\n",
 				__func__, idx, tx_dbm, mem_idx);
 				WARN_ON_ONCE(1);
 		}
@@ -410,11 +410,11 @@ static u32 check_shm_version(u32 *share_mem)
 	switch (mdpm_version_check) {
 	case VERSION_INIT:
 		if (mt_mdpm_debug)
-			pr_info_ratelimited("mdpm share memory: MD not init\n");
+			pr_debug_ratelimited("mdpm share memory: MD not init\n");
 
 		break;
 	case VERSION_INVALID:
-		pr_info("dpm share memory: MD check version ERROR\n");
+		pr_debug("dpm share memory: MD check version ERROR\n");
 		WARN_ON_ONCE(1);
 		break;
 	case VERSION_VALID:
@@ -445,7 +445,7 @@ static u32 get_rfhw(u32 *share_mem)
 			rfhw_updated = 1;
 			return rfhw_version;
 		} else if (1)
-			pr_notice("wrong rfhw_version %d\n", rfhw_version);
+			pr_debug("wrong rfhw_version %d\n", rfhw_version);
 	}
 
 	return rfhw_sel;
@@ -475,7 +475,7 @@ void init_md1_section_level(u32 *share_mem)
 		for (j = 0; j < TX_DBM_NUM; j++) {
 			if (mdpm_tx_pwr[j].rfhw->section[i] >
 				DBM_SECTION_MASK) {
-				pr_notice("[%s] md1_section_level too large i:%d s:%d !\n",
+				pr_debug("[%s] md1_section_level too large i:%d s:%d !\n",
 					__func__, j, i);
 				WARN_ON_ONCE(1);
 			}
@@ -492,23 +492,23 @@ void init_md1_section_level(u32 *share_mem)
 	memcpy(&share_mem[SECTION_LEVEL_START], &mem[SECTION_LEVEL_START],
 		sizeof(u32) * (SECTION_LEVEL_END - SECTION_LEVEL_START + 1));
 
-	pr_info("AP2MD1 section, 2G: 0x%08x%08x(0x%08x%08x), 3G: 0x%08x%08x(0x%08x %08x)\n",
+	pr_debug("AP2MD1 section, 2G: 0x%08x%08x(0x%08x%08x), 3G: 0x%08x%08x(0x%08x %08x)\n",
 		mem[M_2G_SECTION_LEVEL], mem[M_2G_SECTION_1_LEVEL],
 		share_mem[M_2G_SECTION_LEVEL], share_mem[M_2G_SECTION_1_LEVEL],
 		mem[M_3G_SECTION_LEVEL], mem[M_3G_SECTION_1_LEVEL],
 		share_mem[M_3G_SECTION_LEVEL],
 		share_mem[M_3G_SECTION_1_LEVEL]);
-	pr_info("4G_upL1:0x%08x%08x(0x%08x%08x),4G_upL2:0x%08x%08x(0x%08x%08x)\n",
+	pr_debug("4G_upL1:0x%08x%08x(0x%08x%08x),4G_upL2:0x%08x%08x(0x%08x%08x)\n",
 		mem[M_4G_SECTION_LEVEL], mem[M_4G_SECTION_1_LEVEL],
 		share_mem[M_4G_SECTION_LEVEL], share_mem[M_4G_SECTION_1_LEVEL],
 		mem[M_4G_SECTION_LEVEL], mem[M_4G_SECTION_1_LEVEL],
 		share_mem[M_4G_SECTION_LEVEL],
 		share_mem[M_4G_SECTION_1_LEVEL]);
-	pr_info("3GTDD: 0x%08x%08x(0x%08x%08x)\n",
+	pr_debug("3GTDD: 0x%08x%08x(0x%08x%08x)\n",
 		mem[M_TDD_SECTION_LEVEL], mem[M_TDD_SECTION_1_LEVEL],
 		share_mem[M_TDD_SECTION_LEVEL],
 		share_mem[M_TDD_SECTION_1_LEVEL]);
-	pr_info("C2K: 0x%08x%08x(0x%08x%08x), addr: 0x%p\n",
+	pr_debug("C2K: 0x%08x%08x(0x%08x%08x), addr: 0x%p\n",
 		mem[M_C2K_SECTION_1_LEVEL], mem[M_C2K_SECTION_2_LEVEL],
 		share_mem[M_C2K_SECTION_1_LEVEL],
 		share_mem[M_C2K_SECTION_2_LEVEL], share_mem);
@@ -526,7 +526,7 @@ enum md_scenario get_md1_scenario(u32 share_reg,
 	scenario = (scenario < 0) ? S_STANDBY : scenario;
 
 	if (mt_mdpm_debug && scenario >= 0)
-		pr_info("MD1 scenario: %d(%s), reg: 0x%x\n",
+		pr_debug("MD1 scenario: %d(%s), reg: 0x%x\n",
 			scenario, mdpm_scen[scenario].scenario_name,
 			share_reg);
 
@@ -547,7 +547,7 @@ enum md_scenario get_md1_scenario_by_shm(u32 *share_mem)
 	scenario = (scenario < 0) ? S_STANDBY : scenario;
 
 	if (mt_mdpm_debug && scenario >= 0)
-		pr_info("MD1 scenario: %d(%s), scen_status: 0x%x\n",
+		pr_debug("MD1 scenario: %d(%s), scen_status: 0x%x\n",
 			scenario, mdpm_scen[scenario].scenario_name,
 			scen_status);
 
@@ -572,14 +572,14 @@ int get_md1_scenario_power(enum md_scenario scenario,
 		s_power = mdpm_scen[scenario].scenario_power->avg;
 		break;
 	default:
-		pr_notice("%s error power_type=%d\n", __func__, power_type);
+		pr_debug("%s error power_type=%d\n", __func__, power_type);
 		break;
 	}
 	mdpm_pwr_sta->scenario_id = scenario;
 	temp = snprintf(mdpm_pwr_sta->scenario_name, MAX_MDPM_NAME_LEN,
 		"%s", mdpm_scen[scenario].scenario_name);
 	if (temp < 0)
-		pr_notice("%s error scenario_name\n", __func__);
+		pr_debug("%s error scenario_name\n", __func__);
 
 	mdpm_pwr_sta->scanario_power = s_power;
 	mdpm_pwr_sta->power_type = power_type;
@@ -600,7 +600,7 @@ int get_md1_tx_power(enum md_scenario scenario, u32 *share_mem,
 #if 0
 	if (scenario == S_STANDBY) {
 		if (mt_mdpm_debug)
-			pr_info("MD1 is standby, dBm pw: 0\n");
+			pr_debug("MD1 is standby, dBm pw: 0\n");
 
 		return 0;
 	}
@@ -608,7 +608,7 @@ int get_md1_tx_power(enum md_scenario scenario, u32 *share_mem,
 
 	if (share_mem == NULL) {
 		if (mt_mdpm_debug)
-			pr_info("MD1 share_mem is NULL\n");
+			pr_debug("MD1 share_mem is NULL\n");
 
 		return 0;
 	}
@@ -638,7 +638,7 @@ int get_md1_tx_power(enum md_scenario scenario, u32 *share_mem,
 			break;
 
 		default:
-			pr_notice("wrong rf_ret %d\n", rf_ret);
+			pr_debug("wrong rf_ret %d\n", rf_ret);
 			break;
 		}
 	}
@@ -651,7 +651,7 @@ int get_md1_tx_power(enum md_scenario scenario, u32 *share_mem,
 			if ((i + 1) % 10 == 0) {
 				usedBytes = 0;
 
-			pr_info("%s\n", log_buffer);
+			pr_debug("%s\n", log_buffer);
 		}
 	}
 
@@ -695,13 +695,13 @@ static int get_md1_tx_power_by_table(u32 *dbm_mem, u32 *old_dbm_mem,
 
 	if (dbm_type >= TX_DBM_NUM || dbm_type < 0 ||
 		power_type >= POWER_TYPE_NUM || power_type < 0) {
-		pr_notice("error argument dbm_type=%d power_type=%d\n",
+		pr_debug("error argument dbm_type=%d power_type=%d\n",
 			dbm_type, power_type);
 		return 0;
 	}
 
 	if (tx_pwr == NULL) {
-		pr_notice("no data for tx_power\n");
+		pr_debug("no data for tx_power\n");
 		return 0;
 	}
 
@@ -715,7 +715,7 @@ static int get_md1_tx_power_by_table(u32 *dbm_mem, u32 *old_dbm_mem,
 
 	if (cmp) {
 		if (mt_mdpm_debug == 2)
-			pr_info("%s dBm no TX power, reg: 0x%08x%08x(0x%08x%08x) return 0\n",
+			pr_debug("%s dBm no TX power, reg: 0x%08x%08x(0x%08x%08x) return 0\n",
 			tx_pwr->dbm_name,
 			dbm_mem[tx_pwr->shm_dbm_idx[0]],
 			dbm_mem[tx_pwr->shm_dbm_idx[1]],
@@ -742,13 +742,13 @@ static int get_md1_tx_power_by_table(u32 *dbm_mem, u32 *old_dbm_mem,
 				rf_power = tx_pwr->rfhw->rf_power.avg[section];
 				break;
 			default:
-				pr_notice("%s error power_type=%d\n",
+				pr_debug("%s error power_type=%d\n",
 					__func__, power_type);
 				break;
 			}
 
 			if (mt_mdpm_debug)
-				pr_info("%s dBm: reg:0x%08x%08x(0x%08x%08x),pa:%d,rf:%d,s:%d\n",
+				pr_debug("%s dBm: reg:0x%08x%08x(0x%08x%08x),pa:%d,rf:%d,s:%d\n",
 				tx_pwr->dbm_name,
 				dbm_mem[tx_pwr->shm_dbm_idx[0]],
 				dbm_mem[tx_pwr->shm_dbm_idx[1]],
@@ -787,7 +787,7 @@ static int get_md1_tx_power_by_rat(u32 *dbm_mem, u32 *old_dbm_mem,
 
 	if (rat > RAT_NUM || rat <= 0 ||
 		power_type >= POWER_TYPE_NUM || power_type < 0) {
-		pr_notice("error argument rat_type=%d power_type=%d\n", rat,
+		pr_debug("error argument rat_type=%d power_type=%d\n", rat,
 			power_type);
 		return 0;
 	}
@@ -828,7 +828,7 @@ static int get_md1_tx_power_by_rat(u32 *dbm_mem, u32 *old_dbm_mem,
 			section_shift, md_power_s);
 		break;
 	default:
-		pr_notice("error argument rat_type=%d power_type=%d\n",
+		pr_debug("error argument rat_type=%d power_type=%d\n",
 			rat, power_type);
 		break;
 	}
@@ -849,20 +849,20 @@ void md_power_meter_ut(void)
 
 	ret = check_shm_version(fake_share_mem);
 	if (ret != VERSION_INIT) {
-		pr_info("[UT] check_shm_version error %d , should be %d\n",
+		pr_debug("[UT] check_shm_version error %d , should be %d\n",
 			ret, VERSION_INIT);
 	} else
-		pr_info("[UT] check_shm_version init OK\n");
+		pr_debug("[UT] check_shm_version init OK\n");
 
 	mdpm_shm_write(fake_share_mem, M_VERSION_CHECK, VERSION_VALID,
 		VERSION_CHECK_VALID_MASK, VERSION_CHECK_VALID_SHIFT);
 
 	ret = check_shm_version(fake_share_mem);
 	if (ret != VERSION_VALID) {
-		pr_info("[UT] check_shm_version error %d , should be %d\n",
+		pr_debug("[UT] check_shm_version error %d , should be %d\n",
 			ret, VERSION_VALID);
 	} else
-		pr_info("[UT] check_shm_version valid OK\n");
+		pr_debug("[UT] check_shm_version valid OK\n");
 
 	/* MD rfhw UT */
 	mdpm_shm_write(fake_share_mem, M_RF_HW, 1,
@@ -872,9 +872,9 @@ void md_power_meter_ut(void)
 		RF_HW_VALID_MASK, RF_HW_VALID_SHIFT);
 
 	if (get_rfhw(fake_share_mem) == 0x1)
-		pr_info("[UT] get_rfhw OK\n");
+		pr_debug("[UT] get_rfhw OK\n");
 	else
-		pr_info("[UT] get_rfhw ERROR\n");
+		pr_debug("[UT] get_rfhw ERROR\n");
 
 #ifdef GET_MD_SCEANRIO_BY_SHARE_MEMORY
 	/* check getting MD scenario with priority */
@@ -885,10 +885,10 @@ void md_power_meter_ut(void)
 				mdpm_scen[scen_priority[j]].scenario_reg;
 		}
 		l = get_md1_scenario_internal(fake_share_reg);
-		pr_info("test getting MD scenario:%d(%s) 0x%x\n",
+		pr_debug("test getting MD scenario:%d(%s) 0x%x\n",
 			l, mdpm_scen[l].scenario_name, fake_share_reg);
 		if (l != scen_priority[i])
-			pr_info("[UT] getting scenario:%d(%s) 0x%x ERROR\n",
+			pr_debug("[UT] getting scenario:%d(%s) 0x%x ERROR\n",
 			l, mdpm_scen[l].scenario_name, fake_share_reg);
 	}
 #endif
@@ -897,7 +897,7 @@ void md_power_meter_ut(void)
 	rfhw_sel = 0;
 	for (i = 0; i < POWER_TYPE_NUM; i++) {
 		if (mt_mdpm_debug)
-			pr_info("[UT] ====== POWERTYPE:%d ======\n", i);
+			pr_debug("[UT] ====== POWERTYPE:%d ======\n", i);
 
 		for (j = 0; j <= 31; j++) {
 			memset(fake_share_mem, 0, sizeof(u32) *
@@ -917,7 +917,7 @@ void md_power_meter_ut(void)
 					l = get_md1_scenario_internal
 						(fake_share_reg);
 					l = (l < 0) ? S_STANDBY : l;
-					pr_info("[UT] MD SCENARIO:%d(%s) 0x%x DBM SECTION:%d ======\n",
+					pr_debug("[UT] MD SCENARIO:%d(%s) 0x%x DBM SECTION:%d ======\n",
 					j, mdpm_scen[l].scenario_name,
 					fake_share_reg, k+1);
 				}
@@ -925,7 +925,7 @@ void md_power_meter_ut(void)
 				/* test if share_mem not change */
 				md_power = get_md1_power(i, true);
 				if (mt_mdpm_debug)
-					pr_info("[UT] md_power:%d\n", md_power);
+					pr_debug("[UT] md_power:%d\n", md_power);
 
 				/* test section min value */
 				for (l = 0; l < TX_DBM_NUM; l++) {
@@ -938,7 +938,7 @@ void md_power_meter_ut(void)
 
 				md_power = get_md1_power(i, true);
 				if (mt_mdpm_debug)
-					pr_info("[UT] md_power:%d\n", md_power);
+					pr_debug("[UT] md_power:%d\n", md_power);
 
 				/* test section median value */
 				for (l = 0; l < TX_DBM_NUM; l++) {
@@ -951,7 +951,7 @@ void md_power_meter_ut(void)
 
 				md_power = get_md1_power(i, true);
 				if (mt_mdpm_debug)
-					pr_info("[UT] md_power:%d\n", md_power);
+					pr_debug("[UT] md_power:%d\n", md_power);
 
 				/* test section max value */
 				for (l = 0; l < TX_DBM_NUM; l++) {
@@ -964,7 +964,7 @@ void md_power_meter_ut(void)
 
 				md_power = get_md1_power(i, true);
 				if (mt_mdpm_debug)
-					pr_info("[UT] md_power:%d\n", md_power);
+					pr_debug("[UT] md_power:%d\n", md_power);
 			}
 		}
 	}
diff --git a/drivers/misc/mediatek/base/power/mdpm_v2/mtk_mdpm_common.c b/drivers/misc/mediatek/base/power/mdpm_v2/mtk_mdpm_common.c
index 81d23de62..f22d13982 100644
--- a/drivers/misc/mediatek/base/power/mdpm_v2/mtk_mdpm_common.c
+++ b/drivers/misc/mediatek/base/power/mdpm_v2/mtk_mdpm_common.c
@@ -60,7 +60,7 @@ void init_md_section_level(enum pbm_kicker kicker)
 	share_mem =
 		(u32 *)get_smem_start_addr(MD_SYS1, SMEM_USER_RAW_DBM, NULL);
 	if (share_mem == NULL) {
-		pr_info_ratelimited("can't get dbm share memory\n");
+		pr_debug_ratelimited("can't get dbm share memory\n");
 		return;
 	}
 
@@ -91,7 +91,7 @@ int get_md1_power(enum mdpm_power_type power_type, bool need_update)
 
 	if (power_type >= POWER_TYPE_NUM ||
 		power_type < 0) {
-		pr_notice("[md1_power] invalid power_type=%d\n",
+		pr_debug("[md1_power] invalid power_type=%d\n",
 			power_type);
 		return 0;
 	}
@@ -112,7 +112,7 @@ int get_md1_power(enum mdpm_power_type power_type, bool need_update)
 	share_mem = (u32 *)get_smem_start_addr(MD_SYS1, SMEM_USER_RAW_DBM,
 		NULL);
 	if (share_mem == NULL) {
-		pr_info_ratelimited("can't get dbm share memory\n");
+		pr_debug_ratelimited("can't get dbm share memory\n");
 		return MAX_MD1_POWER;
 	}
 #ifdef DBM_RESERVE_OFFSET
@@ -133,7 +133,7 @@ int get_md1_power(enum mdpm_power_type power_type, bool need_update)
 		&mdpm_power_sta);
 
 	if (mt_mdpm_debug)
-		pr_info("[md1_power] scenario_power=%d tx_power=%d total=%d\n",
+		pr_debug("[md1_power] scenario_power=%d tx_power=%d total=%d\n",
 			scenario_power, tx_power, scenario_power + tx_power);
 
 	return scenario_power + tx_power;
@@ -175,9 +175,9 @@ static ssize_t mt_mdpm_debug_proc_write
 		if (debug >= 0 && debug <= 2)
 			mt_mdpm_debug = debug;
 		else
-			pr_notice("should be [0:disable, 1,2:enable level]\n");
+			pr_debug("should be [0:disable, 1,2:enable level]\n");
 	} else
-		pr_notice("should be [0:disable, 1,2:enable level]\n");
+		pr_debug("should be [0:disable, 1,2:enable level]\n");
 
 	return count;
 }
@@ -261,7 +261,7 @@ static int mt_mdpm_create_procfs(void)
 #else /* MD_POWER_METER_ENABLE */
 void init_md_section_level(enum pbm_kicker kicker)
 {
-	pr_notice("MD_POWER_METER_ENABLE:0\n");
+	pr_debug("MD_POWER_METER_ENABLE:0\n");
 }
 
 int get_md1_power(enum mdpm_power_type power_type, bool need_update)
diff --git a/drivers/misc/mediatek/base/power/mt6785/Makefile b/drivers/misc/mediatek/base/power/mt6785/Makefile
index ac0caf02f..1399f6a57 100644
--- a/drivers/misc/mediatek/base/power/mt6785/Makefile
+++ b/drivers/misc/mediatek/base/power/mt6785/Makefile
@@ -59,13 +59,13 @@ obj-$(CONFIG_MACH_MT6785) += mtk_gpufreq_core.o
 obj-$(CONFIG_MACH_MT6785) += mtk_picachu.o
 endif
 
-$(info *GPU CONFIG_MTK_FREQ_HOPPING = $(CONFIG_MTK_FREQ_HOPPING))
-$(info *GPU MT_GPUFREQ_BRINGUP = $(MT_GPUFREQ_BRINGUP))
-$(info *GPU MT_GPUFREQ_GED_READY = $(MT_GPUFREQ_GED_READY))
-$(info *GPU MT_GPUFREQ_KICKER_PBM_READY = $(MT_GPUFREQ_KICKER_PBM_READY))
-$(info *GPU MT_GPUFREQ_STATIC_PWR_READY2USE = $(MT_GPUFREQ_STATIC_PWR_READY2USE))
-$(info *GPU MT_GPUFREQ_LOW_BATT_VOLT_PROTECT = $(MT_GPUFREQ_LOW_BATT_VOLT_PROTECT))
-$(info *GPU MT_GPUFREQ_BATT_PERCENT_PROTECT = $(MT_GPUFREQ_BATT_PERCENT_PROTECT))
-$(info *GPU MT_GPUFREQ_BATT_OC_PROTECT = $(MT_GPUFREQ_BATT_OC_PROTECT))
-$(info *GPU MT_GPUFREQ_DYNAMIC_POWER_TABLE_UPDATE = $(MT_GPUFREQ_DYNAMIC_POWER_TABLE_UPDATE))
-$(info *GPU MT_GPUFREQ_SETTLE_TIME_PROFILE = $(MT_GPUFREQ_SETTLE_TIME_PROFILE))
+#$(info *GPU CONFIG_MTK_FREQ_HOPPING = $(CONFIG_MTK_FREQ_HOPPING))
+#$(info *GPU MT_GPUFREQ_BRINGUP = $(MT_GPUFREQ_BRINGUP))
+#$(info *GPU MT_GPUFREQ_GED_READY = $(MT_GPUFREQ_GED_READY))
+#$(info *GPU MT_GPUFREQ_KICKER_PBM_READY = $(MT_GPUFREQ_KICKER_PBM_READY))
+#$(info *GPU MT_GPUFREQ_STATIC_PWR_READY2USE = $(MT_GPUFREQ_STATIC_PWR_READY2USE))
+#$(info *GPU MT_GPUFREQ_LOW_BATT_VOLT_PROTECT = $(MT_GPUFREQ_LOW_BATT_VOLT_PROTECT))
+#$(info *GPU MT_GPUFREQ_BATT_PERCENT_PROTECT = $(MT_GPUFREQ_BATT_PERCENT_PROTECT))
+#$(info *GPU MT_GPUFREQ_BATT_OC_PROTECT = $(MT_GPUFREQ_BATT_OC_PROTECT))
+#$(info *GPU MT_GPUFREQ_DYNAMIC_POWER_TABLE_UPDATE = $(MT_GPUFREQ_DYNAMIC_POWER_TABLE_UPDATE))
+#$(info *GPU MT_GPUFREQ_SETTLE_TIME_PROFILE = $(MT_GPUFREQ_SETTLE_TIME_PROFILE))
diff --git a/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq.h b/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq.h
index 18ec6612c..254907c9c 100644
--- a/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq.h
+++ b/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq.h
@@ -91,4 +91,9 @@ typedef void (*gpufreq_input_boost_notify)(unsigned int);
 extern void mt_gpufreq_input_boost_notify_registerCB(
 		gpufreq_input_boost_notify pCB);
 
+/**
+ * GED_SKI_SUPPORT
+ */
+extern int mt_gpufreq_get_immed_gpu_temp(void);
+
 #endif /* _MT_GPUFREQ_H_ */
diff --git a/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq_core.c b/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq_core.c
index d885cdee2..8efb60730 100644
--- a/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq_core.c
+++ b/drivers/misc/mediatek/base/power/mt6785/mtk_gpufreq_core.c
@@ -576,7 +576,7 @@ void mt_gpufreq_power_control_disable(bool cg, bool mtcmos, bool buck)
 
 	/* Be powering off MTCMOS and BUCK when PTPOD is initializing */
 	if (g_DVFS_is_paused_by_ptpod) {
-		gpufreq_pr_info(
+		gpufreq_pr_debug(
 				"@%s: DVFS is paused by PTPOD\n",
 				__func__);
 	}
@@ -679,12 +679,12 @@ void mt_gpufreq_enable_by_ptpod(void)
 
 #if defined(CONFIG_ARM64) && \
 	defined(CONFIG_BUILD_ARM64_DTB_OVERLAY_IMAGE_NAMES)
-	gpufreq_pr_info("@%s: flavor name: %s\n",
+	gpufreq_pr_debug("@%s: flavor name: %s\n",
 			__func__,
 			CONFIG_BUILD_ARM64_DTB_OVERLAY_IMAGE_NAMES);
 	if ((strstr(CONFIG_BUILD_ARM64_DTB_OVERLAY_IMAGE_NAMES,
 		"k85v1_64_aging") != NULL)) {
-		gpufreq_pr_info(
+		gpufreq_pr_debug(
 				"@%s: AGING flavor !!!\n",
 				__func__);
 		g_enable_aging_test = 1;
@@ -922,6 +922,12 @@ unsigned int mt_gpufreq_get_min_power(void)
 			g_power_table[g_segment_min_opp_idx].gpufreq_power;
 }
 
+/* API : get immediate gpu temperature */
+int mt_gpufreq_get_immed_gpu_temp(void)
+{
+	return get_immediate_gpu_wrap();
+}
+
 /* API : get static leakage power */
 unsigned int mt_gpufreq_get_leakage_mw(void)
 {
@@ -3149,7 +3155,7 @@ static void __mt_gpufreq_set_initial(void)
 			(DRV_Reg32(MFGPLL_CON1) & (0x7 << POSDIV_SHIFT))
 			>> POSDIV_SHIFT;
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: preloader opp index = %d(%d), initial opp index = %d, g_posdiv_power = %d\n",
 			__func__,
 			cur_preloader_idx,
@@ -3232,7 +3238,7 @@ static int __mt_gpufreq_init_pmic(struct platform_device *pdev)
 
 	g_buck_on = true;
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: VGPU sfchg raising rate: %d (us/step),\t"
 			" VGPU sfchg falling rate: %d (us/step),\t"
 			" VSRAM_GPU sfchg raising rate: %d (us/step),\t"
@@ -3243,7 +3249,7 @@ static int __mt_gpufreq_init_pmic(struct platform_device *pdev)
 			g_vsram_sfchg_rrate,
 			g_vsram_sfchg_frate);
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: VGPU is enabled = %d (%d mV), VSRAM_GPU is enabled = %d (%d mV)\n",
 			__func__,
 			regulator_is_enabled(g_pmic->reg_vgpu),
@@ -3349,7 +3355,7 @@ static int __mt_gpufreq_init_clk(struct platform_device *pdev)
 		return PTR_ERR(g_clk->mtcmos_mfg_core3);
 	}
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: clk_mux is at 0x%p, clk_main_parent is at 0x%p,\t"
 			" clk_sub_parent is at 0x%p, subsys_mfg_cg is at 0x%p,\t"
 			" mtcmos_mfg_async is at 0x%p, mtcmos_mfg is at 0x%p,\t"
@@ -3386,7 +3392,7 @@ static void __mt_gpufreq_init_efuse(void)
 		g_segment_id = MT6785T_SEGMENT;
 	}
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: g_efuse_id = 0x%08X, g_segment_id = %d\n",
 			__func__,
 			g_efuse_id,
@@ -3487,21 +3493,21 @@ static int __mt_gpufreq_pdrv_probe(struct platform_device *pdev)
 	/* setup initial frequency */
 	__mt_gpufreq_set_initial();
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: freq = %d (KHz), vgpu = %d (uV), vsram_gpu = %d (uV)\n",
 			__func__,
 			mt_get_ckgen_freq(15),
 			__mt_gpufreq_get_cur_vgpu() * 10,
 			__mt_gpufreq_get_cur_vsram_gpu() * 10);
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: g_cur_opp_freq = %d, g_cur_opp_vgpu = %d, g_cur_opp_vsram_gpu = %d\n",
 			__func__,
 			g_cur_opp_freq,
 			g_cur_opp_vgpu,
 			g_cur_opp_vsram_gpu);
 
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: g_cur_opp_idx = %d\n",
 			__func__,
 			g_cur_opp_idx);
@@ -3520,7 +3526,7 @@ static int __init __mt_gpufreq_init(void)
 
 #if MT_GPUFREQ_BRINGUP == 1
 	/* skip driver init in bring up stage */
-	gpufreq_pr_info(
+	gpufreq_pr_debug(
 			"@%s: init freq = %d (KHz)\n",
 			__func__,
 			mt_get_ckgen_freq(15));
diff --git a/drivers/misc/mediatek/base/power/mt6785/mtk_picachu.c b/drivers/misc/mediatek/base/power/mt6785/mtk_picachu.c
index 2dafca779..7683bba28 100644
--- a/drivers/misc/mediatek/base/power/mt6785/mtk_picachu.c
+++ b/drivers/misc/mediatek/base/power/mt6785/mtk_picachu.c
@@ -68,6 +68,7 @@
 #define TAG     "[Picachu] "
 
 #define picachu_pr_notice(fmt, args...)	pr_notice(TAG fmt, ##args)
+#define picachu_pr_debug(fmt, args...)	pr_debug(TAG fmt, ##args)
 
 #define picachu_read(addr)		__raw_readl((void __iomem *)(addr))
 #define picachu_write(addr, val)	mt_reg_sync_writel(val, addr)
@@ -249,7 +250,7 @@ static int create_procfs_entries(struct proc_dir_entry *dir,
 		if (!proc_create_data(entries[i].name, proc->mode, dir,
 				entries[i].fops,
 				(void *) &picachu_data[proc->vproc_id])) {
-			picachu_pr_notice("create /proc/picachu/%s failed\n",
+			picachu_pr_debug("create /proc/picachu/%s failed\n",
 					entries[i].name);
 			return -ENOMEM;
 		}
@@ -266,14 +267,14 @@ static int create_procfs(void)
 
 	root = proc_mkdir("picachu", NULL);
 	if (!root) {
-		picachu_pr_notice("mkdir /proc/picachu failed\n");
+		picachu_pr_debug("mkdir /proc/picachu failed\n");
 		return -ENOMEM;
 	}
 
 	for (proc = picachu_proc_list; proc->name; proc++) {
 		dir = proc_mkdir(proc->name, root);
 		if (!dir) {
-			picachu_pr_notice("mkdir /proc/picachu/%s failed\n",
+			picachu_pr_debug("mkdir /proc/picachu/%s failed\n",
 							proc->name);
 			return -ENOMEM;
 		}
@@ -338,7 +339,7 @@ static int __init picachu_init(void)
 
 	eem_base_addr = ioremap(EEM_BASEADDR, EEM_SIZE);
 	if (!eem_base_addr) {
-		picachu_pr_notice("ioremap eem_base_addr failed!\n");
+		picachu_pr_debug("ioremap eem_base_addr failed!\n");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/misc/mediatek/base/power/pbm_v4/mtk_pbm.c b/drivers/misc/mediatek/base/power/pbm_v4/mtk_pbm.c
index 1b2d39b90..563eca5c5 100644
--- a/drivers/misc/mediatek/base/power/pbm_v4/mtk_pbm.c
+++ b/drivers/misc/mediatek/base/power/pbm_v4/mtk_pbm.c
@@ -149,7 +149,7 @@ unsigned int ma_to_mw(unsigned int val)
 
 	bat_vol = get_battery_volt();	/* return mV */
 	ret_val = (bat_vol * val) / 1000;	/* mW = (mV * mA)/1000 */
-	pr_info("[%s] %d(mV) * %d(mA) = %d(mW)\n",
+	pr_debug("[%s] %d(mV) * %d(mA) = %d(mW)\n",
 		__func__, bat_vol, val, ret_val);
 
 	return ret_val;
@@ -160,7 +160,7 @@ void dump_kicker_info(void)
 	struct hpf *hpfmgr = &hpf_ctrl;
 
 	if (mt_pbm_debug)
-		pr_info("(M1/F/G)=%d,%d,%d;(C/G)=%ld,%ld\n",
+		pr_debug("(M1/F/G)=%d,%d,%d;(C/G)=%ld,%ld\n",
 			hpfmgr->switch_md1, hpfmgr->switch_flash,
 			hpfmgr->switch_gpu, hpfmgr->loading_cpu,
 			hpfmgr->loading_gpu);
@@ -176,7 +176,7 @@ int hpf_get_power_leakage(void)
 	hpfmgr->loading_leakage = leakage_cpu + leakage_gpu;
 
 	if (mt_pbm_debug)
-		pr_info("[%s] %ld=%d+%d\n", __func__,
+		pr_debug("[%s] %ld=%d+%d\n", __func__,
 			hpfmgr->loading_leakage, leakage_cpu, leakage_gpu);
 
 	return hpfmgr->loading_leakage;
@@ -269,7 +269,7 @@ static void pbm_allocate_budget_manager(void)
 	/* no any resource can allocate */
 	if (dlpt == 0) {
 		if (mt_pbm_debug)
-			pr_info("DLPT=0\n");
+			pr_debug("DLPT=0\n");
 
 		return;
 	}
@@ -323,14 +323,14 @@ static void pbm_allocate_budget_manager(void)
 	hpf_ctrl.to_gpu_budget = togpu;
 
 	if (mt_pbm_debug) {
-		pr_info
+		pr_debug
 ("(C/G)=%d,%d=>(D/L/M1/F/C/G)=%d,%d,%d,%d,%d,%d(Multi:%d),%d\n",
 cpu, gpu, dlpt, leakage, md1, flash, tocpu, togpu,
 multiple, cpu_lower_bound);
 	} else {
 		if (((abs(pre_tocpu - tocpu) >= 10) && cpu > tocpu) ||
 			((abs(pre_togpu - togpu) >= 10) && gpu > togpu)) {
-			pr_info
+			pr_debug
 ("(C/G)=%d,%d=>(D/L/M1/F/C/G)=%d,%d,%d,%d,%d,%d(Multi:%d),%d\n",
 cpu, gpu, dlpt, leakage, md1, flash, tocpu, togpu,
 multiple, cpu_lower_bound);
@@ -352,7 +352,7 @@ static bool pbm_func_enable_check(void)
 	struct pbm *pwrctrl = &pbm_ctrl;
 
 	if (!pwrctrl->feature_en || !pwrctrl->pbm_drv_done) {
-		pr_info("feature_en: %d, pbm_drv_done: %d\n",
+		pr_debug("feature_en: %d, pbm_drv_done: %d\n",
 		pwrctrl->feature_en, pwrctrl->pbm_drv_done);
 		return false;
 	}
@@ -556,13 +556,13 @@ static int pbm_thread_handle(void *data)
 				pbm_allocate_budget_manager();
 				g_dlpt_state_sync = 0;
 			} else {
-				pr_notice("DISABLE PBM\n");
+				pr_debug("DISABLE PBM\n");
 
 				if (g_dlpt_state_sync == 0) {
 					mt_ppm_dlpt_set_limit_by_pbm(0);
 					mt_gpufreq_set_power_limit_by_pbm(0);
 					g_dlpt_state_sync = 1;
-					pr_info("Release DLPT limit\n");
+					pr_debug("Release DLPT limit\n");
 				}
 			}
 		}
@@ -596,13 +596,13 @@ _mt_pbm_pm_callback(struct notifier_block *nb,
 
 	case PM_SUSPEND_PREPARE:
 		if (mt_pbm_debug)
-			pr_info("PM_SUSPEND_PREPARE:start\n");
+			pr_debug("PM_SUSPEND_PREPARE:start\n");
 
 		mutex_lock(&pbm_mutex);
 		g_dlpt_need_do = 0;
 		mutex_unlock(&pbm_mutex);
 		if (mt_pbm_debug)
-			pr_info("PM_SUSPEND_PREPARE:end\n");
+			pr_debug("PM_SUSPEND_PREPARE:end\n");
 
 		break;
 
@@ -611,13 +611,13 @@ _mt_pbm_pm_callback(struct notifier_block *nb,
 
 	case PM_POST_SUSPEND:
 		if (mt_pbm_debug)
-			pr_info("PM_POST_SUSPEND:start\n");
+			pr_debug("PM_POST_SUSPEND:start\n");
 
 		mutex_lock(&pbm_mutex);
 		g_dlpt_need_do = 1;
 		mutex_unlock(&pbm_mutex);
 		if (mt_pbm_debug)
-			pr_info("PM_POST_SUSPEND:end\n");
+			pr_debug("PM_POST_SUSPEND:end\n");
 
 		break;
 
@@ -688,9 +688,9 @@ static ssize_t mt_pbm_debug_proc_write
 		else if (debug == 1)
 			mt_pbm_debug = 1;
 		else
-			pr_notice("should be [0:disable,1:enable]\n");
+			pr_debug("should be [0:disable,1:enable]\n");
 	} else
-		pr_notice("should be [0:disable,1:enable]\n");
+		pr_debug("should be [0:disable,1:enable]\n");
 
 	return count;
 }
@@ -730,10 +730,10 @@ static ssize_t mt_pbm_debug_log_reduc_proc_write
 			mt_pbm_debug = 1;
 			mt_pbm_log_counter = 0;
 		} else {
-			pr_notice("Should be >=0 [0:disable,other:enable]\n");
+			pr_debug("Should be >=0 [0:disable,other:enable]\n");
 		}
 	} else
-		pr_notice("Should be >=0 [0:disable,other:enable]\n");
+		pr_debug("Should be >=0 [0:disable,other:enable]\n");
 
 	return count;
 }
@@ -764,7 +764,7 @@ static ssize_t mt_pbm_manual_mode_proc_write
 	if (sscanf(desc, "%d %d %d %d %d %d %d", &manual_mode, &loading_dlpt,
 		&loading_leakage, &loading_md1, &loading_cpu, &loading_gpu,
 		&loading_flash) != 7) {
-		pr_notice("parameter number not correct\n");
+		pr_debug("parameter number not correct\n");
 		return -EPERM;
 	}
 
@@ -780,7 +780,7 @@ static ssize_t mt_pbm_manual_mode_proc_write
 	} else if (manual_mode == 0)
 		pbm_ctrl.manual_mode = 0;
 	else
-		pr_notice("pbm manual setting should be 0 or 1 or 2\n");
+		pr_debug("pbm manual setting should be 0 or 1 or 2\n");
 
 	return count;
 }
@@ -868,12 +868,12 @@ static int __init pbm_module_init(void)
 	ret = create_pbm_kthread();
 
 	#ifdef MD_POWER_UT
-	/* pr_info("share_reg: %x", spm_vcorefs_get_MD_status());*/
+	/* pr_debug("share_reg: %x", spm_vcorefs_get_MD_status());*/
 	mt_pbm_debug = 1;
 	md_power_meter_ut();
 	#endif
 
-	pr_info("%s : Done\n", __func__);
+	pr_debug("%s : Done\n", __func__);
 
 	if (ret) {
 		pr_err("FAILED TO CREATE PBM KTHREAD\n");
@@ -906,7 +906,7 @@ void kicker_pbm_by_flash(bool status)
 
 static int __init pbm_module_init(void)
 {
-	pr_notice("DISABLE_PBM_FEATURE is defined.\n");
+	pr_debug("DISABLE_PBM_FEATURE is defined.\n");
 	return 0;
 }
 
diff --git a/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs.c b/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs.c
index ddc0281f6..95769c34c 100644
--- a/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs.c
+++ b/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs.c
@@ -42,15 +42,15 @@ bool slp_chk_golden_diff_mode = true;
 
 void __weak mt_power_gs_suspend_compare(unsigned int dump_flag)
 {
-	pr_info("Power_gs: %s does not implement\n", __func__);
+	pr_debug("Power_gs: %s does not implement\n", __func__);
 }
 void __weak mt_power_gs_dpidle_compare(unsigned int dump_flag)
 {
-	pr_info("Power_gs: %s does not implement\n", __func__);
+	pr_debug("Power_gs: %s does not implement\n", __func__);
 }
 void __weak mt_power_gs_sodi_compare(unsigned int dump_flag)
 {
-	pr_info("Power_gs: %s does not implement\n", __func__);
+	pr_debug("Power_gs: %s does not implement\n", __func__);
 }
 
 /* deprecated, temp used for api argument transfer */
diff --git a/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs_api.c b/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs_api.c
index f118922c2..e1f56b88f 100644
--- a/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs_api.c
+++ b/drivers/misc/mediatek/base/power/power_gs_v1/mtk_power_gs_api.c
@@ -359,13 +359,13 @@ void mt_power_gs_pmic_manual_dump(void)
 				_golden_read_reg(pmd.addr_array[i]));
 
 			if (dump_cnt && ((dump_cnt % PER_LINE_TO_PRINT) == 0)) {
-				pr_notice("%s", buf);
+				pr_debug("%s", buf);
 				p = buf;
 				p += snprintf(p, sizeof(buf), "\n");
 			}
 		}
 		if (dump_cnt % PER_LINE_TO_PRINT)
-			pr_notice("%s", buf);
+			pr_debug("%s", buf);
 	}
 }
 
@@ -407,7 +407,7 @@ void mt_power_gs_compare(char *scenario, char *pmic_name,
 
 				if (dump_cnt &&
 					((dump_cnt % PER_LINE_TO_PRINT) == 0)) {
-					pr_notice("%s", buf);
+					pr_debug("%s", buf);
 					p = buf;
 					p += snprintf(p, sizeof(buf), "\n");
 				}
@@ -415,7 +415,7 @@ void mt_power_gs_compare(char *scenario, char *pmic_name,
 
 		}
 		if (dump_cnt % PER_LINE_TO_PRINT)
-			pr_notice("%s", buf);
+			pr_debug("%s", buf);
 
 	/* dump raw data mode */
 	} else {
@@ -433,12 +433,12 @@ void mt_power_gs_compare(char *scenario, char *pmic_name,
 				scenario, pmic_name, pmic_gs[i], val0);
 
 			if (dump_cnt && ((dump_cnt % PER_LINE_TO_PRINT) == 0)) {
-				pr_notice("%s", buf);
+				pr_debug("%s", buf);
 				p = buf;
 				p += snprintf(p, sizeof(buf), "\n");
 			}
 		}
 		if (dump_cnt % PER_LINE_TO_PRINT)
-			pr_notice("%s", buf);
+			pr_debug("%s", buf);
 	}
 }
diff --git a/drivers/misc/mediatek/base/power/ppm_v3/inc/mtk_ppm_internal.h b/drivers/misc/mediatek/base/power/ppm_v3/inc/mtk_ppm_internal.h
index 8ea66a980..29f6123d7 100644
--- a/drivers/misc/mediatek/base/power/ppm_v3/inc/mtk_ppm_internal.h
+++ b/drivers/misc/mediatek/base/power/ppm_v3/inc/mtk_ppm_internal.h
@@ -118,7 +118,7 @@ static const struct file_operations ppm_ ## name ## _proc_fops = {            \
 
 #define ppm_err			ppm_info
 #define ppm_warn		ppm_info
-#define ppm_info(fmt, args...)	pr_notice(TAG""fmt, ##args)
+#define ppm_info(fmt, args...)	pr_debug(TAG""fmt, ##args)
 #define ppm_dbg(type, fmt, args...)				\
 	do {							\
 		if (ppm_debug & ALL || ppm_debug & type)	\
diff --git a/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_main.c b/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_main.c
index efc7c3536..2183eec9c 100644
--- a/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_main.c
+++ b/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_main.c
@@ -26,7 +26,9 @@
 #include <linux/string.h>
 #include <linux/topology.h>
 #include "mtk_ppm_internal.h"
+#ifdef CONFIG_MTK_PERF_TRACKER
 #include <trace/events/mtk_events.h>
+#endif
 #include <linux/of.h>
 
 /*==============================================================*/
@@ -658,12 +660,14 @@ int mt_ppm_main(void)
 			pos->is_limit_updated = true;
 
 			for (idx = 0; idx < pos->req.cluster_num; idx++) {
+#ifdef CONFIG_MTK_PERF_TRACKER
 				trace_ppm_user_setting(
 					pos->policy,
 					idx,
 					pos->req.limit[idx].min_cpufreq_idx,
 					pos->req.limit[idx].max_cpufreq_idx
 				);
+#endif
 			}
 
 			ppm_unlock(&pos->lock);
diff --git a/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_policy_sys_boost.c b/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_policy_sys_boost.c
index 80d112689..a18eb17a3 100644
--- a/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_policy_sys_boost.c
+++ b/drivers/misc/mediatek/base/power/ppm_v3/src/mtk_ppm_policy_sys_boost.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 MediaTek Inc.
+ * Copyright (C) 2021 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -548,6 +549,8 @@ static int __init ppm_sysboost_policy_init(void)
 		case BOOST_BY_BOOT_TIME_OPT:
 			sysboost_data[i].user_name = "BOOT_TIME_OPT";
 			break;
+		case BOOST_BY_XM_THERMAL:
+			sysboost_data[i].user_name = "XM_THERM";
 		case BOOST_BY_UT:
 		default:
 			sysboost_data[i].user_name = "UT";
@@ -573,7 +576,7 @@ static int __init ppm_sysboost_policy_init(void)
 	ppm_info("@%s: register %s done!\n", __func__, sysboost_policy.name);
 
 out:
-	sysboost_policy.is_enabled = false;
+	sysboost_policy.is_enabled = true;
 	FUNC_EXIT(FUNC_LV_POLICY);
 
 	return ret;
diff --git a/drivers/misc/mediatek/base/power/qos/mtk_qos_bound.c b/drivers/misc/mediatek/base/power/qos/mtk_qos_bound.c
index eb93cd588..4c50e9c80 100644
--- a/drivers/misc/mediatek/base/power/qos/mtk_qos_bound.c
+++ b/drivers/misc/mediatek/base/power/qos/mtk_qos_bound.c
@@ -170,19 +170,19 @@ int qos_notifier_call_chain(unsigned long val, void *v)
 	if (is_qos_bound_log_enabled()) {
 		idx = bound->idx;
 		stat = &bound->stats[bound->idx];
-		pr_info("idx: %hu, state: %hu, num: %hu, event: %hu\n",
+		pr_debug("idx: %hu, state: %hu, num: %hu, event: %hu\n",
 				idx, state,
 				stat->num, stat->event);
 		for (i = 0; i < NR_QOS_EMIBM_TYPE; i++)
-			pr_info("emibw [%d]: mon: %hu, req: %hu\n", i,
+			pr_debug("emibw [%d]: mon: %hu, req: %hu\n", i,
 					stat->emibw_mon[i],
 					stat->emibw_req[i]);
 		for (i = 0; i < NR_QOS_SMIBM_TYPE; i++)
-			pr_info("smibw [%d]: mon: %hu, req: %hu\n", i,
+			pr_debug("smibw [%d]: mon: %hu, req: %hu\n", i,
 					stat->smibw_mon[i],
 					stat->smibw_req[i]);
 		for (i = 0; i < NR_QOS_LAT_TYPE; i++)
-			pr_info("lat [%d]: mon: %hu\n", i, stat->lat_mon[i]);
+			pr_debug("lat [%d]: mon: %hu\n", i, stat->lat_mon[i]);
 	}
 
 	ret = blocking_notifier_call_chain(&qos_bound_chain_head, val, v);
diff --git a/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi.c b/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi.c
index 5abc819f9..4014ba0a2 100644
--- a/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi.c
+++ b/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi.c
@@ -73,7 +73,7 @@ int qos_ipi_to_sspm_command(void *buffer, int slot)
 	int ret = sspm_ipi_send_sync(IPI_ID_QOS, IPI_OPT_POLLING,
 			buffer, slot, &ack_data, 1);
 	if (ret != 0)
-		pr_notice("qos_ipi_to_sspm error(%d)\n", ret);
+		pr_err("qos_ipi_to_sspm error(%d)\n", ret);
 #endif
 	return ack_data;
 }
diff --git a/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi_v2.c b/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi_v2.c
index 47b6adae3..1dadce73f 100644
--- a/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi_v2.c
+++ b/drivers/misc/mediatek/base/power/qos/mtk_qos_ipi_v2.c
@@ -41,7 +41,7 @@ static int qos_ipi_recv_thread(void *arg)
 {
 	struct qos_ipi_data *qos_ipi_d;
 
-	pr_info("%s start!\n", __func__);
+	pr_debug("%s start!\n", __func__);
 	do {
 		mtk_ipi_recv(&sspm_ipidev, IPIR_I_QOS);
 
@@ -65,7 +65,7 @@ static int qos_ipi_recv_thread(void *arg)
 			break;
 #endif /* QOS_PREFETCH_SUPPORT */
 		default:
-			pr_info("wrong QoS IPI command: %d\n", qos_ipi_d->cmd);
+			pr_debug("wrong QoS IPI command: %d\n", qos_ipi_d->cmd);
 		}
 	} while (!kthread_should_stop());
 
@@ -81,14 +81,14 @@ int qos_ipi_to_sspm_command(void *buffer, int slot)
 	int slot_num = sizeof(struct qos_ipi_data)/SSPM_MBOX_SLOT_SIZE;
 
 	if (qos_sspm_ready != 1) {
-		pr_info("qos ipi not ready, skip cmd=%d\n", qos_ipi_d->cmd);
+		pr_debug("qos ipi not ready, skip cmd=%d\n", qos_ipi_d->cmd);
 		goto error;
 	}
 
 	qos_ipi_ackdata = 0;
 
 	if (slot > slot_num) {
-		pr_info("qos ipi cmd %d req slot error(%d > %d)\n",
+		pr_debug("qos ipi cmd %d req slot error(%d > %d)\n",
 			qos_ipi_d->cmd, slot, slot_num);
 		goto error;
 	}
@@ -97,13 +97,13 @@ int qos_ipi_to_sspm_command(void *buffer, int slot)
 		IPI_SEND_POLLING, buffer,
 		slot_num, 2000);
 	if (ret) {
-		pr_info("qos ipi cmd %d send fail,ret=%d\n",
+		pr_debug("qos ipi cmd %d send fail,ret=%d\n",
 		qos_ipi_d->cmd, ret);
 		goto error;
 	}
 
 	if (!qos_ipi_ackdata) {
-		pr_info("qos ipi cmd %d ack fail, ackdata=%d\n",
+		pr_debug("qos ipi cmd %d ack fail, ackdata=%d\n",
 		qos_ipi_d->cmd, qos_ipi_ackdata);
 		goto error;
 	}
@@ -122,7 +122,7 @@ void qos_ipi_init(void)
 	ret = mtk_ipi_register(&sspm_ipidev, IPIS_C_QOS, NULL, NULL,
 				(void *) &qos_ipi_ackdata);
 	if (ret) {
-		pr_info("qos IPIS_C_QOS ipi_register fail, ret %d\n", ret);
+		pr_debug("qos IPIS_C_QOS ipi_register fail, ret %d\n", ret);
 		qos_sspm_ready = -1;
 		return;
 	}
@@ -131,13 +131,13 @@ void qos_ipi_init(void)
 	ret = mtk_ipi_register(&sspm_ipidev, IPIR_I_QOS, NULL, NULL,
 				(void *) &qos_recv_ackdata);
 	if (ret) {
-		pr_info("qos IPIR_I_QOS ipi_register fail, ret %d\n", ret);
+		pr_debug("qos IPIR_I_QOS ipi_register fail, ret %d\n", ret);
 		qos_sspm_ready = -2;
 		return;
 	}
 	qos_sspm_ready = 1;
 	qos_sspm_enable();
-	pr_info("qos ipi is ready!\n");
+	pr_debug("qos ipi is ready!\n");
 #endif
 }
 
@@ -145,7 +145,7 @@ void qos_ipi_recv_init(void)
 {
 #if defined(CONFIG_MTK_TINYSYS_SSPM_SUPPORT)
 	if (qos_sspm_ready != 1) {
-		pr_info("QOS SSPM not ready, recv thread not start!\n");
+		pr_debug("QOS SSPM not ready, recv thread not start!\n");
 		return;
 	}
 	kthread_run(qos_ipi_recv_thread, NULL, "qos_ipi_recv");
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle.c
index 8384a0ff0..4e755a1ff 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle.c
@@ -114,7 +114,7 @@ static ssize_t idle_state_write(char *FromUserBuf, size_t sz, void *priv)
 		} else if (!strcmp(cmd, "spmtwam_sel")) {
 			mtk_idle_get_twam()->sel = parm;
 		} else if (!strcmp(cmd, "spmtwam")) {
-			pr_info("Power/swap spmtwam_event = %d\n", parm);
+			pr_debug("Power/swap spmtwam_event = %d\n", parm);
 			if (parm >= 0)
 				mtk_idle_twam_enable(parm);
 			else
@@ -141,7 +141,7 @@ static void mtk_idle_init(void)
 			, 0644, &idle_state_fops, NULL);
 }
 
-void __init mtk_cpuidle_framework_init(void)
+void mtk_cpuidle_framework_init(void)
 {
 	mtk_idle_sysfs_entry_create();
 
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_export_legacy.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_export_legacy.c
index 9fb53dc27..952cb85a5 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_export_legacy.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_export_legacy.c
@@ -35,6 +35,6 @@ EXPORT_SYMBOL(dpidle_enter);
 /* for display use, abandoned 'spm_enable_sodi' */
 void mtk_idle_disp_is_ready(bool enable)
 {
-	pr_notice("Power/swap - %s not support anymore!\n", __func__);
+	pr_debug("Power/swap - %s not support anymore!\n", __func__);
 }
 
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_internal.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_internal.c
index 3d81b1366..8f941ca31 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_internal.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_internal.c
@@ -106,14 +106,14 @@ int mtk_idle_notifier_register(struct notifier_block *n)
 	symname = kallsyms_lookup((unsigned long)n->notifier_call,
 			NULL, NULL, NULL, namebuf);
 	if (symname) {
-		pr_info("Power/swap [mt_idle_ntf] <%02d>%08lx (%s)\n",
+		pr_debug("Power/swap [mt_idle_ntf] <%02d>%08lx (%s)\n",
 			index++, (unsigned long)n->notifier_call, symname);
 	} else {
-		pr_info("Power/swap [mt_idle_ntf] <%02d>%08lx\n",
+		pr_debug("Power/swap [mt_idle_ntf] <%02d>%08lx\n",
 			index++, (unsigned long)n->notifier_call);
 	}
 	#else
-	pr_info("Power/swap [mt_idle_ntf] <%02d>%08lx\n",
+	pr_debug("Power/swap [mt_idle_ntf] <%02d>%08lx\n",
 			index++, (unsigned long)n->notifier_call);
 	#endif
 
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_module.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_module.c
index 432853a8e..cffea01fc 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_module.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_module.c
@@ -193,7 +193,7 @@ enum idle_fp_step {
 int __attribute__((weak)) mtk_idle_trigger_wfi(
 	int idle_type, unsigned int idle_flag, int cpu)
 {
-	printk_deferred("[name:spm&]Power/swap %s is not implemented!\n"
+	pr_debug("[name:spm&]Power/swap %s is not implemented!\n"
 		, __func__);
 
 	do {
@@ -356,7 +356,7 @@ int mtk_idle_enter(int idle_type,
 	#if defined(CONFIG_SERIAL_8250_MT6577)
 	if (!(idle_flag & MTK_IDLE_LOG_DUMP_LP_GS)) {
 		if (mtk8250_request_to_sleep()) {
-			printk_deferred("[name:spm&]Power/swap Fail to request uart sleep\n");
+			pr_debug("[name:spm&]Power/swap Fail to request uart sleep\n");
 			goto RESTORE_UART;
 		}
 	}
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_profile.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_profile.c
index 4220da3ad..9081fe63b 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_profile.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_profile.c
@@ -137,7 +137,7 @@ void mtk_idle_dump_cnt_in_interval(void)
 	mtk_idle_module_info_dump(MTK_IDLE_MODULE_INFO_COUNT
 				,  get_log(), IDLE_LOG_BUF_LEN);
 	/* dump log */
-	printk_deferred("[name:spm&]Power/swap %s\n", get_log());
+	pr_debug("[name:spm&]Power/swap %s\n", get_log());
 
 	/* dump idle ratio */
 	if (idle_ratio_en) {
@@ -150,7 +150,7 @@ void mtk_idle_dump_cnt_in_interval(void)
 		mtk_idle_module_info_dump(MTK_IDLE_MODULE_INFO_RATIO
 			, get_log_cur()
 			, IDLE_LOG_BUF_LEN - (get_log_cur() - get_log()));
-		printk_deferred("[name:spm&]Power/swap %s --- (ms)\n"
+		pr_debug("[name:spm&]Power/swap %s --- (ms)\n"
 			, get_log());
 		idle_ratio_profile_start_time = idle_get_current_time_ms();
 	}
@@ -169,7 +169,7 @@ void mtk_idle_block_reason_report(struct MTK_IDLE_MODEL_CLERK const *clerk)
 			, "[%d] = (%lu), "
 			, i, clerk->status.cnt.enter[i]);
 
-	printk_deferred("[name:spm&]Power/swap %s\n"
+	pr_debug("[name:spm&]Power/swap %s\n"
 		, get_idle_buf(idle_state_log));
 
 	/* block category */
@@ -181,7 +181,7 @@ void mtk_idle_block_reason_report(struct MTK_IDLE_MODEL_CLERK const *clerk)
 					, "[%s] = %lu, "
 					, mtk_idle_block_reason_name(i)
 					, clerk->status.cnt.block[i]);
-	printk_deferred("[name:spm&]Power/swap %s\n"
+	pr_debug("[name:spm&]Power/swap %s\n"
 		, get_idle_buf(idle_state_log));
 
 	/* block mask */
@@ -191,7 +191,7 @@ void mtk_idle_block_reason_report(struct MTK_IDLE_MODEL_CLERK const *clerk)
 	idle_state_log.p_idx += mtk_idle_cond_append_info(true, clerk->type,
 		idle_state_log.p_idx,
 		IDLE_LOG_BUF_LEN - strlen(idle_state_log.buf));
-	printk_deferred("[name:spm&]Power/swap %s\n"
+	pr_debug("[name:spm&]Power/swap %s\n"
 		, get_idle_buf(idle_state_log));
 	spm_resource_req_block_dump();
 }
@@ -272,7 +272,7 @@ void mtk_idle_latency_profile_result(struct MTK_IDLE_MODEL_CLERK *clerk)
 		_LATENCY.total[2] += (ProfileLatency[2]);
 		_LATENCY.count++;
 	} else {
-		printk_deferred("[name:spm&]Power/latency_profile avg %s: %u, %u, %u\n"
+		pr_debug("[name:spm&]Power/latency_profile avg %s: %u, %u, %u\n"
 			, clerk->name
 			, (unsigned int)_LATENCY.total[0]/PROFILE_LATENCY_NUM
 			, (unsigned int)_LATENCY.total[1]/PROFILE_LATENCY_NUM
@@ -281,6 +281,6 @@ void mtk_idle_latency_profile_result(struct MTK_IDLE_MODEL_CLERK *clerk)
 		_LATENCY.total[0] = _LATENCY.total[1] = _LATENCY.total[2] = 0;
 	}
 
-	printk_deferred("[name:spm&]Power/latency_profile %s\n", plog);
+	pr_debug("[name:spm&]Power/latency_profile %s\n", plog);
 }
 
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_select.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_select.c
index dd7caa430..96afcd545 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_select.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_select.c
@@ -118,7 +118,7 @@ int mtk_idle_entrance(struct mtk_idle_info *info
 		(mtk_idle_plat_bootblock_check() == MTK_IDLE_PLAT_READY))
 	) {
 		if (system_state < SYSTEM_RUNNING) {
-			printk_deferred("[name:spm&]Power/swap %s %s %d\n"
+			pr_debug("[name:spm&]Power/swap %s %s %d\n"
 					, __func__, LOG_STR, system_state);
 		}
 
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_twam.c b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_twam.c
index 286f6fc27..bffb58378 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_idle_twam.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_idle_twam.c
@@ -58,7 +58,7 @@ static void mtk_idle_twam_callback(struct twam_cfg *ts, struct twam_select *sel)
 	int index = 0;
 
 	for (index = 0; index < 4; index++) {
-		pr_notice("Power/swap spm twam (sel%d: %d) ratio: %5u/1000, %d, %d\n",
+		pr_debug("Power/swap spm twam (sel%d: %d) ratio: %5u/1000, %d, %d\n",
 			sel->signal[index], sel->id[index],
 			(idle_twam.speed_mode) ?
 			GET_EVENT_RATIO_SPEED(ts->byte[index].id) :
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_sleep.c b/drivers/misc/mediatek/base/power/spm/common/mtk_sleep.c
index de0070b1e..813b2dae5 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_sleep.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_sleep.c
@@ -62,7 +62,7 @@ static int slp_suspend_ops_valid(suspend_state_t state)
 static int slp_suspend_ops_begin(suspend_state_t state)
 {
 	/* legacy log */
-	printk_deferred("[name:spm&][SLP] @@@@@@@@@@@@\tChip_pm_begin(%u)(%u)\t@@@@@@@@@@@@@\n",
+	pr_debug("[name:spm&][SLP] @@@@@@@@@@@@\tChip_pm_begin(%u)(%u)\t@@@@@@@@@@@@@\n",
 			spm_get_is_cpu_pdn(), spm_get_is_infra_pdn());
 
 	slp_wake_reason = WR_NONE;
@@ -74,7 +74,7 @@ static int slp_suspend_ops_prepare(void)
 {
 #if 0
 	/* legacy log */
-	printk_deferred("[name:spm&][SLP] @@@@@@@@@@@@@@\tChip_pm_prepare\t@@@@@@@@@@@@@@\n");
+	pr_debug("[name:spm&][SLP] @@@@@@@@@@@@@@\tChip_pm_prepare\t@@@@@@@@@@@@@@\n");
 #endif
 	return 0;
 }
@@ -83,7 +83,7 @@ static int slp_suspend_ops_prepare(void)
 || defined(CONFIG_SND_SOC_MTK_SMART_PHONE)
 bool __attribute__ ((weak)) ConditionEnterSuspend(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return true;
 }
 #endif /* MTK_SUSPEND_AUDIO_SUPPORT */
@@ -91,25 +91,25 @@ bool __attribute__ ((weak)) ConditionEnterSuspend(void)
 #ifdef CONFIG_MTK_SYSTRACKER
 void __attribute__ ((weak)) systracker_enable(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 #endif /* CONFIG_MTK_SYSTRACKER */
 
 #ifdef CONFIG_MTK_BUS_TRACER
 void __attribute__ ((weak)) bus_tracer_enable(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 #endif /* CONFIG_MTK_BUS_TRACER */
 
 void __attribute__((weak)) subsys_if_on(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 
 void __attribute__((weak)) pll_if_on(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 
 void __attribute__((weak))
@@ -132,7 +132,7 @@ spm_set_sleep_wakesrc(u32 wakesrc, bool enable, bool replace)
 
 bool __attribute__((weak)) spm_is_enable_sleep(void)
 {
-	pr_info("NO %s !!!\n", __func__);
+	pr_debug("NO %s !!!\n", __func__);
 	return false;
 }
 
@@ -152,7 +152,7 @@ spm_go_to_sleep_ex(unsigned int ex_flag)
 	unsigned int bRet = 0;
 
 	if ((ex_flag & SPM_SUSPEND_PLAT_SLP_DP) != 0)
-		printk_deferred(
+		pr_debug(
 			"[name:spm&][%s:%d] - Spm suspend sleep dpidle not support!!\n"
 			, __func__, __LINE__);
 	else
@@ -163,14 +163,14 @@ spm_go_to_sleep_ex(unsigned int ex_flag)
 bool __attribute__((weak))
 spm_get_is_cpu_pdn(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return false;
 }
 
 bool __attribute__((weak))
 spm_get_is_infra_pdn(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return false;
 }
 
@@ -192,7 +192,7 @@ static int slp_suspend_ops_enter(suspend_state_t state)
 
 #if 0
 	/* legacy log */
-	printk_deferred("[name:spm&][SLP] @@@@@@@@@@@@@@@\tChip_pm_enter\t@@@@@@@@@@@@@@@\n");
+	pr_debug("[name:spm&][SLP] @@@@@@@@@@@@@@@\tChip_pm_enter\t@@@@@@@@@@@@@@@\n");
 #endif
 
 #if !defined(CONFIG_FPGA_EARLY_PORTING)
@@ -206,14 +206,14 @@ static int slp_suspend_ops_enter(suspend_state_t state)
 #endif /* CONFIG_FPGA_EARLY_PORTING */
 
 	if (spm_get_is_infra_pdn() && !spm_get_is_cpu_pdn()) {
-		printk_deferred("[name:spm&][SLP] CANNOT SLEEP DUE TO INFRA PDN BUT CPU PDN\n");
+		pr_debug("[name:spm&][SLP] CANNOT SLEEP DUE TO INFRA PDN BUT CPU PDN\n");
 		ret = -EPERM;
 		goto LEAVE_SLEEP;
 	}
 
 #ifdef CONFIG_MTK_TINYSYS_SSPM_SUPPORT
 	if (is_sspm_ipi_lock_spm()) {
-		printk_deferred("[name:spm&][SLP] CANNOT SLEEP DUE TO SSPM IPI\n");
+		pr_debug("[name:spm&][SLP] CANNOT SLEEP DUE TO SSPM IPI\n");
 		ret = -EPERM;
 		goto LEAVE_SLEEP;
 	}
@@ -221,7 +221,7 @@ static int slp_suspend_ops_enter(suspend_state_t state)
 
 #if !defined(CONFIG_FPGA_EARLY_PORTING)
 	if (spm_load_firmware_status() < 1) {
-		printk_deferred("[name:spm&]SPM FIRMWARE IS NOT READY\n");
+		pr_debug("[name:spm&]SPM FIRMWARE IS NOT READY\n");
 		ret = -EPERM;
 		goto LEAVE_SLEEP;
 	}
@@ -267,7 +267,7 @@ static void slp_suspend_ops_finish(void)
 {
 #if 0
 	/* legacy log */
-	printk_deferred("[name:spm&][SLP] @@@@@@@@@@@@\tChip_pm_finish\t@@@@@@@@@@\n");
+	pr_debug("[name:spm&][SLP] @@@@@@@@@@@@\tChip_pm_finish\t@@@@@@@@@@\n");
 #endif
 }
 
@@ -275,7 +275,7 @@ static void slp_suspend_ops_end(void)
 {
 #if 0
 	/* legacy log */
-	printk_deferred("[name:spm&][SLP] @@@@@@@@@@@@\tChip_pm_end\t@@@@@@@@@@@@\n");
+	pr_debug("[name:spm&][SLP] @@@@@@@@@@@@\tChip_pm_end\t@@@@@@@@@@@@\n");
 #endif
 }
 
@@ -291,7 +291,7 @@ static const struct platform_suspend_ops slp_suspend_ops = {
 __attribute__ ((weak))
 int spm_set_dpidle_wakesrc(u32 wakesrc, bool enable, bool replace)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return 0;
 }
 
@@ -305,7 +305,7 @@ int slp_set_wakesrc(u32 wakesrc, bool enable, bool ck26m_on)
 	int r;
 	unsigned long flags;
 
-	printk_deferred("[name:spm&][SLP] wakesrc = 0x%x, enable = %u, ck26m_on = %u\n",
+	pr_debug("[name:spm&][SLP] wakesrc = 0x%x, enable = %u, ck26m_on = %u\n",
 		wakesrc, enable, ck26m_on);
 
 #if SLP_REPLACE_DEF_WAKESRC
@@ -431,9 +431,9 @@ void slp_module_init(void)
 	}
 
 	spm_output_sleep_option();
-	pr_info("[SLP] SLEEP_DPIDLE_EN:%d, REPLACE_DEF_WAKESRC:%d",
+	pr_debug("[SLP] SLEEP_DPIDLE_EN:%d, REPLACE_DEF_WAKESRC:%d",
 		SLP_SLEEP_DPIDLE_EN, SLP_REPLACE_DEF_WAKESRC);
-	pr_info(", SUSPEND_LOG_EN:%d\n", SLP_SUSPEND_LOG_EN);
+	pr_debug(", SUSPEND_LOG_EN:%d\n", SLP_SUSPEND_LOG_EN);
 	suspend_set_ops(&slp_suspend_ops);
 #if SLP_SUSPEND_LOG_EN
 	console_suspend_enabled = 0;
diff --git a/drivers/misc/mediatek/base/power/spm/common/mtk_spm_resource_req.c b/drivers/misc/mediatek/base/power/spm/common/mtk_spm_resource_req.c
index cd2991429..5e8282c7c 100644
--- a/drivers/misc/mediatek/base/power/spm/common/mtk_spm_resource_req.c
+++ b/drivers/misc/mediatek/base/power/spm/common/mtk_spm_resource_req.c
@@ -259,12 +259,12 @@ void spm_resource_req_dump(void)
 	int i;
 	unsigned long flags;
 
-	printk_deferred("[name:spm&]resource_req:\n");
+	pr_debug("[name:spm&]resource_req:\n");
 
 	spin_lock_irqsave(&spm_resource_desc_update_lock, flags);
 
 	for (i = 0; i < NF_SPM_RESOURCE; i++)
-		printk_deferred("[name:spm&][%s]: 0x%x, 0x%x, mask = 0x%x, 0x%x\n",
+		pr_debug("[name:spm&][%s]: 0x%x, 0x%x, mask = 0x%x, 0x%x\n",
 				spm_resource_name[i],
 				resc_desc[i].user_usage[0],
 				resc_desc[i].user_usage[1],
@@ -281,7 +281,7 @@ void spm_resource_req_block_dump(void)
 	spin_lock_irqsave(&spm_resource_desc_update_lock, flags);
 
 	if (curr_res_usage == SPM_RESOURCE_ALL) {
-		printk_deferred("[name:spm&][resource_req_block] user: 0x%x, 0x%x\n",
+		pr_debug("[name:spm&][resource_req_block] user: 0x%x, 0x%x\n",
 				resc_desc[0].user_usage[0],
 				resc_desc[0].user_usage[1]);
 	}
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_idle_cond_check.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_idle_cond_check.c
index 6d22cfc7a..52fdf7a63 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_idle_cond_check.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_idle_cond_check.c
@@ -882,13 +882,13 @@ void mtk_suspend_cond_info(void)
 	for (j = 0; j < IDLE_MODEL_NUM; j++) {
 		for (i = 0; i < NR_CG_GRPS; i++) {
 			if (idle_block_mask[j][i] && !need_log) {
-				printk_deferred("[name:spm&][%s]\n",
+				pr_debug("[name:spm&][%s]\n",
 				mtk_resource_level_id_string[j]);
 				need_log = true;
 			}
 
 			if (idle_block_mask[j][i]) {
-				printk_deferred("[name:spm&][%02d %s] 0x%08x\n",
+				pr_debug("[name:spm&][%02d %s] 0x%08x\n",
 				i,
 				idle_cg_info[i].name,
 				idle_block_mask[j][i]);
@@ -896,10 +896,10 @@ void mtk_suspend_cond_info(void)
 			}
 		}
 		if (idle_pll_block_mask[j] && !need_log)
-			printk_deferred("[name:spm&][%s]\n",
+			pr_debug("[name:spm&][%s]\n",
 			mtk_resource_level_id_string[j]);
 		if (idle_pll_block_mask[j]) {
-			printk_deferred("[name:spm&]idle_pll_block_mask: 0x%08x\n",
+			pr_debug("[name:spm&]idle_pll_block_mask: 0x%08x\n",
 				idle_pll_block_mask[j]);
 			/* WARN_ON(1); */
 		}
@@ -1159,12 +1159,12 @@ static int get_base_from_node(
 
 	node = of_find_compatible_node(NULL, NULL, cmp);
 	if (!node)
-		printk_deferred("[name:spm&][IDLE] node '%s' not found!\n",
+		pr_debug("[name:spm&][IDLE] node '%s' not found!\n",
 			cmp);
 
 	*pbase = of_iomap(node, idx);
 	if (!(*pbase))
-		printk_deferred("[name:spm&][IDLE] node '%s' cannot iomap!\n",
+		pr_debug("[name:spm&][IDLE] node '%s' cannot iomap!\n",
 			cmp);
 
 	return 0;
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm.c
index 6bef9614a..7c89b2edc 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm.c
@@ -48,21 +48,21 @@ DEFINE_SPINLOCK(__spm_lock);
 void __attribute__ ((weak)) mtk_idle_cond_check_init(void)
 {
 	aee_sram_printk("NO %s !!!\n", __func__);
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 /* Note: implemented in mtk_spm_vcorefs.c */
 void  __attribute__ ((weak)) spm_vcorefs_init(void)
 {
 	aee_sram_printk("NO %s !!!\n", __func__);
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 /* Note: implemented in mtk_spm_dram.c */
 int __attribute__ ((weak)) spm_get_spmfw_idx(void)
 {
 	aee_sram_printk("NO %s !!!\n", __func__);
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 	return 0;
 }
 
@@ -70,7 +70,7 @@ int __attribute__ ((weak)) spm_get_spmfw_idx(void)
 int __attribute__ ((weak)) mtk_spm_irq_register(unsigned int spmirq0)
 {
 	aee_sram_printk("NO %s !!!\n", __func__);
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 	return 0;
 }
 
@@ -81,14 +81,14 @@ int __attribute__ ((weak)) mtk_cpuidle_init(void) { return -EOPNOTSUPP; }
 void __attribute__((weak)) spm_do_dram_config_check(void)
 {
 	aee_sram_printk("NO %s !!!\n", __func__);
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 /* Note: implemented in mtk_spm_fs.c */
 int __attribute__((weak)) spm_fs_init(void)
 {
 	aee_sram_printk("NO %s !!!\n", __func__);
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 	return 0;
 }
 
@@ -156,25 +156,25 @@ static void spm_register_init(unsigned int *spm_irq_0_ptr)
 
 	node = of_find_compatible_node(NULL, NULL, "mediatek,sleep");
 	if (!node)
-		printk_deferred("[name:spm&][SPM] find sleep node failed\n");
+		pr_debug("[name:spm&][SPM] find sleep node failed\n");
 
 	spm_base = of_iomap(node, 0);
 	if (!spm_base)
-		printk_deferred("[name:spm&][SPM] base spm_base failed\n");
+		pr_debug("[name:spm&][SPM] base spm_base failed\n");
 	spmirq0 = irq_of_parse_and_map(node, 0);
 	if (!spmirq0)
-		printk_deferred("[name:spm&][SPM] get spm_irq_0 failed\n");
+		pr_debug("[name:spm&][SPM] get spm_irq_0 failed\n");
 	*spm_irq_0_ptr = spmirq0;
 
 	node = of_find_compatible_node(NULL, NULL, "mediatek,sleep_reg_md");
 	if (!node)
-		printk_deferred("[name:spm&][SPM] find sleep_reg_md node failed\n");
+		pr_debug("[name:spm&][SPM] find sleep_reg_md node failed\n");
 
 	sleep_reg_md_base = of_iomap(node, 0);
 	if (!sleep_reg_md_base)
-		printk_deferred("[name:spm&][SPM] base sleep_reg_md_base failed\n");
+		pr_debug("[name:spm&][SPM] base sleep_reg_md_base failed\n");
 
-	printk_deferred("[name:spm&][SPM] spm_base = %p, sleep_reg_md_base = %p, spm_irq_0 = %d\n",
+	pr_debug("[name:spm&][SPM] spm_base = %p, sleep_reg_md_base = %p, spm_irq_0 = %d\n",
 		spm_base, sleep_reg_md_base, spmirq0);
 }
 
@@ -261,12 +261,12 @@ static int spm_pm_event(struct notifier_block *notifier, unsigned long pm_event,
 		ret = spm_to_sspm_command(SPM_SUSPEND_PREPARE, &spm_d);
 		spin_unlock_irqrestore(&__spm_lock, flags);
 		if (ret < 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) PM_SUSPEND_PREPARE return %d!!!\n",
+			pr_debug("[name:spm&]#@# %s(%d) PM_SUSPEND_PREPARE return %d!!!\n",
 				__func__, __LINE__, ret);
 			return NOTIFY_BAD;
 		}
 #endif
-		printk_deferred(
+		pr_debug(
 		"[name:spm&][SPM] PM: suspend entry %d-%02d-%02d %02d:%02d:%02d.%09lu UTC\n",
 			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
 			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
@@ -279,13 +279,13 @@ static int spm_pm_event(struct notifier_block *notifier, unsigned long pm_event,
 		ret = spm_to_sspm_command(SPM_POST_SUSPEND, &spm_d);
 		spin_unlock_irqrestore(&__spm_lock, flags);
 		if (ret < 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) PM_POST_SUSPEND return %d!!!\n",
+			pr_debug("[name:spm&]#@# %s(%d) PM_POST_SUSPEND return %d!!!\n",
 				__func__, __LINE__, ret);
 			return NOTIFY_BAD;
 		}
 
 #endif
-		printk_deferred(
+		pr_debug(
 		"[name:spm&][SPM] PM: suspend exit %d-%02d-%02d %02d:%02d:%02d.%09lu UTC\n",
 			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
 			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_dram.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_dram.c
index 093893c08..c6f57726d 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_dram.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_dram.c
@@ -120,11 +120,11 @@ static int spm_dram_golden_setting_cmp(bool en)
 					ddrphy_setting[i].offset);
 		if ((value & ddrphy_setting[i].mask) !=
 				ddrphy_setting[i].value) {
-			printk_deferred(
+			pr_debug(
 				"[name:spm&][SPM] NO dramc mismatch addr: 0x%.2x, offset: 0x%.3x, ",
 				ddrphy_setting[i].base,
 				ddrphy_setting[i].offset);
-			printk_deferred(
+			pr_debug(
 				"[name:spm&]mask: 0x%.8x, val: 0x%x, read: 0x%x\n",
 				ddrphy_setting[i].mask,
 				ddrphy_setting[i].value,
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_fs.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_fs.c
index c1eb11082..f9913184f 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_fs.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_fs.c
@@ -1058,7 +1058,7 @@ static ssize_t store_pwr_ctrl(int id, struct pwr_ctrl *pwrctrl,
 	if (sscanf(buf, "%63s %x", cmd, &val) != 2)
 		return -EPERM;
 
-	printk_deferred("[name:spm&] pwr_ctrl: cmd = %s, val = 0x%x\n",
+	pr_debug("[name:spm&] pwr_ctrl: cmd = %s, val = 0x%x\n",
 		cmd, val);
 
 
@@ -2130,7 +2130,7 @@ int spm_fs_init(void)
 	/* create /sys/power/spm/xxx */
 	r = mtk_idle_sysfs_power_create_group(&spm_attr_group);
 	if (r)
-		printk_deferred("[name:spm&][SPM] FAILED TO CREATE /sys/power/spm (%d)\n",
+		pr_debug("[name:spm&][SPM] FAILED TO CREATE /sys/power/spm (%d)\n",
 			r);
 
 	return r;
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_idle.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_idle.c
index a664799fc..e95e2cbe5 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_idle.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_idle.c
@@ -196,7 +196,7 @@ int mtk_idle_trigger_wfi(int idle_type, unsigned int idle_flag, int cpu)
 	print_ftrace_tag(idle_type, cpu, 0);
 
 	if (spm_dormant_sta < 0)
-		printk_deferred("[name:spm&]mtk_enter_idle_state(%d) ret %d\n",
+		pr_debug("[name:spm&]mtk_enter_idle_state(%d) ret %d\n",
 			cpuidle_mode[idle_type], spm_dormant_sta);
 
 	return spm_dormant_sta;
@@ -368,7 +368,7 @@ static unsigned int mtk_idle_output_log(
 	}
 
 	if (print_log) {
-		printk_deferred("[name:spm&]Power/swap op_cond = 0x%x\n"
+		pr_debug("[name:spm&]Power/swap op_cond = 0x%x\n"
 			, op_cond);
 		wr = __spm_output_wake_reason(
 			wakesta, false, mtk_idle_name(idle_type));
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_internal.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_internal.c
index b0f539fcf..3eadc201c 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_internal.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_internal.c
@@ -272,22 +272,22 @@ unsigned int __spm_output_wake_reason(
 		/* add size check for vcoredvfs */
 		aee_sram_printk("SPM ABORT (%s), r13 = 0x%x, ",
 			scenario, wakesta->r13);
-		printk_deferred("[name:spm&][SPM] ABORT (%s), r13 = 0x%x, ",
+		pr_debug("[name:spm&][SPM] ABORT (%s), r13 = 0x%x, ",
 			scenario, wakesta->r13);
 
 		aee_sram_printk(" debug_flag = 0x%x 0x%x\n",
 			wakesta->debug_flag, wakesta->debug_flag1);
-		printk_deferred("[name:spm&][SPM] debug_flag = 0x%x 0x%x\n",
+		pr_debug("[name:spm&][SPM] debug_flag = 0x%x 0x%x\n",
 			wakesta->debug_flag, wakesta->debug_flag1);
 
 		aee_sram_printk(" sw_flag = 0x%x 0x%x\n",
 			wakesta->sw_flag0, wakesta->sw_flag1);
-		printk_deferred("[name:spm&][SPM] sw_flag = 0x%x 0x%x\n",
+		pr_debug("[name:spm&][SPM] sw_flag = 0x%x 0x%x\n",
 			wakesta->sw_flag0, wakesta->sw_flag1);
 
 		aee_sram_printk(" b_sw_flag = 0x%x 0x%x\n",
 			wakesta->b_sw_flag0, wakesta->b_sw_flag1);
-		printk_deferred("[name:spm&][SPM] b_sw_flag = 0x%x 0x%x\n",
+		pr_debug("[name:spm&][SPM] b_sw_flag = 0x%x 0x%x\n",
 			wakesta->b_sw_flag0, wakesta->b_sw_flag1);
 
 		wr =  WR_ABORT;
@@ -443,10 +443,10 @@ unsigned int __spm_output_wake_reason(
 	WARN_ON(log_size >= 1024);
 
 	if (!suspend)
-		printk_deferred("[name:spm&][SPM] %s", log_buf);
+		pr_debug("[name:spm&][SPM] %s", log_buf);
 	else {
 		aee_sram_printk("%s", log_buf);
-		printk_deferred("[name:spm&][SPM] %s", log_buf);
+		pr_debug("[name:spm&][SPM] %s", log_buf);
 	}
 
 #ifdef CONFIG_LPM_STATE_RECORDS
@@ -475,7 +475,7 @@ void spm_set_dummy_read_addr(int debug)
 int __attribute__ ((weak)) get_dynamic_period(
 	int first_use, int first_wakeup_time, int battery_capacity_level)
 {
-	/* printk_deferred("[name:spm&]NO %s !!!\n", __func__); */
+	/* pr_debug("[name:spm&]NO %s !!!\n", __func__); */
 	return 5401;
 }
 
@@ -488,13 +488,13 @@ u32 __spm_get_wake_period(int pwake_time, unsigned int last_wr)
 		period = get_dynamic_period(last_wr != WR_PCM_TIMER
 				? 1 : 0, SPM_WAKE_PERIOD, 1);
 		if (period <= 0) {
-			printk_deferred("[name:spm&][SPM] CANNOT GET PERIOD FROM FUEL GAUGE\n");
+			pr_debug("[name:spm&][SPM] CANNOT GET PERIOD FROM FUEL GAUGE\n");
 			period = SPM_WAKE_PERIOD;
 		}
 	} else {
 		period = pwake_time;
 		aee_sram_printk("pwake = %d\n", pwake_time);
-		printk_deferred("[name:spm&][SPM] pwake = %d\n", pwake_time);
+		pr_debug("[name:spm&][SPM] pwake = %d\n", pwake_time);
 	}
 
 	if (period > 36 * 3600)	/* max period is 36.4 hours */
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_irq.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_irq.c
index e8ef27513..0144d1178 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_irq.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_irq.c
@@ -46,27 +46,27 @@ char __attribute__((weak)) *spm_vcorefs_dump_dvfs_regs(char *p)
 
 void __attribute__((weak)) mt_cirq_clone_gic(void)
 {
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 void __attribute__((weak)) mt_cirq_enable(void)
 {
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 void __attribute__((weak)) mt_cirq_flush(void)
 {
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 void __attribute__((weak)) mt_cirq_disable(void)
 {
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 }
 
 void __attribute__((weak)) set_wakeup_sources(u32 *list, u32 num_events)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 
 /***************************************************
@@ -85,11 +85,11 @@ static void mtk_spm_get_edge_trigger_irq(void)
 	struct device_node *node;
 	unsigned int irq_type;
 
-	printk_deferred("[name:spm&][SPM] edge trigger irqs:\n");
+	pr_debug("[name:spm&][SPM] edge trigger irqs:\n");
 	for (i = 0; i < IRQ_NUMBER; i++) {
 		node = of_find_compatible_node(NULL, NULL, list[i].name);
 		if (!node) {
-			printk_deferred("[name:spm&][SPM] find '%s' node failed\n",
+			pr_debug("[name:spm&][SPM] find '%s' node failed\n",
 				list[i].name);
 			continue;
 		}
@@ -98,7 +98,7 @@ static void mtk_spm_get_edge_trigger_irq(void)
 			irq_of_parse_and_map(node, list[i].order);
 
 		if (!edge_trig_irqs[i]) {
-			printk_deferred("[name:spm&][SPM] get '%s' failed\n",
+			pr_debug("[name:spm&][SPM] get '%s' failed\n",
 				list[i].name);
 			continue;
 		}
@@ -107,7 +107,7 @@ static void mtk_spm_get_edge_trigger_irq(void)
 		irq_type = irq_get_trigger_type(edge_trig_irqs[i]);
 		irq_set_irq_type(edge_trig_irqs[i], irq_type);
 
-		printk_deferred("[name:spm&][SPM] '%s', irq=%d, type=%d\n",
+		pr_debug("[name:spm&][SPM] '%s', irq=%d, type=%d\n",
 			 list[i].name,	edge_trig_irqs[i], irq_type);
 	}
 }
@@ -225,7 +225,7 @@ static irqreturn_t spm_irq0_handler(int irq, void *dev_id)
 
 	spin_unlock_irqrestore(&__spm_lock, flags);
 	if (isr & (ISRS_SW_INT1)) {
-		printk_deferred("[name:spm&][SPM] IRQ0 (ISRS_SW_INT1) HANDLER SHOULD NOT BE EXECUTED (0x%x)\n",
+		pr_debug("[name:spm&][SPM] IRQ0 (ISRS_SW_INT1) HANDLER SHOULD NOT BE EXECUTED (0x%x)\n",
 			isr);
 		#if !defined(CONFIG_FPGA_EARLY_PORTING)
 		spm_vcorefs_dump_dvfs_regs(NULL);
@@ -238,7 +238,7 @@ static irqreturn_t spm_irq0_handler(int irq, void *dev_id)
 		twam_handler(&twamsig, &twam_sel);
 
 	if (isr & (ISRS_SW_INT0 | ISRS_PCM_RETURN))
-		printk_deferred("[name:spm&][SPM] IRQ0 HANDLER SHOULD NOT BE EXECUTED (0x%x)\n",
+		pr_debug("[name:spm&][SPM] IRQ0 HANDLER SHOULD NOT BE EXECUTED (0x%x)\n",
 			isr);
 
 	return IRQ_HANDLED;
@@ -264,7 +264,7 @@ int mtk_spm_irq_register(unsigned int spmirq0)
 				IRQF_PERCPU,
 				"SPM", NULL);
 			if (err) {
-				printk_deferred("[name:spm&][SPM] FAILED TO REQUEST IRQ%d (%d)\n",
+				pr_debug("[name:spm&][SPM] FAILED TO REQUEST IRQ%d (%d)\n",
 					i, err);
 				r = -EPERM;
 			}
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_power.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_power.c
index 8a50ec222..b80aaf912 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_power.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_power.c
@@ -57,7 +57,7 @@ void mtk_idle_power_pre_process(int idle_type, unsigned int op_cond)
 
 	ret = spm_to_sspm_command_async(cmd, &spm_d);
 	if (ret < 0)
-		printk_deferred("[name:spm&]%s: ret %d", __func__, ret);
+		pr_debug("[name:spm&]%s: ret %d", __func__, ret);
 }
 
 void mtk_idle_power_pre_process_async_wait(int idle_type, unsigned int op_cond)
@@ -72,7 +72,7 @@ void mtk_idle_power_pre_process_async_wait(int idle_type, unsigned int op_cond)
 
 	ret = spm_to_sspm_command_async_wait(cmd);
 	if (ret < 0)
-		printk_deferred("[name:spm&]%s: ret %d", __func__, ret);
+		pr_debug("[name:spm&]%s: ret %d", __func__, ret);
 }
 
 void mtk_idle_power_post_process(int idle_type, unsigned int op_cond)
@@ -108,7 +108,7 @@ void mtk_idle_power_post_process(int idle_type, unsigned int op_cond)
 
 	ret = spm_to_sspm_command_async(cmd, &spm_d);
 	if (ret < 0)
-		printk_deferred("[name:spm&]%s: ret %d", __func__, ret);
+		pr_debug("[name:spm&]%s: ret %d", __func__, ret);
 }
 
 void mtk_idle_power_post_process_async_wait(int idle_type, unsigned int op_cond)
@@ -123,6 +123,6 @@ void mtk_idle_power_post_process_async_wait(int idle_type, unsigned int op_cond)
 
 	ret = spm_to_sspm_command_async_wait(cmd);
 	if (ret < 0)
-		printk_deferred("[name:spm&]%s: ret %d", __func__, ret);
+		pr_debug("[name:spm&]%s: ret %d", __func__, ret);
 }
 
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend.c
index cda79a7eb..f30470eae 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend.c
@@ -60,33 +60,33 @@ u64 md_slp_duration;
 
 int __attribute__ ((weak)) mtk_enter_idle_state(int idx)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return -1;
 }
 
 int __attribute__ ((weak)) vcorefs_get_curr_ddr(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return -1;
 }
 
 int  __attribute__ ((weak)) vcorefs_get_curr_vcore(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return -1;
 }
 
 #if defined(CONFIG_MTK_WATCHDOG) && defined(CONFIG_MTK_WD_KICKER)
 int  __attribute__ ((weak)) get_wd_api(struct wd_api **obj)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return -1;
 }
 #endif
 
 void __attribute__ ((weak)) mtk8250_backup_dev(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 
 static u32 suspend_pcm_flags = {
@@ -153,7 +153,7 @@ static void spm_trigger_wfi_for_sleep(struct pwr_ctrl *pwrctrl)
 
 	if (spm_dormant_sta < 0) {
 		aee_sram_printk("spm_dormant_sta %d", spm_dormant_sta);
-		printk_deferred("[name:spm&][SPM] spm_dormant_sta %d"
+		pr_debug("[name:spm&][SPM] spm_dormant_sta %d"
 			, spm_dormant_sta);
 	}
 }
@@ -236,16 +236,16 @@ static unsigned int spm_output_wake_reason(unsigned int ex_flag,
 
 	aee_sram_printk("dormant = %d, sleep_count = %d\n",
 		spm_dormant_sta, spm_sleep_count);
-	printk_deferred("[name:spm&][SPM] dormant = %d, sleep_count = %d\n",
+	pr_debug("[name:spm&][SPM] dormant = %d, sleep_count = %d\n",
 		spm_dormant_sta, spm_sleep_count);
 	if (spm_ap_mdsrc_req_cnt != 0) {
 		aee_sram_printk("warning: spm_ap_mdsrc_req_cnt = %d, ",
 			spm_ap_mdsrc_req_cnt);
-		printk_deferred("[name:spm&][SPM ]warning: spm_ap_mdsrc_req_cnt = %d, ",
+		pr_debug("[name:spm&][SPM ]warning: spm_ap_mdsrc_req_cnt = %d, ",
 			spm_ap_mdsrc_req_cnt);
 	}
 
-	printk_deferred("[name:spm&][SPM] Suspended for %d.%03d seconds",
+	pr_debug("[name:spm&][SPM] Suspended for %d.%03d seconds",
 		PCM_TICK_TO_SEC(wakesta->timer_out),
 		PCM_TICK_TO_SEC((wakesta->timer_out % PCM_32K_TICKS_PER_SEC)
 		* 1000));
@@ -323,7 +323,7 @@ bool spm_get_is_infra_pdn(void)
 /* extern int get_dlpt_imix_spm(void); */
 int __attribute__((weak)) get_dlpt_imix_spm(void)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return 0;
 }
 #endif
@@ -380,7 +380,7 @@ unsigned int spm_go_to_sleep_ex(unsigned int ex_flag)
 		wd_api->wd_spmwdt_mode_config(WD_REQ_EN, WD_REQ_RST_MODE);
 		wd_api->wd_suspend_notify();
 	} else
-		printk_deferred("[name:spm&]FAILED TO GET WD API\n");
+		pr_debug("[name:spm&]FAILED TO GET WD API\n");
 #endif
 
 	spin_lock_irqsave(&__spm_lock, flags);
@@ -390,7 +390,7 @@ unsigned int spm_go_to_sleep_ex(unsigned int ex_flag)
 	aee_sram_printk("sec = %u, wakesrc = 0x%x (%u)(%u)\n",
 		  sec, pwrctrl->wake_src, is_cpu_pdn(pwrctrl->pcm_flags),
 		  is_infra_pdn(pwrctrl->pcm_flags));
-	printk_deferred("[name:spm&][SPM] sec = %u, wakesrc = 0x%x (%u)(%u)\n",
+	pr_debug("[name:spm&][SPM] sec = %u, wakesrc = 0x%x (%u)(%u)\n",
 		  sec, pwrctrl->wake_src, is_cpu_pdn(pwrctrl->pcm_flags),
 		  is_infra_pdn(pwrctrl->pcm_flags));
 
@@ -403,7 +403,7 @@ unsigned int spm_go_to_sleep_ex(unsigned int ex_flag)
 		app_last_sleep_time =
 			(u64)_golden_read_reg(WORLD_CLK_CNTCV_H) << 32
 			| _golden_read_reg(WORLD_CLK_CNTCV_L);
-		printk_deferred(
+		pr_debug(
 			"[name:spm&][SPM] Awaked for %lld.%03lld seconds",
 			WORLD_CLK_TICK_TO_SEC((app_last_sleep_time
 				- app_last_wakeup_time)),
@@ -417,7 +417,7 @@ unsigned int spm_go_to_sleep_ex(unsigned int ex_flag)
 #if !defined(CONFIG_FPGA_EARLY_PORTING)
 	if (mtk8250_request_to_sleep()) {
 		last_wr = WR_UART_BUSY;
-		printk_deferred("[name:spm&]Fail to request uart sleep\n");
+		pr_debug("[name:spm&]Fail to request uart sleep\n");
 		goto RESTORE_IRQ;
 	}
 #endif
@@ -456,7 +456,7 @@ RESTORE_IRQ:
 
 	if (slp_dump_subsys_sleep_duration &&
 		spm_wakesta.timer_out >= PCM_32K_TICKS_FIVE_SEC)
-		printk_deferred("[name:spm&][SPM] md_slp_duration = %llu",
+		pr_debug("[name:spm&][SPM] md_slp_duration = %llu",
 			get_md_slp_duration() - md_slp_duration);
 
 	spin_unlock_irqrestore(&__spm_lock, flags);
@@ -479,7 +479,7 @@ RESTORE_IRQ:
 	if (pwrctrl->wakelock_timer_val) {
 		aee_sram_printk("#@# %s(%d) calling spm_pm_stay_awake()\n",
 			__func__, __LINE__);
-		printk_deferred("[name:spm&][SPM ]#@# %s(%d) calling spm_pm_stay_awake()\n",
+		pr_debug("[name:spm&][SPM ]#@# %s(%d) calling spm_pm_stay_awake()\n",
 			__func__, __LINE__);
 		spm_pm_stay_awake(pwrctrl->wakelock_timer_val);
 	}
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend_process.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend_process.c
index f55b82c28..48fc42537 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend_process.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_suspend_process.c
@@ -37,7 +37,7 @@ __attribute__ ((weak))
 unsigned int pmic_read_interface_nolock(unsigned int RegNum, unsigned int *val,
 	unsigned int MASK, unsigned int SHIFT)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return 0;
 }
 
@@ -45,27 +45,27 @@ __attribute__ ((weak))
 unsigned int pmic_config_interface(unsigned int RegNum, unsigned int val,
 	unsigned int MASK, unsigned int SHIFT)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return 0;
 }
 __attribute__ ((weak))
 unsigned int pmic_config_interface_nolock(unsigned int RegNum, unsigned int val,
 	unsigned int MASK, unsigned int SHIFT)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 	return 0;
 }
 
 __attribute__ ((weak))
 void mt_power_gs_t_dump_suspend(int count, ...)
 {
-	printk_deferred("[name:spm&]NO %s !!!\n", __func__);
+	pr_debug("[name:spm&]NO %s !!!\n", __func__);
 }
 
 __attribute__ ((weak))
 unsigned int _golden_read_reg(unsigned int addr)
 {
-	printk_deferred("[name:spm&][SPM] NO %s !!!\n", __func__);
+	pr_debug("[name:spm&][SPM] NO %s !!!\n", __func__);
 	return 0;
 }
 
@@ -78,7 +78,7 @@ void spm_dump_world_clk_cntcv(void)
 	wlk_cntcv_l = _golden_read_reg(WORLD_CLK_CNTCV_L);
 	wlk_cntcv_h = _golden_read_reg(WORLD_CLK_CNTCV_H);
 
-	printk_deferred("[name:spm&][SPM] wlk_cntcv_l = 0x%x, wlk_cntcv_h = 0x%x\n",
+	pr_debug("[name:spm&][SPM] wlk_cntcv_l = 0x%x, wlk_cntcv_h = 0x%x\n",
 		wlk_cntcv_l, wlk_cntcv_h);
 }
 
@@ -92,7 +92,7 @@ void spm_set_sysclk_settle(void)
 	/* md_settle is keyword for suspend status */
 	aee_sram_printk("md_settle = %u, settle = %u\n",
 		SPM_SYSCLK_SETTLE, settle);
-	printk_deferred("[name:spm&][SPM] md_settle = %u, settle = %u\n",
+	pr_debug("[name:spm&][SPM] md_settle = %u, settle = %u\n",
 		SPM_SYSCLK_SETTLE, settle);
 }
 
@@ -109,7 +109,7 @@ static void spm_dump_pmic_reg(void)
 		ret = pmic_read_interface_nolock(pmic_reg[i], &val, 0xffff, 0);
 		aee_sram_printk("#@# %s(%d) pmic reg(0x%x) = 0x%x\n",
 			__func__, __LINE__, pmic_reg[i], val);
-		printk_deferred("[name:spm&][SPM] #@# %s(%d) pmic reg(0x%x) = 0x%x\n",
+		pr_debug("[name:spm&][SPM] #@# %s(%d) pmic reg(0x%x) = 0x%x\n",
 			__func__, __LINE__, pmic_reg[i], val);
 	}
 #endif /* CONFIG_MTK_PMIC_NEW_ARCH */
@@ -143,7 +143,7 @@ void spm_suspend_pre_process(int cmd, struct pwr_ctrl *pwrctrl)
 	ret = spm_to_sspm_command(cmd, &spm_d);
 	if (ret < 0) {
 		aee_sram_printk("ret %d", ret);
-		printk_deferred("[name:spm&][SPM] ret %d", ret);
+		pr_debug("[name:spm&][SPM] ret %d", ret);
 	}
 #endif /* CONFIG_MTK_TINYSYS_SSPM_SUPPORT */
 
@@ -176,7 +176,7 @@ void spm_suspend_post_process(int cmd, struct pwr_ctrl *pwrctrl)
 	ret = spm_to_sspm_command(cmd, &spm_d);
 	if (ret < 0) {
 		aee_sram_printk("ret %d", ret);
-		printk_deferred("[name:spm&][SPM] ret %d", ret);
+		pr_debug("[name:spm&][SPM] ret %d", ret);
 	}
 #endif /* CONFIG_MTK_TINYSYS_SSPM_SUPPORT */
 }
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_twam.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_twam.c
index 7053cdfc2..5e6d78eec 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_twam.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_twam.c
@@ -130,7 +130,7 @@ void spm_twam_enable_monitor(bool en_monitor,
 
 	spin_unlock_irqrestore(&__spm_lock, flags);
 
-	printk_deferred("[name:spm&][SPM] enable TWAM for signal %u, %u, %u, %u (%u)\n",
+	pr_debug("[name:spm&][SPM] enable TWAM for signal %u, %u, %u, %u (%u)\n",
 		  twamcfg.byte[0].id, twamcfg.byte[1].id, twamcfg.byte[2].id,
 		  twamcfg.byte[3].id, twam_speed_mode);
 }
@@ -147,7 +147,7 @@ void spm_twam_disable_monitor(void)
 	spm_write(SPM_IRQ_STA, ISRC_TWAM);
 	spin_unlock_irqrestore(&__spm_lock, flags);
 
-	printk_deferred("[name:spm&]disable TWAM\n");
+	pr_debug("[name:spm&]disable TWAM\n");
 }
 EXPORT_SYMBOL(spm_twam_disable_monitor);
 
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_utils.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_utils.c
index 55695b5d2..782b89a74 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_utils.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_spm_utils.c
@@ -30,7 +30,7 @@ void __attribute__ ((weak))
 __iomem *get_smem_start_addr(int md_id, enum SMEM_USER_ID user_id,
 	int *size_o)
 {
-	printk_deferred("[name:spm&][SPM] %s not ready\n", __func__);
+	pr_debug("[name:spm&][SPM] %s not ready\n", __func__);
 	return 0;
 }
 
@@ -85,9 +85,9 @@ static void check_ap_mdsrc_ack(void)
 		if (i++ < 10) {
 			mdelay(1);
 		} else {
-			printk_deferred("[name:spm&][SPM] WARNING: MD SLEEP = %d\n",
+			pr_debug("[name:spm&][SPM] WARNING: MD SLEEP = %d\n",
 				md_sleep);
-			printk_deferred("[name:spm&][SPM] %s CAN NOT polling AP_MD1SRC_ACK\n",
+			pr_debug("[name:spm&][SPM] %s CAN NOT polling AP_MD1SRC_ACK\n",
 				__func__);
 			break;
 		}
@@ -102,7 +102,7 @@ void spm_ap_mdsrc_req(u8 set)
 		spin_lock_irqsave(&__spm_lock, flags);
 
 		if (spm_ap_mdsrc_req_cnt < 0) {
-			printk_deferred(
+			pr_debug(
 				"[name:spm&][SPM] warning: set = %d, spm_ap_mdsrc_req_cnt = %d\n",
 				set, spm_ap_mdsrc_req_cnt);
 			spin_unlock_irqrestore(&__spm_lock, flags);
@@ -121,7 +121,7 @@ void spm_ap_mdsrc_req(u8 set)
 		spm_ap_mdsrc_req_cnt--;
 
 		if (spm_ap_mdsrc_req_cnt < 0) {
-			printk_deferred(
+			pr_debug(
 				"[name:spm&][SPM] ]warning: set = %d spm_ap_mdsrc_req_cnt = %d\n",
 				set, spm_ap_mdsrc_req_cnt);
 		} else {
@@ -577,7 +577,7 @@ ssize_t set_network_traffic(char *ToUserBuf
 
 void spm_output_sleep_option(void)
 {
-	printk_deferred("[name:spm&][SPM] PWAKE_EN:%d, PCMWDT_EN:%d, BYPASS_SYSPWREQ:%d\n",
+	pr_debug("[name:spm&][SPM] PWAKE_EN:%d, PCMWDT_EN:%d, BYPASS_SYSPWREQ:%d\n",
 		   SPM_PWAKE_EN, SPM_PCMWDT_EN, SPM_BYPASS_SYSPWREQ);
 }
 EXPORT_SYMBOL(spm_output_sleep_option);
diff --git a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_sspm.c b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_sspm.c
index 27c714d69..76381c1b8 100644
--- a/drivers/misc/mediatek/base/power/spm/mt6785/mtk_sspm.c
+++ b/drivers/misc/mediatek/base/power/spm/mt6785/mtk_sspm.c
@@ -39,11 +39,11 @@ int spm_to_sspm_command_async(u32 cmd, struct spm_data *spm_d)
 		ret = sspm_ipi_send_async(
 			IPI_ID_SPM_SUSPEND, IPI_OPT_DEFAUT, spm_d, SPM_D_LEN);
 		if (ret != 0)
-			printk_deferred("[name:spm&]#@# %s(%d) sspm_ipi_send_async(cmd:0x%x) ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) sspm_ipi_send_async(cmd:0x%x) ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		break;
 	default:
-		printk_deferred("[name:spm&]#@# %s(%d) cmd(%d) wrong!!!\n",
+		pr_debug("[name:spm&]#@# %s(%d) cmd(%d) wrong!!!\n",
 			__func__, __LINE__, cmd);
 		break;
 	}
@@ -66,16 +66,16 @@ int spm_to_sspm_command_async_wait(u32 cmd)
 		ret = sspm_ipi_send_async_wait(
 			IPI_ID_SPM_SUSPEND, IPI_OPT_DEFAUT, &ack_data);
 		if (ret != 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) sspm_ipi_send_async_wait(cmd:0x%x) ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) sspm_ipi_send_async_wait(cmd:0x%x) ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			printk_deferred("[name:spm&]#@# %s(%d) cmd(%d) return %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd(%d) return %d\n",
 				__func__, __LINE__, cmd, ret);
 		}
 		break;
 	default:
-		printk_deferred("[name:spm&]#@# %s(%d) cmd(%d) wrong!!!\n",
+		pr_debug("[name:spm&]#@# %s(%d) cmd(%d) wrong!!!\n",
 			__func__, __LINE__, cmd);
 		break;
 	}
@@ -103,11 +103,11 @@ int spm_to_sspm_command(u32 cmd, struct spm_data *spm_d)
 			IPI_ID_SPM_SUSPEND, IPI_OPT_POLLING, spm_d, SPM_D_LEN,
 				&ack_data, 1);
 		if (ret != 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		}
 		break;
@@ -117,11 +117,11 @@ int spm_to_sspm_command(u32 cmd, struct spm_data *spm_d)
 			IPI_ID_SPM_SUSPEND, IPI_OPT_POLLING, spm_d, SPM_D_LEN,
 				&ack_data, 1);
 		if (ret != 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		}
 		break;
@@ -132,11 +132,11 @@ int spm_to_sspm_command(u32 cmd, struct spm_data *spm_d)
 			IPI_ID_SPM_SUSPEND, IPI_OPT_POLLING, spm_d, SPM_D_LEN,
 				&ack_data, 1);
 		if (ret != 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		}
 		break;
@@ -147,11 +147,11 @@ int spm_to_sspm_command(u32 cmd, struct spm_data *spm_d)
 			IPI_ID_SPM_SUSPEND, IPI_OPT_POLLING, spm_d, SPM_D_LEN,
 				&ack_data, 1);
 		if (ret != 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		}
 		break;
@@ -163,16 +163,16 @@ int spm_to_sspm_command(u32 cmd, struct spm_data *spm_d)
 			IPI_ID_SPM_SUSPEND, IPI_OPT_POLLING, spm_d, SPM_D_LEN,
 				&ack_data, 1);
 		if (ret != 0) {
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		} else if (ack_data < 0) {
 			ret = ack_data;
-			printk_deferred("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
+			pr_debug("[name:spm&]#@# %s(%d) cmd:0x%x ret %d\n",
 				__func__, __LINE__, cmd, ret);
 		}
 		break;
 	default:
-		printk_deferred("[name:spm&]#@# %s(%d) cmd(%d) wrong!!!\n",
+		pr_debug("[name:spm&]#@# %s(%d) cmd(%d) wrong!!!\n",
 			__func__, __LINE__, cmd);
 		break;
 	}
diff --git a/drivers/misc/mediatek/blocktag/Kconfig b/drivers/misc/mediatek/blocktag/Kconfig
index e342d7c49..e50645f09 100644
--- a/drivers/misc/mediatek/blocktag/Kconfig
+++ b/drivers/misc/mediatek/blocktag/Kconfig
@@ -10,7 +10,7 @@ config MTK_BLOCK_TAG
 	depends on MEDIATEK_SOLUTION
 	depends on (MTK_GMO_RAM_OPTIMIZE && MTK_ENG_BUILD) || \
 		   !MTK_GMO_RAM_OPTIMIZE
-	default y
+	default n
 	help
 	  Enable block tagging at block driver, tag requester pid to
 	  the accessing pages. This allows MMC/UFS Block IO log to obtian
diff --git a/drivers/misc/mediatek/cameraisp/dip/isp_50/camera_dip.c b/drivers/misc/mediatek/cameraisp/dip/isp_50/camera_dip.c
index 923a34512..d5368d5bb 100644
--- a/drivers/misc/mediatek/cameraisp/dip/isp_50/camera_dip.c
+++ b/drivers/misc/mediatek/cameraisp/dip/isp_50/camera_dip.c
@@ -145,7 +145,7 @@ pr_debug(MyTag "[%s] " format, __func__, ##args)
 #define DIP_DEBUG
 #ifdef DIP_DEBUG
 #define LOG_DBG(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_debug(MyTag "[%s] " format, __func__, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
@@ -155,9 +155,9 @@ pr_info(MyTag "[%s] " format, __func__, ##args)
 #define LOG_NOTICE(format, args...) \
 pr_notice(MyTag "[%s] " format, __func__, ##args)
 #define LOG_WRN(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_warn(MyTag "[%s] " format, __func__, ##args)
 #define LOG_ERR(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_err(MyTag "[%s] " format, __func__, ##args)
 #define LOG_AST(format, args...) \
 pr_debug(MyTag "[%s] " format, __func__, ##args)
 
diff --git a/drivers/misc/mediatek/cameraisp/dpe/isp_50/camera_dpe.c b/drivers/misc/mediatek/cameraisp/dpe/isp_50/camera_dpe.c
index 5cac542bc..ec32feb06 100644
--- a/drivers/misc/mediatek/cameraisp/dpe/isp_50/camera_dpe.c
+++ b/drivers/misc/mediatek/cameraisp/dpe/isp_50/camera_dpe.c
@@ -142,7 +142,7 @@ struct DPE_CLK_STRUCT dpe_clk;
 #define LOG_VRB(format,	args...)    pr_debug(MyTag format, ##args)
 
 #ifdef DPE_DEBUG_USE
-#define LOG_DBG(format, args...)    pr_info(MyTag format, ##args)
+#define LOG_DBG(format, args...)    pr_debug(MyTag format, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
diff --git a/drivers/misc/mediatek/cameraisp/dpe/isp_60/camera_dpe.c b/drivers/misc/mediatek/cameraisp/dpe/isp_60/camera_dpe.c
index 07a5b679e..ba654562a 100644
--- a/drivers/misc/mediatek/cameraisp/dpe/isp_60/camera_dpe.c
+++ b/drivers/misc/mediatek/cameraisp/dpe/isp_60/camera_dpe.c
@@ -165,16 +165,16 @@ struct DPE_CLK_STRUCT dpe_clk;
 
 //#define DPE_DEBUG_USE
 #ifdef DPE_DEBUG_USE
-#define LOG_DBG(format, args...) pr_info(MyTag format, ##args)
+#define LOG_DBG(format, args...) pr_debug(MyTag format, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
 
 #define LOG_INF(format, args...) pr_info(MyTag format, ##args)
 #define LOG_NOTICE(format, args...) pr_notice(MyTag format, ##args)
-#define LOG_WRN(format, args...) pr_info(MyTag format, ##args)
-#define LOG_ERR(format, args...) pr_info(MyTag format, ##args)
-#define LOG_AST(format, args...) pr_info(MyTag format, ##args)
+#define LOG_WRN(format, args...) pr_warn(MyTag format, ##args)
+#define LOG_ERR(format, args...) pr_err(MyTag format, ##args)
+#define LOG_AST(format, args...) pr_debug(MyTag format, ##args)
 
 /**************************************************************
  *
diff --git a/drivers/misc/mediatek/cameraisp/dpe/isp_60/engine_request.c b/drivers/misc/mediatek/cameraisp/dpe/isp_60/engine_request.c
index 8d5f0031b..770e8ce59 100644
--- a/drivers/misc/mediatek/cameraisp/dpe/isp_60/engine_request.c
+++ b/drivers/misc/mediatek/cameraisp/dpe/isp_60/engine_request.c
@@ -38,7 +38,7 @@ MODULE_PARM_DESC(dpe_egn_debug, " activates debug info");
 #define LOG_DBG(format, args...)				 \
 	do {							 \
 		if (dpe_egn_debug >= 2)				 \
-			pr_info(MyTag "[%s] " format, __func__, ##args); \
+			pr_debug(MyTag "[%s] " format, __func__, ##args); \
 	} while (0)
 
 #define LOG_INF(format, args...)				 \
@@ -50,13 +50,13 @@ MODULE_PARM_DESC(dpe_egn_debug, " activates debug info");
 #define LOG_WRN(format, args...)				 \
 	do {							 \
 		if (dpe_egn_debug >= 0)				 \
-			pr_info(MyTag "[%s] " format, __func__, ##args); \
+			pr_warn(MyTag "[%s] " format, __func__, ##args); \
 	} while (0)
 
 #define LOG_ERR(format, args...)				 \
 	do {							 \
 		if (dpe_egn_debug >= 0)				 \
-			pr_info(MyTag "[%s] " format, __func__, ##args); \
+			pr_err(MyTag "[%s] " format, __func__, ##args); \
 	} while (0)
 
 
diff --git a/drivers/misc/mediatek/cameraisp/fdvt/3.5/camera_fdvt.c b/drivers/misc/mediatek/cameraisp/fdvt/3.5/camera_fdvt.c
index 9555f349a..f059d0291 100644
--- a/drivers/misc/mediatek/cameraisp/fdvt/3.5/camera_fdvt.c
+++ b/drivers/misc/mediatek/cameraisp/fdvt/3.5/camera_fdvt.c
@@ -79,11 +79,11 @@ pr_debug("FDVT [%s] " format, __func__, ##args)
 #define log_inf(format, args...) \
 pr_info("FDVT [%s] " format, __func__, ##args)
 #define log_wrn(format, args...) \
-pr_info("FDVT [%s] WARNING: " format, __func__, ##args)
+pr_warn("FDVT [%s] WARNING: " format, __func__, ##args)
 #define log_err(format, args...) \
-pr_info("FDVT [%s, line%04d] ERROR: " format, __func__, __LINE__, ##args)
+pr_err("FDVT [%s, line%04d] ERROR: " format, __func__, __LINE__, ##args)
 #define log_ast(format, args...) \
-pr_info("FDVT [%s, line%04d] ASSERT: " format, __func__, __LINE__, ##args)
+pr_debug("FDVT [%s, line%04d] ASSERT: " format, __func__, __LINE__, ##args)
 
 
 #define LDVT_EARLY_PORTING_NO_CCF 0
diff --git a/drivers/misc/mediatek/cameraisp/fdvt/4.0/camera_fdvt.c b/drivers/misc/mediatek/cameraisp/fdvt/4.0/camera_fdvt.c
index 544739bbe..bc9cf524b 100644
--- a/drivers/misc/mediatek/cameraisp/fdvt/4.0/camera_fdvt.c
+++ b/drivers/misc/mediatek/cameraisp/fdvt/4.0/camera_fdvt.c
@@ -84,11 +84,11 @@ pr_debug("FDVT [%s] " format, __func__, ##args)
 #define LOG_INF(format, args...) \
 pr_info("FDVT [%s] " format, __func__, ##args)
 #define LOG_WRN(format, args...) \
-pr_info("FDVT [%s] WARNING: " format, __func__, ##args)
+pr_warn("FDVT [%s] WARNING: " format, __func__, ##args)
 #define LOG_ERR(format, args...) \
-pr_info("FDVT [%s, line%04d] ERROR: " format, __func__, __LINE__, ##args)
+pr_err("FDVT [%s, line%04d] ERROR: " format, __func__, __LINE__, ##args)
 #define LOG_AST(format, args...) \
-pr_info("FDVT [%s, line%04d] ASSERT: " format, __func__, __LINE__, ##args)
+pr_debug("FDVT [%s, line%04d] ASSERT: " format, __func__, __LINE__, ##args)
 
 #define LDVT_EARLY_PORTING_NO_CCF 0
 #if LDVT_EARLY_PORTING_NO_CCF
diff --git a/drivers/misc/mediatek/cameraisp/fdvt/5.0/camera_fdvt.c b/drivers/misc/mediatek/cameraisp/fdvt/5.0/camera_fdvt.c
index ab21f64d2..bb5f7399b 100644
--- a/drivers/misc/mediatek/cameraisp/fdvt/5.0/camera_fdvt.c
+++ b/drivers/misc/mediatek/cameraisp/fdvt/5.0/camera_fdvt.c
@@ -166,7 +166,7 @@ pr_debug(MyTag "[%s] " format, __func__, ##args)
 
 #ifdef FDVT_DEBUG_USE
 #define log_dbg(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_debug(MyTag "[%s] " format, __func__, ##args)
 #else
 #define log_dbg(format, args...)
 #endif
@@ -176,9 +176,9 @@ pr_info(MyTag "[%s] " format, __func__, ##args)
 #define log_notice(format, args...) \
 pr_notice(MyTag "[%s] " format, __func__, ##args)
 #define log_wrn(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_warn(MyTag "[%s] " format, __func__, ##args)
 #define log_err(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_err(MyTag "[%s] " format, __func__, ##args)
 #define log_ast(format, args...) \
 pr_debug(MyTag "[%s] " format, __func__, ##args)
 
@@ -3848,7 +3848,7 @@ enum m4u_callback_ret_t FDVT_M4U_TranslationFault_callback(int port,
 #endif
 {
 
-	pr_info("[FDVT_M4U]fault call port=%d, mva=0x%x", port, mva);
+	pr_debug("[FDVT_M4U]fault call port=%d, mva=0x%x", port, mva);
 
 	switch (port) {
 	case M4U_PORT_FDVT_RDA:
@@ -3856,17 +3856,17 @@ enum m4u_callback_ret_t FDVT_M4U_TranslationFault_callback(int port,
 	case M4U_PORT_FDVT_WRA:
 	case M4U_PORT_FDVT_WRB:
 	default:  //ISP_FDVT_BASE = 0x1b001000
-		pr_info("FDVT_IN_BASE_ADR_0:0x%08x, FDVT_IN_BASE_ADR_1:0x%08x, FDVT_IN_BASE_ADR_2:0x%08x, FDVT_IN_BASE_ADR_3:0x%08x\n",
+		pr_debug("FDVT_IN_BASE_ADR_0:0x%08x, FDVT_IN_BASE_ADR_1:0x%08x, FDVT_IN_BASE_ADR_2:0x%08x, FDVT_IN_BASE_ADR_3:0x%08x\n",
 			FDVT_RD32(FDVT_IN_BASE_ADR_0_REG),
 			FDVT_RD32(FDVT_IN_BASE_ADR_1_REG),
 			FDVT_RD32(FDVT_IN_BASE_ADR_2_REG),
 			FDVT_RD32(FDVT_IN_BASE_ADR_3_REG));
-		pr_info("FDVT_OUT_BASE_ADR_0:0x%08x, FDVT_OUT_BASE_ADR_1:0x%08x, FDVT_OUT_BASE_ADR_2:0x%08x, FDVT_OUT_BASE_ADR_3:0x%08x\n",
+		pr_debug("FDVT_OUT_BASE_ADR_0:0x%08x, FDVT_OUT_BASE_ADR_1:0x%08x, FDVT_OUT_BASE_ADR_2:0x%08x, FDVT_OUT_BASE_ADR_3:0x%08x\n",
 			FDVT_RD32(FDVT_OUT_BASE_ADR_0_REG),
 			FDVT_RD32(FDVT_OUT_BASE_ADR_1_REG),
 			FDVT_RD32(FDVT_OUT_BASE_ADR_2_REG),
 			FDVT_RD32(FDVT_OUT_BASE_ADR_3_REG));
-		pr_info("FDVT_KERNEL_BASE_ADR_0:0x%08x, FDVT_KERNEL_BASE_ADR_1:0x%08x\n",
+		pr_debug("FDVT_KERNEL_BASE_ADR_0:0x%08x, FDVT_KERNEL_BASE_ADR_1:0x%08x\n",
 			FDVT_RD32(FDVT_KERNEL_BASE_ADR_0_REG),
 			FDVT_RD32(FDVT_KERNEL_BASE_ADR_1_REG));
 	break;
diff --git a/drivers/misc/mediatek/cameraisp/fdvt/5.1/camera_fdvt.c b/drivers/misc/mediatek/cameraisp/fdvt/5.1/camera_fdvt.c
index df7c276ed..ad6fcf15c 100644
--- a/drivers/misc/mediatek/cameraisp/fdvt/5.1/camera_fdvt.c
+++ b/drivers/misc/mediatek/cameraisp/fdvt/5.1/camera_fdvt.c
@@ -191,7 +191,7 @@ pr_debug(FDTAG "[%s] " format, __func__, ##args)
 
 #ifdef FDVT_DEBUG_USE
 #define log_dbg(format, args...) \
-pr_info(FDTAG "[%s] " format, __func__, ##args)
+pr_debug(FDTAG "[%s] " format, __func__, ##args)
 #else
 #define log_dbg(format, args...)
 #endif
@@ -201,9 +201,9 @@ pr_info(FDTAG "[%s] " format, __func__, ##args)
 #define log_notice(format, args...) \
 pr_notice(FDTAG "[%s] " format, __func__, ##args)
 #define log_wrn(format, args...) \
-pr_info(FDTAG "[%s] " format, __func__, ##args)
+pr_warn(FDTAG "[%s] " format, __func__, ##args)
 #define log_err(format, args...) \
-pr_info(FDTAG "[%s] " format, __func__, ##args)
+pr_err(FDTAG "[%s] " format, __func__, ##args)
 #define log_ast(format, args...) \
 pr_debug(FDTAG "[%s] " format, __func__, ##args)
 
@@ -3602,7 +3602,7 @@ enum m4u_callback_ret_t FDVT_M4U_TranslationFault_callback(int port,
 							   void *data)
 #endif
 {
-	pr_info("[FDVT_M4U]fault call port=%d, mva=0x%x", port, mva);
+	pr_debug("[FDVT_M4U]fault call port=%d, mva=0x%x", port, mva);
 
 	switch (port) {
 #if 0
@@ -3612,17 +3612,17 @@ enum m4u_callback_ret_t FDVT_M4U_TranslationFault_callback(int port,
 	case M4U_PORT_FDVT_WRB:
 #endif
 	default: //ISP_FDVT_BASE = 0x1b001000
-		pr_info("FDVT_IN_BASE_ADR_0:0x%08x, FDVT_IN_BASE_ADR_1:0x%08x, FDVT_IN_BASE_ADR_2:0x%08x, FDVT_IN_BASE_ADR_3:0x%08x\n",
+		pr_debug("FDVT_IN_BASE_ADR_0:0x%08x, FDVT_IN_BASE_ADR_1:0x%08x, FDVT_IN_BASE_ADR_2:0x%08x, FDVT_IN_BASE_ADR_3:0x%08x\n",
 			FDVT_RD32(FDVT_IN_BASE_ADR_0_REG),
 			FDVT_RD32(FDVT_IN_BASE_ADR_1_REG),
 			FDVT_RD32(FDVT_IN_BASE_ADR_2_REG),
 			FDVT_RD32(FDVT_IN_BASE_ADR_3_REG));
-		pr_info("FDVT_OUT_BASE_ADR_0:0x%08x, FDVT_OUT_BASE_ADR_1:0x%08x, FDVT_OUT_BASE_ADR_2:0x%08x, FDVT_OUT_BASE_ADR_3:0x%08x\n",
+		pr_debug("FDVT_OUT_BASE_ADR_0:0x%08x, FDVT_OUT_BASE_ADR_1:0x%08x, FDVT_OUT_BASE_ADR_2:0x%08x, FDVT_OUT_BASE_ADR_3:0x%08x\n",
 			FDVT_RD32(FDVT_OUT_BASE_ADR_0_REG),
 			FDVT_RD32(FDVT_OUT_BASE_ADR_1_REG),
 			FDVT_RD32(FDVT_OUT_BASE_ADR_2_REG),
 			FDVT_RD32(FDVT_OUT_BASE_ADR_3_REG));
-		pr_info("FDVT_KERNEL_BASE_ADR_0:0x%08x, FDVT_KERNEL_BASE_ADR_1:0x%08x\n",
+		pr_debug("FDVT_KERNEL_BASE_ADR_0:0x%08x, FDVT_KERNEL_BASE_ADR_1:0x%08x\n",
 			FDVT_RD32(FDVT_KERNEL_BASE_ADR_0_REG),
 			FDVT_RD32(FDVT_KERNEL_BASE_ADR_1_REG));
 	break;
diff --git a/drivers/misc/mediatek/cameraisp/fdvt/Makefile b/drivers/misc/mediatek/cameraisp/fdvt/Makefile
index b3025df63..f365a3f57 100644
--- a/drivers/misc/mediatek/cameraisp/fdvt/Makefile
+++ b/drivers/misc/mediatek/cameraisp/fdvt/Makefile
@@ -24,7 +24,7 @@ MTKCAM_FDVT_PATH := $(MTK_CUSTOM_PATH)/cameraisp/fdvt/4.0
 subdir-ccflags-y += -I$(MTK_CUSTOM_PATH)/cameraisp/fdvt/4.0/inc
 obj-y += 4.0/
 else ifneq (, $(findstring $(FDVT_CURRENT_PLATFORM), $(FDVT_50_PLATFORM)))
-$(info FDVT: Drv use 5.0 folder)
+#$(info FDVT: Drv use 5.0 folder)
 MTKCAM_FDVT_VERSION := 5.0
 MTKCAM_FDVT_PATH := $(MTK_CUSTOM_PATH)/cameraisp/fdvt/5.0
 subdir-ccflags-y += -I$(MTK_CUSTOM_PATH)/cameraisp/fdvt/5.0/inc
diff --git a/drivers/misc/mediatek/cameraisp/mfb/isp_50/camera_mfb.c b/drivers/misc/mediatek/cameraisp/mfb/isp_50/camera_mfb.c
index 99a7aa621..b85c2685b 100644
--- a/drivers/misc/mediatek/cameraisp/mfb/isp_50/camera_mfb.c
+++ b/drivers/misc/mediatek/cameraisp/mfb/isp_50/camera_mfb.c
@@ -155,7 +155,7 @@ struct MFB_CLK_STRUCT mfb_clk;
 #define log_vrb(format,	args...)    pr_debug(MyTag format, ##args)
 
 #ifdef MFB_DEBUG_USE
-#define log_dbg(format, args...)    pr_info(MyTag format, ##args)
+#define log_dbg(format, args...)    pr_debug(MyTag format, ##args)
 #else
 #define log_dbg(format, args...)
 #endif
diff --git a/drivers/misc/mediatek/cameraisp/owe/isp_50/camera_owe.c b/drivers/misc/mediatek/cameraisp/owe/isp_50/camera_owe.c
index 3ed7d7272..6fd4b49b2 100644
--- a/drivers/misc/mediatek/cameraisp/owe/isp_50/camera_owe.c
+++ b/drivers/misc/mediatek/cameraisp/owe/isp_50/camera_owe.c
@@ -130,16 +130,16 @@ struct OWE_CLK_STRUCT owe_clk;
 #define LOG_VRB(format,	args...)    pr_debug(MyTag format, ##args)
 
 #ifdef OWE_DEBUG_USE
-#define LOG_DBG(format, args...)    pr_info(MyTag format, ##args)
+#define LOG_DBG(format, args...)    pr_debug(MyTag format, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
 
 #define LOG_INF(format, args...)    pr_info(MyTag format,  ##args)
 #define LOG_NOTICE(format, args...) pr_notice(MyTag format,  ##args)
-#define LOG_WRN(format, args...)    pr_info(MyTag format,  ##args)
-#define LOG_ERR(format, args...)    pr_info(MyTag format,  ##args)
-#define LOG_AST(format, args...)    pr_info(MyTag format, ##args)
+#define LOG_WRN(format, args...)    pr_warn(MyTag format,  ##args)
+#define LOG_ERR(format, args...)    pr_err(MyTag format,  ##args)
+#define LOG_AST(format, args...)    pr_debug(MyTag format, ##args)
 
 
 /******************************************************************************
diff --git a/drivers/misc/mediatek/cameraisp/owe/mt6785/camera_owe.c b/drivers/misc/mediatek/cameraisp/owe/mt6785/camera_owe.c
index 77c13113b..2ad94ed68 100644
--- a/drivers/misc/mediatek/cameraisp/owe/mt6785/camera_owe.c
+++ b/drivers/misc/mediatek/cameraisp/owe/mt6785/camera_owe.c
@@ -130,16 +130,16 @@ struct OWE_CLK_STRUCT owe_clk;
 #define LOG_VRB(format,	args...)    pr_debug(MyTag format, ##args)
 
 #ifdef OWE_DEBUG_USE
-#define LOG_DBG(format, args...)    pr_info(MyTag format, ##args)
+#define LOG_DBG(format, args...)    pr_debug(MyTag format, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
 
 #define LOG_INF(format, args...)    pr_info(MyTag format,  ##args)
 #define LOG_NOTICE(format, args...) pr_notice(MyTag format,  ##args)
-#define LOG_WRN(format, args...)    pr_info(MyTag format,  ##args)
-#define LOG_ERR(format, args...)    pr_info(MyTag format,  ##args)
-#define LOG_AST(format, args...)    pr_info(MyTag format, ##args)
+#define LOG_WRN(format, args...)    pr_warn(MyTag format,  ##args)
+#define LOG_ERR(format, args...)    pr_err(MyTag format,  ##args)
+#define LOG_AST(format, args...)    pr_debug(MyTag format, ##args)
 
 
 /******************************************************************************
diff --git a/drivers/misc/mediatek/cameraisp/rsc/engine_request.c b/drivers/misc/mediatek/cameraisp/rsc/engine_request.c
index 5dd32309e..4f8066c3f 100644
--- a/drivers/misc/mediatek/cameraisp/rsc/engine_request.c
+++ b/drivers/misc/mediatek/cameraisp/rsc/engine_request.c
@@ -39,7 +39,7 @@ MODULE_PARM_DESC(egn_debug, " activates debug info");
 #define LOG_DBG(format, args...)				 \
 	do {							 \
 		if (egn_debug >= 2)				 \
-			pr_info(MyTag "[%s] " format, __func__, ##args); \
+			pr_debug(MyTag "[%s] " format, __func__, ##args); \
 	} while (0)
 
 #define LOG_INF(format, args...)				 \
@@ -51,13 +51,13 @@ MODULE_PARM_DESC(egn_debug, " activates debug info");
 #define LOG_WRN(format, args...)				 \
 	do {							 \
 		if (egn_debug >= 0)				 \
-			pr_info(MyTag "[%s] " format, __func__, ##args); \
+			pr_warn(MyTag "[%s] " format, __func__, ##args); \
 	} while (0)
 
 #define LOG_ERR(format, args...)				 \
 	do {							 \
 		if (egn_debug >= 0)				 \
-			pr_info(MyTag "[%s] " format, __func__, ##args); \
+			pr_err(MyTag "[%s] " format, __func__, ##args); \
 	} while (0)
 
 
diff --git a/drivers/misc/mediatek/cameraisp/rsc/isp_50/camera_rsc.c b/drivers/misc/mediatek/cameraisp/rsc/isp_50/camera_rsc.c
index ce4003e0d..d7561f52b 100644
--- a/drivers/misc/mediatek/cameraisp/rsc/isp_50/camera_rsc.c
+++ b/drivers/misc/mediatek/cameraisp/rsc/isp_50/camera_rsc.c
@@ -162,9 +162,9 @@ struct RSC_CLK_STRUCT rsc_clk;
 
 #define LOG_INF(format, args...) pr_info(MyTag format, ##args)
 #define LOG_NOTICE(format, args...) pr_notice(MyTag format, ##args)
-#define LOG_WRN(format, args...) pr_info(MyTag format, ##args)
-#define LOG_ERR(format, args...) pr_info(MyTag format, ##args)
-#define LOG_AST(format, args...) pr_info(MyTag format, ##args)
+#define LOG_WRN(format, args...) pr_warn(MyTag format, ##args)
+#define LOG_ERR(format, args...) pr_err(MyTag format, ##args)
+#define LOG_AST(format, args...) pr_debug(MyTag format, ##args)
 
 /*******************************************************************************
  *
diff --git a/drivers/misc/mediatek/cameraisp/rsc/mt6785/camera_rsc.c b/drivers/misc/mediatek/cameraisp/rsc/mt6785/camera_rsc.c
index 9087e420e..afc091ab7 100644
--- a/drivers/misc/mediatek/cameraisp/rsc/mt6785/camera_rsc.c
+++ b/drivers/misc/mediatek/cameraisp/rsc/mt6785/camera_rsc.c
@@ -163,9 +163,9 @@ struct RSC_CLK_STRUCT rsc_clk;
 
 #define LOG_INF(format, args...) pr_info(MyTag format, ##args)
 #define LOG_NOTICE(format, args...) pr_notice(MyTag format, ##args)
-#define LOG_WRN(format, args...) pr_info(MyTag format, ##args)
-#define LOG_ERR(format, args...) pr_info(MyTag format, ##args)
-#define LOG_AST(format, args...) pr_info(MyTag format, ##args)
+#define LOG_WRN(format, args...) pr_warn(MyTag format, ##args)
+#define LOG_ERR(format, args...) pr_err(MyTag format, ##args)
+#define LOG_AST(format, args...) pr_debug(MyTag format, ##args)
 
 /*******************************************************************************
  *
diff --git a/drivers/misc/mediatek/cameraisp/src/isp_50/camera_isp.c b/drivers/misc/mediatek/cameraisp/src/isp_50/camera_isp.c
index 178beea2b..163ebe722 100644
--- a/drivers/misc/mediatek/cameraisp/src/isp_50/camera_isp.c
+++ b/drivers/misc/mediatek/cameraisp/src/isp_50/camera_isp.c
@@ -146,7 +146,7 @@ static u32 target_clk;
 #define ISP_DEBUG
 #ifdef ISP_DEBUG
 #define LOG_DBG(format, args...) \
-		pr_info(MyTag "[%s] " format, __func__, ##args)
+		pr_debug(MyTag "[%s] " format, __func__, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
@@ -707,16 +707,16 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 			gSvLog[irq]._lastIrqTime.sec, gSvLog[irq]\
 			._lastIrqTime.usec,\
 			##__VA_ARGS__) < 0) {\
-			LOG_NOTICE("[Error] %s: snprintf failed", __func__);\
+			LOG_DBG("[Error] %s: snprintf failed", __func__);\
 		} \
 		if ('\0' != gSvLog[irq]._str[ppb][logT][str_leng - 1]) {\
-			LOG_NOTICE("log str over flow(%d)", irq);\
+			LOG_DBG("log str over flow(%d)", irq);\
 		} \
 		while (*ptr++ != '\0') {\
 			(*ptr2)++;\
 		}     \
 	} else { \
-		LOG_INF("(%d)(%d)log str avalible=0, print log\n", irq, logT);\
+		LOG_DBG("(%d)(%d)log str avalible=0, print log\n", irq, logT);\
 		ptr = pSrc->_str[ppb][logT];\
 		if (pSrc->_cnt[ppb][logT] != 0) {\
 			if (logT == _LOG_DBG) {\
@@ -755,17 +755,17 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 					    '\0') {\
 						ptr[NORMAL_STR_LEN*(i+1) - 1] =\
 						    '\0';\
-						LOG_NOTICE("%s",\
+						LOG_DBG("%s",\
 						    &ptr[NORMAL_STR_LEN*i]);\
 					} else{\
-						LOG_NOTICE("%s",\
+						LOG_DBG("%s",\
 						    &ptr[NORMAL_STR_LEN*i]);\
 						break;\
 					} \
 				} \
 			} \
 			else {\
-				LOG_NOTICE("N.S.%d", logT);\
+				LOG_DBG("N.S.%d", logT);\
 			} \
 			ptr[0] = '\0';\
 			pSrc->_cnt[ppb][logT] = 0;\
@@ -775,7 +775,7 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 			ptr2 = &(pSrc->_cnt[ppb][logT]);\
 			if (snprintf((char *)(pDes), avaLen,\
 					fmt, ##__VA_ARGS__) < 0) {\
-				LOG_NOTICE("[Error] %s: snprintf failed",\
+				LOG_DBG("[Error] %s: snprintf failed",\
 					   __func__);\
 			} \
 			while (*ptr++ != '\0') {\
@@ -831,17 +831,17 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 			for (i = 0; i < ERR_PAGE; i++) {\
 				if (ptr[NORMAL_STR_LEN*(i+1) - 1] != '\0') {\
 					ptr[NORMAL_STR_LEN*(i+1) - 1] = '\0';\
-					LOG_NOTICE("%s",\
+					LOG_DBG("%s",\
 					    &ptr[NORMAL_STR_LEN*i]);\
 				} else{\
-					LOG_NOTICE("%s",\
+					LOG_DBG("%s",\
 					    &ptr[NORMAL_STR_LEN*i]);\
 					break;\
 				} \
 			} \
 		} \
 		else {\
-			LOG_NOTICE("N.S.%d", logT);\
+			LOG_DBG("N.S.%d", logT);\
 		} \
 		ptr[0] = '\0';\
 		pSrc->_cnt[ppb][logT] = 0;\
@@ -906,7 +906,7 @@ int MET_Event_Get_BPP(enum _isp_dma_enum_ dmao, unsigned int reg_module)
 			ret = 14;
 			break;
 		default:
-			LOG_NOTICE("get imgo bpp error fmt_sel:0x%x value=%x\n",
+			LOG_DBG("get imgo bpp error fmt_sel:0x%x value=%x\n",
 				fmt_sel, (fmt_sel >> 4) & 0x1F);
 			break;
 		}
@@ -922,7 +922,7 @@ int MET_Event_Get_BPP(enum _isp_dma_enum_ dmao, unsigned int reg_module)
 			ret = 12;
 			break;
 		default:
-			LOG_NOTICE("get rrzo bpp error fmt_sel:0x%x value=%x\n",
+			LOG_DBG("get rrzo bpp error fmt_sel:0x%x value=%x\n",
 				fmt_sel, (fmt_sel >> 2) & 0x3);
 			break;
 		}
@@ -1055,7 +1055,7 @@ static void ISP_DumpDmaDeepDbg(enum ISP_IRQ_TYPE_ENUM module)
 		strncpy(cam, "CAM_C", sizeof("CAM_C"));
 		break;
 	default:
-		LOG_NOTICE("unsupported module:0x%x\n", module);
+		LOG_DBG("unsupported module:0x%x\n", module);
 		return;
 	}
 
@@ -1191,42 +1191,42 @@ static inline void Prepare_Enable_ccf_clock(void)
 	 */
 
 	#ifndef EP_MARK_SMI /* enable through smi API */
-	LOG_INF("enable CG/MTCMOS through SMI CLK API\n");
+	LOG_DBG("enable CG/MTCMOS through SMI CLK API\n");
 	smi_bus_prepare_enable(SMI_LARB6, ISP_DEV_NAME);
 	smi_bus_prepare_enable(SMI_LARB3, ISP_DEV_NAME);
 	#endif
 
 	ret = clk_prepare_enable(isp_clk.ISP_SCP_SYS_DIS);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_SCP_SYS_DIS clock\n");
+		LOG_DBG("cannot pre-en ISP_SCP_SYS_DIS clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_SCP_SYS_ISP);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_SCP_SYS_ISP clock\n");
+		LOG_DBG("cannot pre-en ISP_SCP_SYS_ISP clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_SCP_SYS_CAM);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_SCP_SYS_CAM clock\n");
+		LOG_DBG("cannot pre-en ISP_SCP_SYS_CAM clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSYS);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSYS clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSYS clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMTG);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMTG clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMTG clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSV0);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSV0 clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSV0 clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSV1);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSV1 clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSV1 clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSV2);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSV2 clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSV2 clock\n");
 
 }
 
@@ -1245,7 +1245,7 @@ static inline void Disable_Unprepare_ccf_clock(void)
 	clk_disable_unprepare(isp_clk.ISP_SCP_SYS_DIS);
 
 	#ifndef EP_MARK_SMI
-	LOG_INF("disable CG/MTCMOS through SMI CLK API\n");
+	LOG_DBG("disable CG/MTCMOS through SMI CLK API\n");
 	smi_bus_disable_unprepare(SMI_LARB6, ISP_DEV_NAME);
 	smi_bus_disable_unprepare(SMI_LARB3, ISP_DEV_NAME);
 	#endif
@@ -1264,7 +1264,7 @@ void ISP_Halt_Mask(unsigned int isphaltMask)
 
 	ISP_WR32(ISP_CAMSYS_CONFIG_BASE + 0x120, setReg);
 
-	LOG_INF("ISP halt_en for dvfs:0x%x\n",
+	LOG_DBG("ISP halt_en for dvfs:0x%x\n",
 		ISP_RD32(ISP_CAMSYS_CONFIG_BASE + 0x120));
 }
 EXPORT_SYMBOL(ISP_Halt_Mask);
@@ -1367,7 +1367,7 @@ static void ISP_EnableClock(bool En)
 		G_u4EnableClockCount++;
 		spin_unlock(&(IspInfo.SpinLockClock));
 #else/*CCF*/
-		/*LOG_INF("CCF:prepare_enable clk");*/
+		/*LOG_DBG("CCF:prepare_enable clk");*/
 		spin_lock(&(IspInfo.SpinLockClock));
 		G_u4EnableClockCount++;
 		spin_unlock(&(IspInfo.SpinLockClock));
@@ -1377,7 +1377,7 @@ static void ISP_EnableClock(bool En)
 		/* Disable CAMSYS_HALT1_EN: LSCI & BPCI*/
 		/* To avoid ISP halt keep arise */
 		#if 1/* ALSK TBD */
-		LOG_INF("# NEED UPDATE CAMSYS_HALT1_EN: LSCI & BPCI SETTING #");
+		LOG_DBG("# NEED UPDATE CAMSYS_HALT1_EN: LSCI & BPCI SETTING #");
 		#else
 		ISP_WR32(ISP_CAMSYS_CONFIG_BASE + 0x120, 0xFFFFFF4F);
 		#endif
@@ -1400,11 +1400,11 @@ static void ISP_EnableClock(bool En)
 		}
 		spin_unlock(&(IspInfo.SpinLockClock));
 #else
-		/*LOG_INF("CCF:disable_unprepare clk\n");*/
+		/*LOG_DBG("CCF:disable_unprepare clk\n");*/
 		spin_lock(&(IspInfo.SpinLockClock));
 		if (G_u4EnableClockCount == 0) {
 			spin_unlock(&(IspInfo.SpinLockClock));
-			LOG_INF(
+			LOG_DBG(
 			  "G_u4EnableClockCount aleady be 0, do nothing\n");
 			return;
 		}
@@ -1471,7 +1471,7 @@ static inline void ISP_Reset(int module)
 		ISP_WR32(CAM_UNI_REG_TOP_SW_CTL(module), 0x0);
 		break;
 	default:
-		LOG_NOTICE("Not support reset module:%d\n", module);
+		LOG_DBG("Not support reset module:%d\n", module);
 		break;
 	}
 }
@@ -1491,14 +1491,14 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 	struct ISP_REG_STRUCT *pData;
 
 	if (pRegIo == NULL) {
-		LOG_NOTICE("Error: NULL pRegIo\n");
+		LOG_DBG("Error: NULL pRegIo\n");
 		return -EFAULT;
 	}
 
 	pData = (struct ISP_REG_STRUCT *)pRegIo->pData;
 
 	if (pData == NULL) {
-		LOG_NOTICE("Error: NULL pData\n");
+		LOG_DBG("Error: NULL pData\n");
 		return -EFAULT;
 	}
 
@@ -1534,7 +1534,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 		regBase = ISP_CAM_UNI_BASE;
 		break;
 	default:
-		LOG_NOTICE("Unsupported module(%x) !!!\n", pData->module);
+		LOG_DBG("Unsupported module(%x) !!!\n", pData->module);
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1546,7 +1546,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 
 	for (i = 0; i < pRegIo->Count; i++) {
 		if (get_user(reg.Addr, (unsigned int *)&pData->Addr) != 0) {
-			LOG_NOTICE("get_user failed\n");
+			LOG_DBG("get_user failed\n");
 			Ret = -EFAULT;
 			goto EXIT;
 		}
@@ -1554,13 +1554,13 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 		if ((regBase + reg.Addr) < (regBase + ispRange)) {
 			reg.Val = ISP_RD32(regBase + reg.Addr);
 		} else {
-			LOG_NOTICE("Wrong address(0x%lx)\n",
+			LOG_DBG("Wrong address(0x%lx)\n",
 				(unsigned long)(regBase + reg.Addr));
 			reg.Val = 0;
 		}
 
 		if (put_user(reg.Val, (unsigned int *) &(pData->Val)) != 0) {
-			LOG_NOTICE("put_user failed\n");
+			LOG_DBG("put_user failed\n");
 			Ret = -EFAULT;
 			goto EXIT;
 		}
@@ -1629,7 +1629,7 @@ static int ISP_WriteRegToHw(
 		regBase = ISP_CAM_UNI_BASE;
 		break;
 	default:
-		LOG_NOTICE("Unsupported module(%x) !!!\n", pReg->module);
+		LOG_DBG("Unsupported module(%x) !!!\n", pReg->module);
 		return -EFAULT;
 	}
 
@@ -1655,7 +1655,7 @@ static int ISP_WriteRegToHw(
 		if (((regBase + pReg[i].Addr) < (regBase + ispRange)))
 			ISP_WR32(regBase + pReg[i].Addr, pReg[i].Val);
 		else
-			LOG_NOTICE("wrong address(0x%lx)\n",
+			LOG_DBG("wrong address(0x%lx)\n",
 			  (unsigned long)(regBase + pReg[i].Addr));
 
 	}
@@ -1673,7 +1673,7 @@ static int ISP_WriteReg(struct ISP_REG_IO_STRUCT *pRegIo)
 	struct ISP_REG_STRUCT *pData = NULL;
 
 	if (pRegIo->Count > 0xFFFFFFFF) {
-		LOG_NOTICE("pRegIo->Count error");
+		LOG_DBG("pRegIo->Count error");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1693,7 +1693,7 @@ static int ISP_WriteReg(struct ISP_REG_IO_STRUCT *pRegIo)
 	}
 
 	if ((void __user *)(pRegIo->pData) == NULL) {
-		LOG_NOTICE("NULL pData");
+		LOG_DBG("NULL pData");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1701,7 +1701,7 @@ static int ISP_WriteReg(struct ISP_REG_IO_STRUCT *pRegIo)
 	/*  */
 	if (copy_from_user(pData, (void __user *)(pRegIo->pData),
 		  pRegIo->Count * sizeof(struct ISP_REG_STRUCT)) != 0) {
-		LOG_NOTICE("copy_from_user failed\n");
+		LOG_DBG("copy_from_user failed\n");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1754,7 +1754,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 
 	/*  */
 	if ((void __user *)Param == NULL)  {
-		LOG_NOTICE("[rtbc]NULL Param");
+		LOG_DBG("[rtbc]NULL Param");
 		return -EFAULT;
 	}
 	/*  */
@@ -1762,13 +1762,13 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 		  sizeof(struct ISP_BUFFER_CTRL_STRUCT)) == 0) {
 		if (rt_buf_ctrl.module >= ISP_IRQ_TYPE_AMOUNT ||
 		    rt_buf_ctrl.module < 0) {
-			LOG_NOTICE("[rtbc]not supported module:0x%x\n",
+			LOG_DBG("[rtbc]not supported module:0x%x\n",
 			  rt_buf_ctrl.module);
 			return -EFAULT;
 		}
 
 		if (pstRTBuf[rt_buf_ctrl.module] == NULL)  {
-			LOG_NOTICE("[rtbc]NULL pstRTBuf, module:0x%x\n",
+			LOG_DBG("[rtbc]NULL pstRTBuf, module:0x%x\n",
 			  rt_buf_ctrl.module);
 			return -EFAULT;
 		}
@@ -1776,7 +1776,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 		rt_dma = rt_buf_ctrl.buf_id;
 		if (rt_dma >= _cam_max_ ||
 		    rt_dma < 0) {
-			LOG_NOTICE("[rtbc]buf_id error:0x%x\n", rt_dma);
+			LOG_DBG("[rtbc]buf_id error:0x%x\n", rt_dma);
 			return -EFAULT;
 		}
 
@@ -1785,7 +1785,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 		case ISP_RT_BUF_CTRL_CLEAR:
 			/*  */
 			if (IspInfo.DebugMask & ISP_DBG_BUF_CTRL)
-				LOG_INF("[rtbc][%d][CLEAR]:rt_dma(%d)\n",
+				LOG_DBG("[rtbc][%d][CLEAR]:rt_dma(%d)\n",
 				  rt_buf_ctrl.module, rt_dma);
 			/*  */
 
@@ -1887,7 +1887,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 				pstRTBuf[rt_buf_ctrl.module]->state = 0;
 				break;
 			default:
-				LOG_NOTICE(
+				LOG_DBG(
 				  "unsupported module:0x%x\n",
 				  rt_buf_ctrl.module);
 				break;
@@ -1903,7 +1903,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 			unsigned char *pExt;
 
 			if (rt_buf_ctrl.pExtend == NULL) {
-				LOG_NOTICE("NULL pExtend");
+				LOG_DBG("NULL pExtend");
 				Ret = -EFAULT;
 				break;
 			}
@@ -1916,11 +1916,11 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 					  ->ring_buf[z].active = array[z];
 					if (IspInfo.DebugMask
 					  & ISP_DBG_BUF_CTRL)
-						LOG_INF(
+						LOG_DBG(
 						  "[rtbc][DMA_EN]:dma_%d:%d",
 						  z, array[z]);
 				} else {
-					LOG_NOTICE(
+					LOG_DBG(
 					  "[rtbc][DMA_EN]:get_user failed(%d)",
 					  z);
 					Ret = -EFAULT;
@@ -1936,7 +1936,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 
 		}
 	} else {
-		LOG_NOTICE("[rtbc]copy_from_user failed");
+		LOG_DBG("[rtbc]copy_from_user failed");
 		Ret = -EFAULT;
 	}
 
@@ -1965,14 +1965,14 @@ static int ISP_SetPMQOS(unsigned int cmd, unsigned int module)
 		break;
 	}
 	default:
-		LOG_NOTICE("unsupport cmd:%d", cmd);
+		LOG_DBG("unsupport cmd:%d", cmd);
 		Ret = -1;
 		break;
 	}
 	pm_qos_update_request(&camsys_qos_request[module], bw_cal);
 
 	if (PMQoS_BW_value != bw_cal) {
-		LOG_INF(
+		LOG_DBG(
 		"PM_QoS:module[%d],cmd[%d],bw[%d],fps[%d],total bw = %d MB/s\n",
 		module, cmd, G_PM_QOS[module].bw_sum,
 		G_PM_QOS[module].fps, bw_cal);
@@ -2028,7 +2028,7 @@ static int ISP_REGISTER_IRQ_USERKEY(char *userName)
 	}
 
 	spin_unlock((spinlock_t *)(&SpinLock_UserKey));
-	LOG_INF("User(%s)key(%d)\n", userName, key);
+	LOG_DBG("User(%s)key(%d)\n", userName, key);
 	return key;
 }
 
@@ -2040,26 +2040,26 @@ static int ISP_FLUSH_IRQ(struct ISP_WAIT_IRQ_STRUCT *irqinfo)
 	/* old: unsigned int flags;*//* FIX to avoid build warning */
 	unsigned long flags;
 
-	LOG_INF("type(%d)userKey(%d)St_type(%d)St(0x%x)",
+	LOG_DBG("type(%d)userKey(%d)St_type(%d)St(0x%x)",
 		irqinfo->Type, irqinfo->EventInfo.UserKey,
 		irqinfo->EventInfo.St_type, irqinfo->EventInfo.Status);
 
 	if (irqinfo->Type >= ISP_IRQ_TYPE_AMOUNT ||
 	    irqinfo->Type < 0) {
-		LOG_NOTICE("FLUSH_IRQ: type error(%d)", irqinfo->Type);
+		LOG_DBG("FLUSH_IRQ: type error(%d)", irqinfo->Type);
 		return -EFAULT;
 	}
 
 	if (irqinfo->EventInfo.St_type >= ISP_IRQ_ST_AMOUNT ||
 	    irqinfo->EventInfo.St_type < 0) {
-		LOG_NOTICE("FLUSH_IRQ: st_type error(%d)",
+		LOG_DBG("FLUSH_IRQ: st_type error(%d)",
 			irqinfo->EventInfo.St_type);
 		return -EFAULT;
 	}
 
 	if (irqinfo->EventInfo.UserKey >= IRQ_USER_NUM_MAX ||
 	    irqinfo->EventInfo.UserKey < 0) {
-		LOG_NOTICE("FLUSH_IRQ: userkey error(%d)",
+		LOG_DBG("FLUSH_IRQ: userkey error(%d)",
 			irqinfo->EventInfo.UserKey);
 		return -EFAULT;
 	}
@@ -2103,20 +2103,20 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 
 	if (WaitIrq->Type >= ISP_IRQ_TYPE_AMOUNT ||
 	    WaitIrq->Type < 0) {
-		LOG_NOTICE("WaitIrq: type error(%d)", WaitIrq->Type);
+		LOG_DBG("WaitIrq: type error(%d)", WaitIrq->Type);
 		return -EFAULT;
 	}
 
 	if (WaitIrq->EventInfo.St_type >= ISP_IRQ_ST_AMOUNT ||
 	    WaitIrq->EventInfo.St_type < 0) {
-		LOG_NOTICE("WaitIrq: st_type error(%d)",
+		LOG_DBG("WaitIrq: st_type error(%d)",
 			WaitIrq->EventInfo.St_type);
 		return -EFAULT;
 	}
 
 	if (WaitIrq->EventInfo.UserKey >= IRQ_USER_NUM_MAX ||
 	    WaitIrq->EventInfo.UserKey < 0) {
-		LOG_NOTICE("WaitIrq: userkey error(%d)",
+		LOG_DBG("WaitIrq: userkey error(%d)",
 			WaitIrq->EventInfo.UserKey);
 		return -EFAULT;
 	}
@@ -2246,7 +2246,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 		    WaitIrq->EventInfo.St_type][WaitIrq->EventInfo.UserKey] &
 		    WaitIrq->EventInfo.Status) {
 #ifdef ENABLE_WAITIRQ_LOG
-			LOG_INF("%s,%s",
+			LOG_DBG("%s,%s",
 			"Already have irq!!!: WaitIrq Timeout(%d) Clear(%d), Type(%d), StType(%d)",
 			", IrqStatus(0x%08X), WaitStatus(0x%08X), Timeout(%d), userKey(%d)\n",
 				WaitIrq->EventInfo.Timeout,
@@ -2263,7 +2263,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 	}
 
 #ifdef ENABLE_WAITIRQ_LOG
-	LOG_INF(
+	LOG_DBG(
 	    "before wait: Clear(%d) Type(%d) StType(%d) Sts(0x%08X) WaitSts(0x%08X) Timeout(%d) userKey(%d)\n",
 	    WaitIrq->EventInfo.Clear,
 	    WaitIrq->Type,
@@ -2308,7 +2308,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 		spin_unlock_irqrestore(
 			&(IspInfo.SpinLockIrq[WaitIrq->Type]), flags);
 
-		LOG_NOTICE(
+		LOG_DBG(
 			"ERRRR WaitIrq Clear(%d) Type(%d) StType(%d) Status(0x%08X) WaitStatus(0x%08X) Timeout(%d) key(%d)\n",
 			WaitIrq->EventInfo.Clear,
 			WaitIrq->Type,
@@ -2332,7 +2332,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 		spin_unlock_irqrestore(
 			&(IspInfo.SpinLockIrq[WaitIrq->Type]), flags);
 
-		LOG_INF(
+		LOG_DBG(
 		    "Done WaitIrq Clear(%d) Type(%d) StType(%d) Status(0x%08X) WaitStatus(0x%08X) Timeout(%d) key(%d)\n",
 		    WaitIrq->EventInfo.Clear,
 		    WaitIrq->Type,
@@ -2490,12 +2490,12 @@ static void ISP_ion_init(void)
 		pIon_client = ion_client_create(g_ion_device, "camera_isp");
 
 	if (!pIon_client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return;
 	}
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("create ion client 0x%p\n", pIon_client);
+		LOG_DBG("create ion client 0x%p\n", pIon_client);
 }
 
 /******************************************************************************
@@ -2504,12 +2504,12 @@ static void ISP_ion_init(void)
 static void ISP_ion_uninit(void)
 {
 	if (!pIon_client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return;
 	}
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("destroy ion client 0x%p\n", pIon_client);
+		LOG_DBG("destroy ion client 0x%p\n", pIon_client);
 
 	ion_client_destroy(pIon_client);
 
@@ -2525,23 +2525,23 @@ static struct ion_handle *ISP_ion_import_handle(
 	struct ion_handle *handle = NULL;
 
 	if (!client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return handle;
 	}
 	if (fd == -1) {
-		LOG_NOTICE("invalid ion fd!\n");
+		LOG_DBG("invalid ion fd!\n");
 		return handle;
 	}
 
 	handle = ion_import_dma_buf_fd(client, fd);
 
 	if (IS_ERR(handle)) {
-		LOG_NOTICE("import ion handle failed!\n");
+		LOG_DBG("import ion handle failed!\n");
 		return NULL;
 	}
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("[ion_import_hd] Hd(0x%p)\n", handle);
+		LOG_DBG("[ion_import_hd] Hd(0x%p)\n", handle);
 	return handle;
 }
 
@@ -2552,14 +2552,14 @@ static void ISP_ion_free_handle(
 	struct ion_client *client, struct ion_handle *handle)
 {
 	if (!client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return;
 	}
 	if (!handle)
 		return;
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("[ion_free_hd] Hd(0x%p)\n", handle);
+		LOG_DBG("[ion_free_hd] Hd(0x%p)\n", handle);
 
 	ion_free(client, handle);
 
@@ -2576,7 +2576,7 @@ static void ISP_ion_free_handle_by_module(unsigned int module)
 	struct T_ION_TBL *ptbl = &gION_TBL[module];
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("[ion_free_hd_by_module]%d\n", module);
+		LOG_DBG("[ion_free_hd_by_module]%d\n", module);
 
 	for (i = 0; i < _dma_max_wr_; i++) {
 		unsigned int jump = i*_ion_keep_max_;
@@ -2597,7 +2597,7 @@ static void ISP_ion_free_handle_by_module(unsigned int module)
 			spin_unlock(&(ptbl->pLock[i]));
 			/* */
 			if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-				LOG_INF(
+				LOG_DBG(
 				"ion_free:dev(%d)dma(%d)j(%d)fd(%d)Hnd(0x%p)\n",
 				module, i, j, nFd, p_IonHnd);
 			}
@@ -2641,7 +2641,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 	/*  */
 	if (pFile->private_data == NULL) {
-		LOG_NOTICE(
+		LOG_DBG(
 		  "private_data is NULL,(process, pid, tgid)=(%s, %d, %d)\n",
 		  current->comm, current->pid, current->tgid);
 		return -EFAULT;
@@ -2653,7 +2653,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	case ISP_WAKELOCK_CTRL:
 		if (copy_from_user(&wakelock_ctrl, (void *)Param,
 		    sizeof(unsigned int)) != 0) {
-			LOG_NOTICE(
+			LOG_DBG(
 			  "get ISP_WAKELOCK_CTRL from user fail\n");
 			Ret = -EFAULT;
 		} else {
@@ -2690,13 +2690,13 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	case ISP_GET_DROP_FRAME:
 		if (copy_from_user(&DebugFlag[0], (void *)Param,
 		    sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get irq from user fail\n");
+			LOG_DBG("get irq from user fail\n");
 			Ret = -EFAULT;
 		} else {
 
 			if (DebugFlag[0] < ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				DebugFlag[0] > ISP_IRQ_TYPE_INT_CAMSV_1_ST) {
-				LOG_NOTICE("err TG(0x%x)\n", DebugFlag[0]);
+				LOG_DBG("err TG(0x%x)\n", DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
 			}
@@ -2709,7 +2709,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			if (copy_to_user((void *)Param,
 				&DebugFlag[1], sizeof(unsigned int)) != 0) {
-				LOG_NOTICE("copy to user fail\n");
+				LOG_DBG("copy to user fail\n");
 				Ret = -EFAULT;
 			}
 		}
@@ -2717,7 +2717,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	case ISP_GET_INT_ERR:
 		if (copy_to_user((void *)Param, (void *)g_ISPIntStatus,
 		    sizeof(struct ISP_RAW_INT_STATUS)*ISP_IRQ_TYPE_AMOUNT) != 0)
-			LOG_NOTICE("get int err fail\n");
+			LOG_DBG("get int err fail\n");
 		else
 			memset((void *)g_ISPIntStatus,
 				0, sizeof(g_ISPIntStatus));
@@ -2726,30 +2726,30 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	case ISP_GET_DMA_ERR:
 		if (copy_from_user(&DebugFlag[0], (void *)Param,
 		    sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get module fail\n");
+			LOG_DBG("get module fail\n");
 			Ret = -EFAULT;
 		} else {
 			if (DebugFlag[0] >= (ISP_IRQ_TYPE_AMOUNT)) {
-				LOG_NOTICE("module error(%d)\n", DebugFlag[0]);
+				LOG_DBG("module error(%d)\n", DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
 			}
 			if (copy_to_user(
 				(void *)Param, &g_DmaErr_CAM[DebugFlag[0]],
 				sizeof(unsigned int)*_cam_max_) != 0)
-				LOG_NOTICE("get dma_err fail\n");
+				LOG_DBG("get dma_err fail\n");
 
 		}
 		break;
 	case ISP_GET_CUR_SOF:
 		if (copy_from_user(&DebugFlag[0], (void *)Param,
 		    sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get cur sof from user fail\n");
+			LOG_DBG("get cur sof from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			if (DebugFlag[0] < ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				DebugFlag[0] >= ISP_IRQ_TYPE_AMOUNT) {
-				LOG_NOTICE("cursof: error type(%d)\n"
+				LOG_DBG("cursof: error type(%d)\n"
 					, DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
@@ -2758,14 +2758,14 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		}
 		if (copy_to_user((void *)Param,
 		    &DebugFlag[1], sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("copy to user fail\n");
+			LOG_DBG("copy to user fail\n");
 			Ret = -EFAULT;
 		}
 		break;
 	case ISP_RESET_BY_HWMODULE: {
 		if (copy_from_user(&module, (void *)Param,
 		    sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get hwmodule from user fail\n");
+			LOG_DBG("get hwmodule from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			ISP_Reset(module);
@@ -2780,7 +2780,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			 */
 			Ret = ISP_ReadReg(&RegIo);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -2793,7 +2793,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			 */
 			Ret = ISP_WriteReg(&RegIo);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -2805,13 +2805,13 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			if ((IrqInfo.Type >= ISP_IRQ_TYPE_AMOUNT) ||
 				(IrqInfo.Type < 0)) {
 				Ret = -EFAULT;
-				LOG_NOTICE("invalid type(%d)\n", IrqInfo.Type);
+				LOG_DBG("invalid type(%d)\n", IrqInfo.Type);
 				goto EXIT;
 			}
 
 			if ((IrqInfo.EventInfo.St_type >= ISP_IRQ_ST_AMOUNT) ||
 				(IrqInfo.EventInfo.St_type < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "invalid St_type(%d), max(%d), force St_type = 0\n",
 				    IrqInfo.EventInfo.St_type,
 				    ISP_IRQ_ST_AMOUNT);
@@ -2820,14 +2820,14 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			if ((IrqInfo.EventInfo.UserKey >= IRQ_USER_NUM_MAX) ||
 				(IrqInfo.EventInfo.UserKey < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "invalid userKey(%d), max(%d), force userkey = 0\n",
 				    IrqInfo.EventInfo.UserKey,
 				    IRQ_USER_NUM_MAX);
 				IrqInfo.EventInfo.UserKey = 0;
 			}
 #ifdef ENABLE_WAITIRQ_LOG
-			LOG_INF(
+			LOG_DBG(
 			    "IRQ type(%d), userKey(%d), timeout(%d), userkey(%d), st_status(%d), status(%d)\n",
 			    IrqInfo.Type,
 			    IrqInfo.EventInfo.UserKey,
@@ -2838,7 +2838,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 #endif
 			Ret = ISP_WaitIrq(&IrqInfo);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -2851,13 +2851,13 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			if ((ClearIrq.Type >= ISP_IRQ_TYPE_AMOUNT) ||
 				(ClearIrq.Type < 0)) {
 				Ret = -EFAULT;
-				LOG_NOTICE("invalid type(%d)\n", ClearIrq.Type);
+				LOG_DBG("invalid type(%d)\n", ClearIrq.Type);
 				goto EXIT;
 			}
 
 			if ((ClearIrq.EventInfo.St_type >= ISP_IRQ_ST_AMOUNT) ||
 				(ClearIrq.EventInfo.St_type < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "invalid St_type(%d), max(%d), force St_type = 0\n",
 				    ClearIrq.EventInfo.St_type,
 				    ISP_IRQ_ST_AMOUNT);
@@ -2867,7 +2867,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			/*  */
 			if ((ClearIrq.EventInfo.UserKey >= IRQ_USER_NUM_MAX) ||
 				(ClearIrq.EventInfo.UserKey < 0)) {
-				LOG_NOTICE("errUserEnum(%d)",
+				LOG_DBG("errUserEnum(%d)",
 					ClearIrq.EventInfo.UserKey);
 				Ret = -EFAULT;
 				goto EXIT;
@@ -2892,7 +2892,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			spin_unlock_irqrestore(
 				&(IspInfo.SpinLockIrq[ClearIrq.Type]), flags);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -2906,14 +2906,14 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			RegUserKey.userKey = userKey;
 			if (copy_to_user((void *)Param, &RegUserKey,
 			    sizeof(struct ISP_REGISTER_USERKEY_STRUCT)) != 0)
-				LOG_NOTICE("copy_to_user failed\n");
+				LOG_DBG("copy_to_user failed\n");
 
 			if (RegUserKey.userKey < 0) {
-				LOG_NOTICE("query irq user key fail\n");
+				LOG_DBG("query irq user key fail\n");
 				Ret = -1;
 			}
 		} else {
-			LOG_NOTICE("copy from user fail\n");
+			LOG_DBG("copy from user fail\n");
 		}
 
 		break;
@@ -2923,7 +2923,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		    sizeof(struct ISP_WAIT_IRQ_STRUCT)) == 0) {
 			if ((IrqInfo.EventInfo.UserKey >= IRQ_USER_NUM_MAX) ||
 				(IrqInfo.EventInfo.UserKey < 0)) {
-				LOG_NOTICE("invalid userKey(%d), max(%d)\n",
+				LOG_DBG("invalid userKey(%d), max(%d)\n",
 					IrqInfo.EventInfo.UserKey,
 					IRQ_USER_NUM_MAX);
 				Ret = -EFAULT;
@@ -2931,7 +2931,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			if ((IrqInfo.Type >= ISP_IRQ_TYPE_AMOUNT) ||
 				(IrqInfo.Type < 0)) {
-				LOG_NOTICE("invalid type(%d), max(%d)\n",
+				LOG_DBG("invalid type(%d), max(%d)\n",
 					IrqInfo.Type,
 					ISP_IRQ_TYPE_AMOUNT);
 				Ret = -EFAULT;
@@ -2939,7 +2939,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			if ((IrqInfo.EventInfo.St_type >= ISP_IRQ_ST_AMOUNT) ||
 				(IrqInfo.EventInfo.St_type < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "invalid St_type(%d), max(%d), force St_type = 0\n",
 				    IrqInfo.EventInfo.St_type,
 				    ISP_IRQ_ST_AMOUNT);
@@ -2958,7 +2958,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			/* LOG_DBG("FBC kernel debug level = %x\n" */
 			/*	,IspInfo.DebugMask); */
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -2974,7 +2974,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			if (DebugFlag[1] < ISP_CAMSYS_CONFIG_IDX ||
 				DebugFlag[1] > ISP_CAMSV5_IDX) {
-				LOG_NOTICE("CAM Index is out of range:%d",
+				LOG_DBG("CAM Index is out of range:%d",
 					DebugFlag[1]);
 				Ret = -EFAULT;
 				break;
@@ -3022,11 +3022,11 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 						    CAM_REG_CTL_DMA_EN(
 						    DebugFlag[1]));
 
-				LOG_INF("CAM_%d viewFinder is ON(SecOn:0x%x)\n",
+				LOG_DBG("CAM_%d viewFinder is ON(SecOn:0x%x)\n",
 					module, sec_on);
 
 				if (vf & 0x1)
-					LOG_NOTICE(
+					LOG_DBG(
 					    "CAM_%d: vf already enabled\n",
 					    module);
 				else
@@ -3057,31 +3057,31 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				break;
 			}
 			case 0: {
-				LOG_INF("CAM_%d viewFinder is OFF\n", module);
+				LOG_DBG("CAM_%d viewFinder is OFF\n", module);
 
 				if (vf & 0x1)
 					ISP_WR32(
 					    CAM_REG_TG_VF_CON(DebugFlag[1]),
 					    (vf-0x1));
 				else
-					LOG_NOTICE(
+					LOG_DBG(
 					    "CAM_%d: vf already disabled\n",
 					    module);
 				break;
 			}
 			/* CAMSV */
 			case 11: {
-				LOG_INF("CAMSV_%d viewFinder is ON\n", module);
+				LOG_DBG("CAMSV_%d viewFinder is ON\n", module);
 				cam_dmao = (ISP_RD32(
 					CAMSV_REG_MODULE_EN(DebugFlag[1]))
 					& 0x10);
-				LOG_INF("CAMSV_%d:[DMA_EN]:0x%x\n",
+				LOG_DBG("CAMSV_%d:[DMA_EN]:0x%x\n",
 					module, cam_dmao);
 				vf = ISP_RD32(
 					CAMSV_REG_TG_VF_CON(DebugFlag[1]));
 
 				if (vf & 0x1)
-					LOG_NOTICE(
+					LOG_DBG(
 					    "CAMSV_%d: vf already enabled\n",
 					    DebugFlag[1]);
 				else
@@ -3098,7 +3098,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				break;
 			}
 			case 10: {
-				LOG_INF("CAMSV_%d viewFinder is OFF\n",
+				LOG_DBG("CAMSV_%d viewFinder is OFF\n",
 					DebugFlag[1]);
 				vf = ISP_RD32(
 					CAMSV_REG_TG_VF_CON(DebugFlag[1]));
@@ -3108,14 +3108,14 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 					    CAMSV_REG_TG_VF_CON(DebugFlag[1]),
 					    (vf-0x1));
 				else
-					LOG_NOTICE(
+					LOG_DBG(
 					    "CAMSV_%d: vf already disalbed\n",
 					    DebugFlag[1]);
 				break;
 			}
 			}
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3140,7 +3140,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			case ISP_IRQ_TYPE_INT_CAM_B_ST:
 				if (ISP_PopBufTimestamp(DebugFlag[0],
 				    dma_id, Tstp) != 0)
-					LOG_NOTICE(
+					LOG_DBG(
 					    "Get Buf sof timestamp fail");
 
 				break;
@@ -3154,7 +3154,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				Tstp.usec = gSTime[DebugFlag[0]].usec;
 				break;
 			default:
-				LOG_NOTICE("unsupported module:0x%x\n",
+				LOG_DBG("unsupported module:0x%x\n",
 					DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
@@ -3164,7 +3164,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			#else
 			if (DebugFlag[0] < ISP_IRQ_TYPE_INT_CAM_A_ST ||
 			    DebugFlag[0] > ISP_IRQ_TYPE_INT_CAMSV_5_ST) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"unsupported module:0x%x",
 					DebugFlag[0]);
 				Ret = -EFAULT;
@@ -3181,7 +3181,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			if (copy_to_user((void *)Param, &Tstp,
 			    sizeof(struct S_START_T)) != 0) {
-				LOG_NOTICE("copy_to_user failed");
+				LOG_DBG("copy_to_user failed");
 				Ret = -EFAULT;
 			}
 		}
@@ -3198,12 +3198,12 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		/* Set a default clk for EP */
 		ispclks.clklevelcnt = 1;
 		ispclks.clklevel[lv] = 546;
-		LOG_NOTICE("Default DFS Clk level:%d for EP",
+		LOG_DBG("Default DFS Clk level:%d for EP",
 			ispclks.clklevel[lv]);
 
 		if (copy_to_user((void *)Param, &ispclks,
 		    sizeof(struct ISP_CLK_INFO)) != 0) {
-			LOG_NOTICE("copy_to_user failed");
+			LOG_DBG("copy_to_user failed");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3244,7 +3244,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 					}
 				}
 			} else {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ISP_DFS_CTRL copy_from_user failed\n");
 				Ret = -EFAULT;
 			}
@@ -3269,7 +3269,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				target_clk = dfs_update;
 				LOG_DBG("Set clock level:%d", dfs_update);
 			} else {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ISP_DFS_UPDATE copy_from_user failed\n");
 				Ret = -EFAULT;
 			}
@@ -3290,7 +3290,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 					(u32 *)&ispclks.clklevelcnt);
 
 			if (result < 0) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "get MMDVFS freq steps failed, result: %d\n",
 				    result);
 				Ret = -EFAULT;
@@ -3298,7 +3298,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 
 			if (ispclks.clklevelcnt > ISP_CLK_LEVEL_CNT) {
-				LOG_NOTICE("clklevelcnt is exceeded");
+				LOG_DBG("clklevelcnt is exceeded");
 				Ret = -EFAULT;
 				break;
 			}
@@ -3321,7 +3321,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 						MMDVFS_PM_QOS_SUB_SYS_CAMERA);
 
 			if (ispclks.clklevelcnt > ISP_CLK_LEVEL_CNT) {
-				LOG_NOTICE("clklevelcnt is exceeded");
+				LOG_DBG("clklevelcnt is exceeded");
 				Ret = -EFAULT;
 				break;
 			}
@@ -3341,7 +3341,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		#endif
 			if (copy_to_user((void *)Param, &ispclks,
 				sizeof(struct ISP_CLK_INFO)) != 0) {
-				LOG_NOTICE("copy_to_user failed");
+				LOG_DBG("copy_to_user failed");
 				Ret = -EFAULT;
 			}
 		}
@@ -3364,7 +3364,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			if (copy_to_user((void *)Param, &getclk,
 			    sizeof(struct ISP_GET_CLK_INFO)) != 0) {
-				LOG_NOTICE("copy_to_user failed");
+				LOG_DBG("copy_to_user failed");
 				Ret = -EFAULT;
 			}
 		}
@@ -3392,12 +3392,12 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 #endif
 				if (copy_to_user((void *)Param,
 					globalTime, sizeof(u64)*TS_TYPE) != 0) {
-					LOG_NOTICE(
+					LOG_DBG(
 					    "ISP_GET_GLOBAL_TIME copy_to_user failed");
 					Ret = -EFAULT;
 				}
 			} else {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ISP_GET_GLOBAL_TIME copy_from_user failed\n");
 				Ret = -EFAULT;
 			}
@@ -3414,7 +3414,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				    ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				    pm_qos_info.module >
 				    ISP_IRQ_TYPE_INT_CAM_C_ST) {
-					LOG_NOTICE("HW_module error:%d",
+					LOG_DBG("HW_module error:%d",
 					pm_qos_info.module);
 					Ret = -EFAULT;
 					break;
@@ -3425,11 +3425,11 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				G_PM_QOS[pm_qos_info.module].fps =
 					pm_qos_info.fps/10;
 				#else
-				LOG_NOTICE(
+				LOG_DBG(
 				"ISP_SET_PM_QOS_INFO is not supported\n");
 				#endif
 			} else {
-				LOG_NOTICE(
+				LOG_DBG(
 				"ISP_SET_PM_QOS_INFO copy_from_user failed\n");
 				Ret = -EFAULT;
 			}
@@ -3445,7 +3445,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 				if (DebugFlag[1] < ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				    DebugFlag[1] > ISP_IRQ_TYPE_INT_CAM_C_ST) {
-					LOG_NOTICE(
+					LOG_DBG(
 					  "HW_module error:%d", DebugFlag[1]);
 					Ret = -EFAULT;
 					break;
@@ -3472,11 +3472,11 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 					bw_request[DebugFlag[1]] = 0;
 				}
 				#else
-				LOG_NOTICE("ISP_SET_PM_QOS is not supported\n");
+				LOG_DBG("ISP_SET_PM_QOS is not supported\n");
 				break;
 				#endif
 			} else {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ISP_SET_PM_QOS copy_from_user failed\n");
 				Ret = -EFAULT;
 			}
@@ -3486,13 +3486,13 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	case ISP_GET_VSYNC_CNT:
 		if (copy_from_user(&DebugFlag[0], (void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get cur sof from user fail");
+			LOG_DBG("get cur sof from user fail");
 			Ret = -EFAULT;
 		} else {
 
 			if (DebugFlag[0] < ISP_IRQ_TYPE_INT_CAM_A_ST ||
 			    DebugFlag[0] >= ISP_IRQ_TYPE_AMOUNT) {
-				LOG_NOTICE("err TG(0x%x)\n", DebugFlag[0]);
+				LOG_DBG("err TG(0x%x)\n", DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
 			}
@@ -3501,7 +3501,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		}
 		if (copy_to_user((void *)Param, &DebugFlag[1],
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("copy to user fail");
+			LOG_DBG("copy to user fail");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3521,13 +3521,13 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			unsigned int jump;
 
 			if (!pIon_client) {
-				LOG_NOTICE("ion_import: invalid ion client!\n");
+				LOG_DBG("ion_import: invalid ion client!\n");
 				Ret = -EFAULT;
 				break;
 			}
 
 			if (IonNode.devNode >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "[ISP_ION_IMPORT]devNode should be smaller than ISP_DEV_NODE_NUM");
 				Ret = -EFAULT;
 				break;
@@ -3535,7 +3535,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			ptbl = &gION_TBL[IonNode.devNode];
 			if (ptbl->node != IonNode.devNode) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_import: devNode not support(%d)!\n",
 				    IonNode.devNode);
 				Ret = -EFAULT;
@@ -3543,7 +3543,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			if (IonNode.dmaPort < 0 ||
 				IonNode.dmaPort >= _dma_max_wr_) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_import: dmaport error:%d(0~%d)\n",
 				    IonNode.dmaPort, _dma_max_wr_);
 				Ret = -EFAULT;
@@ -3551,7 +3551,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			jump = IonNode.dmaPort*_ion_keep_max_;
 			if (IonNode.memID <= 0) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_import: dma(%d)invalid ion fd(%d)\n",
 				    IonNode.dmaPort, IonNode.memID);
 				Ret = -EFAULT;
@@ -3568,7 +3568,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			/* */
 			if (i < _ion_keep_max_) {
 				if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-					LOG_INF(
+					LOG_DBG(
 					    "ion_import: already exist: dev(%d)dma(%d)i(%d)fd(%d)Hnd(0x%p)\n",
 					    IonNode.devNode,
 					    IonNode.dmaPort,
@@ -3608,7 +3608,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 					if (IspInfo.DebugMask
 						& ISP_DBG_ION_CTRL) {
-						LOG_INF(
+						LOG_DBG(
 						    "ion_import: dev(%d)dma(%d)i(%d)fd(%d)Hnd(0x%p)\n",
 						    IonNode.devNode,
 						    IonNode.dmaPort,
@@ -3622,7 +3622,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
 			/* */
 			if (i == _ion_keep_max_) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_import: dma(%d)no empty space in list(%d_%d)\n",
 				    IonNode.dmaPort,
 				    IonNode.memID,
@@ -3632,7 +3632,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				Ret = -EFAULT;
 			}
 		} else {
-			LOG_NOTICE("[ion import]copy_from_user failed\n");
+			LOG_DBG("[ion import]copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3643,13 +3643,13 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			unsigned int jump;
 
 			if (!pIon_client) {
-				LOG_NOTICE("ion_free: invalid ion client!\n");
+				LOG_DBG("ion_free: invalid ion client!\n");
 				Ret = -EFAULT;
 				break;
 			}
 
 			if (IonNode.devNode >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "[ISP_ION_FREE]devNode should be smaller than ISP_DEV_NODE_NUM");
 				Ret = -EFAULT;
 				break;
@@ -3657,7 +3657,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 			ptbl = &gION_TBL[IonNode.devNode];
 			if (ptbl->node != IonNode.devNode) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_free: devNode not support(%d)!\n",
 				    IonNode.devNode);
 				Ret = -EFAULT;
@@ -3665,7 +3665,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			if (IonNode.dmaPort < 0 ||
 			    IonNode.dmaPort >= _dma_max_wr_) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_free: dmaport error:%d(0~%d)\n",
 				    IonNode.dmaPort,
 				    _dma_max_wr_);
@@ -3674,7 +3674,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			jump = IonNode.dmaPort*_ion_keep_max_;
 			if (IonNode.memID <= 0) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_free: invalid ion fd(%d)\n",
 				    IonNode.memID);
 				Ret = -EFAULT;
@@ -3689,7 +3689,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 			if (i == _ion_keep_max_) {
 				spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_free: can't find ion dev(%d)dma(%d)fd(%d) in list\n",
 				    IonNode.devNode,
 				    IonNode.dmaPort,
@@ -3705,7 +3705,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			if (--ptbl->pIonCt[jump + i] > 0) {
 				spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
 				if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-					LOG_INF(
+					LOG_DBG(
 					    "ion_free: user ct(%d): dev(%d)dma(%d)i(%d)fd(%d)\n",
 					    ptbl->pIonCt[jump + i],
 					    IonNode.devNode,
@@ -3716,7 +3716,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				break;
 			} else if (ptbl->pIonCt[jump + i] < 0) {
 				spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ion_free: free more than import (%d): dev(%d)dma(%d)i(%d)fd(%d)\n",
 				    ptbl->pIonCt[jump + i],
 				    IonNode.devNode,
@@ -3728,7 +3728,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			}
 
 			if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-				LOG_INF(
+				LOG_DBG(
 				    "ion_free: dev(%d)dma(%d)i(%d)fd(%d)Hnd(0x%p)Ct(%d)\n",
 					IonNode.devNode, IonNode.dmaPort, i,
 					IonNode.memID,
@@ -3743,7 +3743,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			/* */
 			ISP_ion_free_handle(pIon_client, p_IonHnd);
 		} else {
-			LOG_NOTICE("[ion free]copy_from_user failed\n");
+			LOG_DBG("[ion free]copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3751,20 +3751,20 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		if (copy_from_user(&module, (void *)Param,
 			sizeof(unsigned int)) == 0) {
 			if (module >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE(
+				LOG_DBG(
 				   "[ISP_ION_FREE_BY_HWMODULE]module should be smaller than ISP_DEV_NODE_NUM");
 				Ret = -EFAULT;
 				break;
 			}
 			if (gION_TBL[module].node != module) {
-				LOG_NOTICE("module error(%d)\n", module);
+				LOG_DBG("module error(%d)\n", module);
 				Ret = -EFAULT;
 				break;
 			}
 
 			ISP_ion_free_handle_by_module(module);
 		} else {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "[ion free by module]copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
@@ -3782,7 +3782,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 				if (multiRAWConfig.HWmodule < 0 ||
 				    multiRAWConfig.HWmodule >
 				    (ISP_IRQ_TYPE_INT_CAMSV_0_ST - 1)) {
-					LOG_NOTICE("Wrong HWmodule:%d",
+					LOG_DBG("Wrong HWmodule:%d",
 						multiRAWConfig.HWmodule);
 					Ret = -EFAULT;
 					break;
@@ -3954,7 +3954,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 		if (copy_from_user(&larbInfo, (void *)Param,
 		    sizeof(struct ISP_LARB_MMU_STRUCT)) != 0) {
-			LOG_NOTICE("copy_from_user LARB_MMU_CTL failed\n");
+			LOG_DBG("copy_from_user LARB_MMU_CTL failed\n");
 			Ret = -EFAULT;
 			goto EXIT;
 		}
@@ -3964,7 +3964,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		case 6:
 			break;
 		default:
-			LOG_NOTICE("Wrong SMI_LARB port=%d\n",
+			LOG_DBG("Wrong SMI_LARB port=%d\n",
 				larbInfo.LarbNum);
 			Ret = -EFAULT;
 			goto EXIT;
@@ -3972,7 +3972,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 
 		if ((SMI_LARB_BASE[larbInfo.LarbNum] == NULL) ||
 			(larbInfo.regOffset >= 0x1000)) {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "Wrong SMI_LARB port=%d base addr=%p offset=0x%x\n",
 			    larbInfo.LarbNum,
 			    SMI_LARB_BASE[larbInfo.LarbNum],
@@ -3990,12 +3990,12 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	case ISP_SET_SEC_DAPC_REG:
 		if (copy_from_user(Dapc_Reg, (void *)Param,
 			sizeof(unsigned int) * 6) != 0) {
-			LOG_NOTICE("get ISP_SET_SEC_DAPC_REG from user fail\n");
+			LOG_DBG("get ISP_SET_SEC_DAPC_REG from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			if (Dapc_Reg[0] < ISP_CAM_A_IDX ||
 			    Dapc_Reg[0] >= ISP_CAMSV0_IDX) {
-				LOG_NOTICE("module index(0x%x) error\n",
+				LOG_DBG("module index(0x%x) error\n",
 					   Dapc_Reg[0]);
 				Ret = -EFAULT;
 				break;
@@ -4005,7 +4005,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 			lock_reg.CAM_REG_CTL_DMA_EN[Dapc_Reg[0]] = Dapc_Reg[3];
 			lock_reg.CAM_REG_CTL_SEL[Dapc_Reg[0]] = Dapc_Reg[4];
 			lock_reg.CAM_REG_CTL_EN2[Dapc_Reg[0]] = Dapc_Reg[5];
-			LOG_INF(
+			LOG_DBG(
 			    "[DAPC]CAM_CTL_EN:0x%x CAM_CTL_DMA_EN:0x%x CAM_CTL_SEL:0x%x CAM_CTL_EN2:0x%x",
 			    lock_reg.CAM_REG_CTL_EN[Dapc_Reg[0]],
 			    lock_reg.CAM_REG_CTL_DMA_EN[Dapc_Reg[0]],
@@ -4015,7 +4015,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 		break;
 	default:
 	{
-		LOG_NOTICE("Unknown Cmd(%d)\n", Cmd);
+		LOG_DBG("Unknown Cmd(%d)\n", Cmd);
 		Ret = -EPERM;
 		break;
 	}
@@ -4023,7 +4023,7 @@ static long ISP_ioctl(struct file *pFile, unsigned int Cmd, unsigned long Param)
 	/*  */
 EXIT:
 	if (Ret != 0)
-		LOG_NOTICE(
+		LOG_DBG(
 		    "Fail, Cmd(%d), Pid(%d), (process, pid, tgid)=(%s, %d, %d)\n",
 		    Cmd, pUserInfo->Pid, current->comm,
 		    current->pid, current->tgid);
@@ -4174,14 +4174,14 @@ static long ISP_ioctl_compat(
 
 		err = compat_get_isp_read_register_data(data32, data);
 		if (err) {
-			LOG_INF("compat_get_isp_read_register_data error!!!\n");
+			LOG_DBG("compat_get_isp_read_register_data error!!!\n");
 			return err;
 		}
 		ret = filp->f_op->unlocked_ioctl(filp,
 			ISP_READ_REGISTER, (unsigned long)data);
 		err = compat_put_isp_read_register_data(data32, data);
 		if (err) {
-			LOG_INF("compat_put_isp_read_register_data error!!!\n");
+			LOG_DBG("compat_put_isp_read_register_data error!!!\n");
 			return err;
 		}
 		return ret;
@@ -4199,7 +4199,7 @@ static long ISP_ioctl_compat(
 
 		err = compat_get_isp_read_register_data(data32, data);
 		if (err) {
-			LOG_INF("COMPAT_ISP_WRITE_REGISTER error!!!\n");
+			LOG_DBG("COMPAT_ISP_WRITE_REGISTER error!!!\n");
 			return err;
 		}
 		ret = filp->f_op->unlocked_ioctl(filp,
@@ -4222,7 +4222,7 @@ static long ISP_ioctl_compat(
 			return err;
 
 		if (err) {
-			LOG_INF(
+			LOG_DBG(
 				"compat_get_isp_buf_ctrl_struct_data error!\n");
 			return err;
 		}
@@ -4231,7 +4231,7 @@ static long ISP_ioctl_compat(
 		err = compat_put_isp_buf_ctrl_struct_data(data32, data);
 
 		if (err) {
-			LOG_INF("compat_put_isp_buf_ctrl_struct_data error!\n");
+			LOG_DBG("compat_put_isp_buf_ctrl_struct_data error!\n");
 			return err;
 		}
 		return ret;
@@ -4250,14 +4250,14 @@ static long ISP_ioctl_compat(
 
 		err = compat_get_isp_ref_cnt_ctrl_struct_data(data32, data);
 		if (err) {
-			LOG_INF(
+			LOG_DBG(
 			  "compat_get_isp_ref_cnt_ctrl_struct_data error!\n");
 			return err;
 		}
 
 		err = compat_put_isp_ref_cnt_ctrl_struct_data(data32, data);
 		if (err) {
-			LOG_INF(
+			LOG_DBG(
 			  "compat_put_isp_ref_cnt_ctrl_struct_data error!!!\n");
 			return err;
 		}
@@ -4483,7 +4483,7 @@ EXIT:
 			G_u4EnableClockCount);
 	}
 
-	LOG_INF(
+	LOG_DBG(
 	    "- X. Ret: %d. UserCount: %d. G_u4EnableClockCount:%d\n", Ret,
 	    IspInfo.UserCount, G_u4EnableClockCount);
 
@@ -4531,14 +4531,14 @@ static inline void ISP_StopHW(int module)
 		if (regTGSt == 1)
 			break;
 
-		LOG_INF("%s: wait 1VD (%d)\n", moduleName, loopCnt);
+		LOG_DBG("%s: wait 1VD (%d)\n", moduleName, loopCnt);
 		ret = ISP_WaitIrq(&waitirq);
 		/* first wait is clear wait, others are non-clear wait */
 		waitirq.EventInfo.Clear = ISP_IRQ_CLEAR_NONE;
 	} while (--loopCnt);
 
 	if (-ERESTARTSYS == ret) {
-		LOG_INF("%s: interrupt by system signal, wait idle\n",
+		LOG_DBG("%s: interrupt by system signal, wait idle\n",
 			moduleName);
 		/* timer*/
 		m_sec = ktime_get();
@@ -4553,14 +4553,14 @@ static inline void ISP_StopHW(int module)
 				break;
 		}
 		if (regTGSt == 1)
-			LOG_INF("%s: wait idle done\n", moduleName);
+			LOG_DBG("%s: wait idle done\n", moduleName);
 		else
-			LOG_INF("%s: wait idle timeout(%lld)\n",
+			LOG_DBG("%s: wait idle timeout(%lld)\n",
 				moduleName, (sec - m_sec));
 	}
 
 RESET:
-	LOG_INF("%s: reset\n", moduleName);
+	LOG_DBG("%s: reset\n", moduleName);
 	/* timer*/
 	m_sec = ktime_get();
 
@@ -4573,7 +4573,7 @@ RESET:
 		sec = ktime_get();
 		/* wait time>timeoutMs, break */
 		if ((sec  - m_sec) > timeoutMs) {
-			LOG_INF("%s: wait SW idle timeout\n", moduleName);
+			LOG_DBG("%s: wait SW idle timeout\n", moduleName);
 			break;
 		}
 	}
@@ -4592,7 +4592,7 @@ RESET:
 		sec = ktime_get();
 		/* wait time>timeoutMs, break */
 		if ((sec  - m_sec) > (timeoutMs/50000)) {
-			LOG_INF("%s: wait SW RST ST 50000 timeout\n",
+			LOG_DBG("%s: wait SW RST ST 50000 timeout\n",
 				moduleName);
 			break;
 		}
@@ -4659,14 +4659,14 @@ static inline void ISP_StopSVHW(int module)
 		if (regTGSt == 1)
 			break;
 
-		LOG_INF("%s: wait 1VD (%d)\n", moduleName, loopCnt);
+		LOG_DBG("%s: wait 1VD (%d)\n", moduleName, loopCnt);
 		ret = ISP_WaitIrq(&waitirq);
 		/* first wait is clear wait, others are non-clear wait */
 		waitirq.EventInfo.Clear = ISP_IRQ_CLEAR_NONE;
 	} while (--loopCnt);
 
 	if (-ERESTARTSYS == ret) {
-		LOG_INF("%s: interrupt by system signal, wait idle\n",
+		LOG_DBG("%s: interrupt by system signal, wait idle\n",
 			moduleName);
 		/* timer*/
 		m_sec = ktime_get();
@@ -4681,13 +4681,13 @@ static inline void ISP_StopSVHW(int module)
 				break;
 		}
 		if (regTGSt == 1)
-			LOG_INF("%s: wait idle done\n", moduleName);
+			LOG_DBG("%s: wait idle done\n", moduleName);
 		else
-			LOG_INF("%s: wait idle timeout(%lld)\n",
+			LOG_DBG("%s: wait idle timeout(%lld)\n",
 				moduleName, (sec - m_sec));
 	}
 
-	LOG_INF("%s: reset\n", moduleName);
+	LOG_DBG("%s: reset\n", moduleName);
 	/* timer*/
 	m_sec = ktime_get();
 
@@ -4701,7 +4701,7 @@ static inline void ISP_StopSVHW(int module)
 		sec = ktime_get();
 		/* wait time>timeoutMs, break */
 		if ((sec  - m_sec) > timeoutMs) {
-			LOG_INF("%s: wait SW idle timeout\n", moduleName);
+			LOG_DBG("%s: wait SW idle timeout\n", moduleName);
 			break;
 		}
 	}
@@ -4800,7 +4800,7 @@ static int ISP_release(
 	 */
 	/* the power-saving mode */
 	if (g_WaitLockCt) {
-		LOG_INF("wakelock disable!! cnt(%d)\n", g_WaitLockCt);
+		LOG_DBG("wakelock disable!! cnt(%d)\n", g_WaitLockCt);
 #ifdef CONFIG_PM_SLEEP
 		__pm_relax(&isp_wake_lock);
 #endif
@@ -4865,7 +4865,7 @@ static int ISP_release(
 
 EXIT:
 
-	LOG_INF("- X. UserCount: %d. G_u4EnableClockCount:%d",
+	LOG_DBG("- X. UserCount: %d. G_u4EnableClockCount:%d",
 		IspInfo.UserCount,
 		G_u4EnableClockCount);
 	return 0;
@@ -4886,7 +4886,7 @@ static int ISP_mmap(struct file *pFile, struct vm_area_struct *pVma)
 	pVma->vm_page_prot = pgprot_noncached(pVma->vm_page_prot);
 	pfn = pVma->vm_pgoff << PAGE_SHIFT;
 
-	/*LOG_INF("ISP_mmap: vm_pgoff(0x%lx),pfn(0x%x),phy(0x%lx),
+	/*LOG_DBG("ISP_mmap: vm_pgoff(0x%lx),pfn(0x%x),phy(0x%lx),
 	 *	vm_start(0x%lx),vm_end(0x%lx),length(0x%lx)\n",
 	 *	pVma->vm_pgoff, pfn, pVma->vm_pgoff << PAGE_SHIFT,
 	 *	pVma->vm_start, pVma->vm_end, length);
@@ -4897,7 +4897,7 @@ static int ISP_mmap(struct file *pFile, struct vm_area_struct *pVma)
 	case CAM_B_BASE_HW:
 	case CAM_C_BASE_HW:
 		if (length > ISP_REG_RANGE) {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "mmap range error :module(0x%x) length(0x%lx),ISP_REG_RANGE(0x%lx)!\n",
 			    pfn, length, ISP_REG_RANGE);
 			return -EAGAIN;
@@ -4911,14 +4911,14 @@ static int ISP_mmap(struct file *pFile, struct vm_area_struct *pVma)
 	case CAMSV_5_BASE_HW:
 	case UNI_A_BASE_HW:
 		if (length > ISP_REG_RANGE/2) {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "mmap range error :module(0x%x) length(0x%lx),ISP_REG_RANGE(0x%lx)!\n",
 			    pfn, length, ISP_REG_RANGE/2);
 			return -EAGAIN;
 		}
 		break;
 	default:
-		LOG_NOTICE("Illegal starting HW addr for mmap!\n");
+		LOG_DBG("Illegal starting HW addr for mmap!\n");
 		return -EAGAIN;
 	}
 	if (remap_pfn_range(
@@ -4977,13 +4977,13 @@ static inline int ISP_RegCharDev(void)
 	/*  */
 	Ret = alloc_chrdev_region(&IspDevNo, 0, 1, ISP_DEV_NAME);
 	if ((Ret) < 0) {
-		LOG_NOTICE("alloc_chrdev_region failed, %d\n", Ret);
+		LOG_DBG("alloc_chrdev_region failed, %d\n", Ret);
 		return Ret;
 	}
 	/* Allocate driver */
 	pIspCharDrv = cdev_alloc();
 	if (pIspCharDrv == NULL) {
-		LOG_NOTICE("cdev_alloc failed\n");
+		LOG_DBG("cdev_alloc failed\n");
 		Ret = -ENOMEM;
 		goto EXIT;
 	}
@@ -4994,7 +4994,7 @@ static inline int ISP_RegCharDev(void)
 	/* Add to system */
 	Ret = cdev_add(pIspCharDrv, IspDevNo, 1);
 	if ((Ret) < 0) {
-		LOG_NOTICE("Attatch file operation failed, %d\n", Ret);
+		LOG_DBG("Attatch file operation failed, %d\n", Ret);
 		goto EXIT;
 	}
 	/*  */
@@ -5023,7 +5023,7 @@ static int ISP_probe(struct platform_device *pDev)
 	struct device *dev = NULL;
 #endif
 
-	LOG_INF("- E. ISP driver probe.\n");
+	LOG_DBG("- E. ISP driver probe.\n");
 
 	/* Get platform_device parameters */
 #ifdef CONFIG_OF
@@ -5055,7 +5055,7 @@ static int ISP_probe(struct platform_device *pDev)
 		return -ENOMEM;
 	}
 
-	LOG_INF("nr_isp_devs=%d, devnode(%s), map_addr=0x%lx\n",
+	LOG_DBG("nr_isp_devs=%d, devnode(%s), map_addr=0x%lx\n",
 		nr_isp_devs, pDev->dev.of_node->name,
 		(unsigned long)isp_dev->regs);
 
@@ -5092,7 +5092,7 @@ static int ISP_probe(struct platform_device *pDev)
 					return Ret;
 				}
 
-				LOG_INF(
+				LOG_DBG(
 				    "nr_isp_devs=%d, devnode(%s), irq=%d, ISR: %s\n",
 				    nr_isp_devs,
 				    pDev->dev.of_node->name,
@@ -5103,7 +5103,7 @@ static int ISP_probe(struct platform_device *pDev)
 		}
 
 		if (i >= ISP_IRQ_TYPE_AMOUNT)
-			LOG_INF(
+			LOG_DBG(
 			    "No corresponding ISR!!: nr_isp_devs=%d, devnode(%s), irq=%d\n",
 			    nr_isp_devs,
 			    pDev->dev.of_node->name,
@@ -5111,7 +5111,7 @@ static int ISP_probe(struct platform_device *pDev)
 
 
 	} else {
-		LOG_INF("No IRQ!!: nr_isp_devs=%d, devnode(%s), irq=%d\n",
+		LOG_DBG("No IRQ!!: nr_isp_devs=%d, devnode(%s), irq=%d\n",
 			nr_isp_devs, pDev->dev.of_node->name, isp_dev->irq);
 	}
 
@@ -5128,7 +5128,7 @@ static int ISP_probe(struct platform_device *pDev)
 		pIspClass = class_create(THIS_MODULE, "ispdrv");
 		if (IS_ERR(pIspClass)) {
 			Ret = PTR_ERR(pIspClass);
-			LOG_NOTICE("Unable to create class, err = %d\n", Ret);
+			LOG_DBG("Unable to create class, err = %d\n", Ret);
 			goto EXIT;
 		}
 		dev = device_create(
@@ -5184,35 +5184,35 @@ static int ISP_probe(struct platform_device *pDev)
 					&pDev->dev, "CAMSYS_CAMSV2_CGPDN");
 
 		if (IS_ERR(isp_clk.ISP_SCP_SYS_DIS)) {
-			LOG_NOTICE("cannot get ISP_SCP_SYS_DIS clock\n");
+			LOG_DBG("cannot get ISP_SCP_SYS_DIS clock\n");
 			return PTR_ERR(isp_clk.ISP_SCP_SYS_DIS);
 		}
 		if (IS_ERR(isp_clk.ISP_SCP_SYS_ISP)) {
-			LOG_NOTICE("cannot get ISP_SCP_SYS_ISP clock\n");
+			LOG_DBG("cannot get ISP_SCP_SYS_ISP clock\n");
 			return PTR_ERR(isp_clk.ISP_SCP_SYS_ISP);
 		}
 		if (IS_ERR(isp_clk.ISP_SCP_SYS_CAM)) {
-			LOG_NOTICE("cannot get ISP_SCP_SYS_CAM clock\n");
+			LOG_DBG("cannot get ISP_SCP_SYS_CAM clock\n");
 			return PTR_ERR(isp_clk.ISP_SCP_SYS_CAM);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSYS)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSYS clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSYS clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSYS);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMTG)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMTG clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMTG clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMTG);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSV0)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSV0 clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSV0 clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSV0);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSV1)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSV1 clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSV1 clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSV1);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSV2)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSV2 clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSV2 clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSV2);
 		}
 #endif
@@ -5314,7 +5314,7 @@ EXIT:
 
 	}
 
-	LOG_INF("- X. ISP driver probe.\n");
+	LOG_DBG("- X. ISP driver probe.\n");
 
 	return Ret;
 }
@@ -5387,7 +5387,7 @@ static int ISP_suspend(
 				G_u4EnableClockCount,
 				atomic_read(&G_u4DevNodeCt));
 		} else if (IspInfo.UserCount != 0) {
-			LOG_INF(
+			LOG_DBG(
 			    "%s - X. UserCount=%d,G_u4EnableClockCount=0,wakelock:%d,devct:%d\n",
 			    moduleName,
 			    IspInfo.UserCount,
@@ -5433,7 +5433,7 @@ static int ISP_suspend(
 		module = ISP_CAMSV5_IDX;
 		break;
 	case ISP_IRQ_TYPE_AMOUNT:
-		LOG_NOTICE("dev name is not found (%s)", moduleName);
+		LOG_DBG("dev name is not found (%s)", moduleName);
 		break;
 	case ISP_IRQ_TYPE_INT_UNI_A_ST:
 	default:
@@ -5448,7 +5448,7 @@ static int ISP_suspend(
 	/*LOG_DBG("%s: Rs_TG(0x%08x)\n", moduleName, regVal);*/
 
 	if (regVal & 0x01) {
-		LOG_INF("%s_suspend,disable VF,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_suspend,disable VF,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName, g_WaitLockCt, G_u4EnableClockCount,
 			atomic_read(&G_u4DevNodeCt));
 		SuspnedRecord[module] = 1;
@@ -5471,14 +5471,14 @@ static int ISP_suspend(
 			if (regTGSt == 1)
 				break;
 
-			LOG_INF("%s: wait 1VD (%d)\n", moduleName, loopCnt);
+			LOG_DBG("%s: wait 1VD (%d)\n", moduleName, loopCnt);
 			ret = ISP_WaitIrq(&waitirq);
 			/* first wait is clear wait, others are non-clear wait*/
 			waitirq.EventInfo.Clear = ISP_IRQ_CLEAR_NONE;
 		} while (--loopCnt);
 
 		if (-ERESTARTSYS == ret) {
-			LOG_INF("%s: interrupt by system signal, wait idle\n",
+			LOG_DBG("%s: interrupt by system signal, wait idle\n",
 				moduleName);
 			/* timer*/
 			m_sec = ktime_get();
@@ -5493,9 +5493,9 @@ static int ISP_suspend(
 					break;
 			}
 			if (regTGSt == 1)
-				LOG_INF("%s: wait idle done\n", moduleName);
+				LOG_DBG("%s: wait idle done\n", moduleName);
 			else
-				LOG_INF("%s: wait idle timeout(%lld)\n",
+				LOG_DBG("%s: wait idle timeout(%lld)\n",
 					moduleName, (sec - m_sec));
 		}
 
@@ -5509,7 +5509,7 @@ static int ISP_suspend(
 		regVal = ISP_RD32(CAM_REG_TG_SEN_MODE(module));
 		ISP_WR32(CAM_REG_TG_SEN_MODE(module), (regVal & (~0x01)));
 	} else {
-		LOG_INF("%s_suspend,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_suspend,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName, g_WaitLockCt, G_u4EnableClockCount,
 			atomic_read(&G_u4DevNodeCt));
 		SuspnedRecord[module] = 0;
@@ -5522,7 +5522,7 @@ EXIT:
 		loopCnt = G_u4EnableClockCount;
 		spin_unlock(&(IspInfo.SpinLockClock));
 
-		LOG_INF("%s - X. wakelock:%d, last dev node,disable clk:%d\n",
+		LOG_DBG("%s - X. wakelock:%d, last dev node,disable clk:%d\n",
 			moduleName, g_WaitLockCt, loopCnt);
 		while (loopCnt > 0) {
 			ISP_EnableClock(MFALSE);
@@ -5594,7 +5594,7 @@ static int ISP_resume(struct platform_device *pDev)
 		module = ISP_CAMSV5_IDX;
 		break;
 	case ISP_IRQ_TYPE_AMOUNT:
-		LOG_NOTICE("dev name is not found (%s)", moduleName);
+		LOG_DBG("dev name is not found (%s)", moduleName);
 		break;
 	case ISP_IRQ_TYPE_INT_UNI_A_ST:
 	default:
@@ -5610,7 +5610,7 @@ static int ISP_resume(struct platform_device *pDev)
 	ISP_EnableClock(MTRUE);
 
 	if (SuspnedRecord[module]) {
-		LOG_INF("%s_resume,enable VF,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_resume,enable VF,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName, g_WaitLockCt, G_u4EnableClockCount,
 			atomic_read(&G_u4DevNodeCt));
 		SuspnedRecord[module] = 0;
@@ -5622,7 +5622,7 @@ static int ISP_resume(struct platform_device *pDev)
 		regVal = ISP_RD32(CAM_REG_TG_VF_CON(module));
 		ISP_WR32(CAM_REG_TG_VF_CON(module), (regVal | 0x01));
 	} else {
-		LOG_INF("%s_resume,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_resume,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName, g_WaitLockCt, G_u4EnableClockCount,
 			atomic_read(&G_u4DevNodeCt));
 	}
@@ -5717,7 +5717,7 @@ static ssize_t ISP_DumpRegToProc(
 	size_t off,
 	loff_t *Count)
 {
-	LOG_NOTICE("Not implement");
+	LOG_DBG("Not implement");
 	return 0;
 }
 
@@ -5730,7 +5730,7 @@ static ssize_t ISP_RegDebug(
 	size_t Count,
 	loff_t *pData)
 {
-	LOG_NOTICE("Not implement");
+	LOG_DBG("Not implement");
 	return 0;
 }
 
@@ -5743,7 +5743,7 @@ static ssize_t CAMIO_DumpRegToProc(
 	size_t off,
 	loff_t *Count)
 {
-	LOG_NOTICE("Not implement");
+	LOG_DBG("Not implement");
 	return 0;
 }
 
@@ -5756,7 +5756,7 @@ static ssize_t CAMIO_RegDebug(
 	size_t Count,
 	loff_t *pData)
 {
-	LOG_NOTICE("Not implement");
+	LOG_DBG("Not implement");
 	return 0;
 }
 
@@ -5790,7 +5790,7 @@ static int __init ISP_Init(void)
 	/*  */
 	Ret = platform_driver_register(&IspDriver);
 	if ((Ret) < 0) {
-		LOG_NOTICE("platform_driver_register fail");
+		LOG_DBG("platform_driver_register fail");
 		return Ret;
 	}
 
@@ -5804,7 +5804,7 @@ static int __init ISP_Init(void)
 
 		comp_str = kmalloc(64, GFP_KERNEL);
 		if (comp_str == NULL) {
-			LOG_NOTICE("kmalloc failed for finding compatible\n");
+			LOG_DBG("kmalloc failed for finding compatible\n");
 			break;
 		}
 
@@ -5812,24 +5812,24 @@ static int __init ISP_Init(void)
 
 			if (snprintf(comp_str, 64,
 					"mediatek,smi_larb%d", i) < 0) {
-				LOG_NOTICE("[Error] %s: snprintf failed",
+				LOG_DBG("[Error] %s: snprintf failed",
 					   __func__);
 			}
-			LOG_INF("Finding SMI_LARB compatible: %s\n", comp_str);
+			LOG_DBG("Finding SMI_LARB compatible: %s\n", comp_str);
 
 			node = of_find_compatible_node(NULL, NULL, comp_str);
 			if (!node) {
-				LOG_NOTICE("find %s node failed!\n", comp_str);
+				LOG_DBG("find %s node failed!\n", comp_str);
 				SMI_LARB_BASE[i] = 0;
 				continue;
 			}
 			SMI_LARB_BASE[i] = of_iomap(node, 0);
 			if (!SMI_LARB_BASE[i]) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "unable to map SMI_LARB_BASE registers!\n");
 				break;
 			}
-			LOG_INF("SMI_LARB%d_BASE: %p\n", i, SMI_LARB_BASE[i]);
+			LOG_DBG("SMI_LARB%d_BASE: %p\n", i, SMI_LARB_BASE[i]);
 		}
 
 		/* if (comp_str) coverity: no need if, kfree is safe */
@@ -5838,7 +5838,7 @@ static int __init ISP_Init(void)
 	#endif
 	node = of_find_compatible_node(NULL, NULL, "mediatek,mmsys_config");
 	if (!node) {
-		LOG_NOTICE("find mmsys_config node failed!!!\n");
+		LOG_DBG("find mmsys_config node failed!!!\n");
 		return -ENODEV;
 	}
 
@@ -5866,7 +5866,7 @@ static int __init ISP_Init(void)
 				pBuf_kmalloc[j] =
 					kmalloc(i + 2 * PAGE_SIZE, GFP_KERNEL);
 				if ((pBuf_kmalloc[j]) == NULL) {
-					LOG_NOTICE("mem not enough\n");
+					LOG_DBG("mem not enough\n");
 					return -ENOMEM;
 				}
 				memset(pBuf_kmalloc[j], 0x00, i);
@@ -5876,7 +5876,7 @@ static int __init ISP_Init(void)
 					(RT_BUF_TBL_NPAGES + 2) * PAGE_SIZE,
 					GFP_KERNEL);
 				if ((pBuf_kmalloc[j]) == NULL) {
-					LOG_NOTICE("mem not enough\n");
+					LOG_DBG("mem not enough\n");
 					return -ENOMEM;
 				}
 				memset(pBuf_kmalloc[j], 0x00,
@@ -5913,7 +5913,7 @@ static int __init ISP_Init(void)
 	}
 	pLog_kmalloc = kmalloc(i, GFP_KERNEL);
 	if ((pLog_kmalloc) == NULL) {
-		LOG_NOTICE("mem not enough\n");
+		LOG_DBG("mem not enough\n");
 		return -ENOMEM;
 	}
 	memset(pLog_kmalloc, 0x00, i);
@@ -5925,7 +5925,7 @@ static int __init ISP_Init(void)
 			/* (NORMAL_STR_LEN*DBG_PAGE)); */
 			tmp = (void *)((char *)tmp +
 				(NORMAL_STR_LEN * DBG_PAGE));
-			gSvLog[j]._str[i][_LOG_INF] = (char *)tmp;
+			gSvLog[j]._str[i][_LOG_DBG] = (char *)tmp;
 			/* tmp = (void*) ((unsigned int)tmp + */
 			/* (NORMAL_STR_LEN*INF_PAGE)); */
 			tmp = (void *)((char *)tmp +
@@ -6159,7 +6159,7 @@ enum CAM_FrameST Irq_CAM_FrameStatus(
 	unsigned int i;
 
 	if ((module < ISP_CAM_A_IDX) || (module >= ISP_CAMSV0_IDX)) {
-		LOG_NOTICE("unsupported module:0x%x\n", module);
+		LOG_DBG("unsupported module:0x%x\n", module);
 		return CAM_FST_DROP_FRAME;
 	}
 
@@ -6279,7 +6279,7 @@ enum CAM_FrameST Irq_CAM_FrameStatus(
 						    fbc_ctrl2[dma_arry_map[
 							i]].Bits.FBC_CNT;
 				} else {
-					LOG_INF(
+					LOG_DBG(
 					"cam:%d dma:%d overwrite preveFbcDropCnt %d <= %d subsample:%d\n",
 					irq_mod, i,
 					IspInfo.TstpQInfo[irq_mod]
@@ -6432,20 +6432,20 @@ static enum CAM_FrameST Irq_CAM_SttFrameStatus(
 	case ISP_CAM_B_IDX:
 	case ISP_CAM_C_IDX:
 		if (dma_id >= _cam_max_) {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "LINE_%d ERROR: unsupported module:0x%x dma:%d\n",
 			    __LINE__, module, dma_id);
 			return CAM_FST_DROP_FRAME;
 		}
 		if (dma_arry_map[dma_id] < 0) {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "LINE_%d ERROR: unsupported module:0x%x dma:%d\n",
 			    __LINE__, module, dma_id);
 			return CAM_FST_DROP_FRAME;
 		}
 		break;
 	default:
-		LOG_NOTICE(
+		LOG_DBG(
 		    "LINE_%d ERROR: unsupported module:0x%x dma:%d\n",
 		    __LINE__, module, dma_id);
 		return CAM_FST_DROP_FRAME;
@@ -6516,7 +6516,7 @@ static enum CAM_FrameST Irq_CAM_SttFrameStatus(
 				else
 					product *= fbc_ctrl2.Bits.FBC_CNT;
 			} else {
-				LOG_INF(
+				LOG_DBG(
 				    "cam:%d dma:%d overwrite preveFbcDropCnt %d <= %d\n",
 				    irq_mod, dma_id,
 				    IspInfo.TstpQInfo[irq_mod]
@@ -6609,7 +6609,7 @@ static int32_t ISP_PushBufTimestamp(unsigned int module,
 		reg_module = ISP_CAM_C_IDX;
 		break;
 	default:
-		LOG_NOTICE("Unsupport module:x%x\n", module);
+		LOG_DBG("Unsupport module:x%x\n", module);
 		return -EFAULT;
 	}
 
@@ -6667,7 +6667,7 @@ static int32_t ISP_PushBufTimestamp(unsigned int module,
 				ISP_RD32(CAM_REG_FBC_UFGO_CTL2(reg_module));
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
@@ -6682,7 +6682,7 @@ static int32_t ISP_PushBufTimestamp(unsigned int module,
 	if (((fbc_ctrl2.Bits.WCNT + frmPeriod) & 63) ==
 		IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt) {
 		IRQ_LOG_KEEPER(
-			module, m_CurrentPPB, _LOG_INF,
+			module, m_CurrentPPB, _LOG_DBG,
 			"Cam:%d dma:%d ignore push wcnt_%d_%d\n",
 			module, dma_id,
 			IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt,
@@ -6733,7 +6733,7 @@ static int32_t ISP_PopBufTimestamp(
 		case _ufgo_:
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
@@ -6747,12 +6747,12 @@ static int32_t ISP_PopBufTimestamp(
 		case _camsv_imgo_:
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
 	default:
-		LOG_NOTICE("Unsupport module:x%x\n", module);
+		LOG_DBG("Unsupport module:x%x\n", module);
 		return -EFAULT;
 	}
 
@@ -6782,7 +6782,7 @@ static int32_t ISP_WaitTimestampReady(unsigned int module, unsigned int dma_id)
 		IspInfo.TstpQInfo[module].Dmao[dma_id].TotalRdCnt)
 		return 0;
 
-	LOG_INF("Wait module:%d dma:%d timestamp ready W/R:%d/%d\n",
+	LOG_DBG("Wait module:%d dma:%d timestamp ready W/R:%d/%d\n",
 	    module, dma_id,
 	    (unsigned int)IspInfo.TstpQInfo[module].Dmao[dma_id].TotalWrCnt,
 	    (unsigned int)IspInfo.TstpQInfo[module].Dmao[dma_id].TotalRdCnt);
@@ -6798,7 +6798,7 @@ static int32_t ISP_WaitTimestampReady(unsigned int module, unsigned int dma_id)
 		if ((_timeout != 0) &&
 		    (!(IspInfo.TstpQInfo[module].Dmao[dma_id].TotalWrCnt >
 		    IspInfo.TstpQInfo[module].Dmao[dma_id].TotalRdCnt))) {
-			LOG_INF(
+			LOG_DBG(
 			    "interrupted by system signal, return value(%d)\n",
 			    _timeout);
 			return -ERESTARTSYS;
@@ -6807,11 +6807,11 @@ static int32_t ISP_WaitTimestampReady(unsigned int module, unsigned int dma_id)
 		if (_timeout > 0)
 			break;
 
-		LOG_INF("WARNING: cam:%d dma:%d wait left count %d\n",
+		LOG_DBG("WARNING: cam:%d dma:%d wait left count %d\n",
 			module, dma_id, wait_cnt);
 	}
 	if (wait_cnt == 0) {
-		LOG_NOTICE("ERROR: cam:%d dma:%d wait timestamp timeout!!!\n",
+		LOG_DBG("ERROR: cam:%d dma:%d wait timestamp timeout!!!\n",
 			module, dma_id);
 		return -EFAULT;
 	}
@@ -6892,7 +6892,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 				ISP_RD32(CAM_REG_FBC_UFGO_CTL2(reg_module));
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
@@ -6903,7 +6903,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 	case ISP_IRQ_TYPE_INT_CAMSV_4_ST:
 	case ISP_IRQ_TYPE_INT_CAMSV_5_ST:
 	default:
-		LOG_NOTICE("Unsupport module:x%x\n", module);
+		LOG_DBG("Unsupport module:x%x\n", module);
 		return -EFAULT;
 	}
 
@@ -6914,7 +6914,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 	if (((fbc_ctrl2.Bits.WCNT + frmPeriod) & 63) ==
 		IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt) {
 		if (dmao_mask)
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			    "Cam:%d dma:%d ignore compensate wcnt_%d_%d\n",
 			    module, dma_id,
 			    IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt,
@@ -6932,7 +6932,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 
 	if (delta_wcnt > 255) {
 		if (dmao_mask)
-			LOG_NOTICE(
+			LOG_DBG(
 			    "ERROR: Cam:%d dma:%d WRONG WCNT:%d_%d_%d\n",
 			    module, dma_id, delta_wcnt,
 			    IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt,
@@ -6940,7 +6940,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 		return -EFAULT;
 	} else if (delta_wcnt > 6) {
 		if (dmao_mask)
-			LOG_NOTICE(
+			LOG_DBG(
 			    "WARNING: Cam:%d dma:%d SUSPICIOUS WCNT:%d_%d_%d\n",
 			    module, dma_id, delta_wcnt,
 			    IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt,
@@ -6973,7 +6973,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 					time_prev1.usec;
 	} else {
 		if (dmao_mask)
-			LOG_NOTICE(
+			LOG_DBG(
 			    "ERROR: Cam:%d dma:%d current timestamp: cur: %d.%06d prev1: %d.%06d\n",
 			    module, dma_id, sec, usec,
 			    time_prev1.sec, time_prev1.usec);
@@ -6987,7 +6987,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 					+ time_prev1.usec) - time_prev2.usec;
 	else {
 		if (dmao_mask)
-			LOG_NOTICE(
+			LOG_DBG(
 			    "ERROR: Cam:%d dma:%d previous timestamp: prev1: %d.%06d prev2: %d.%06d\n",
 			    module, dma_id, time_prev1.sec,
 			    time_prev1.usec, time_prev2.sec, time_prev2.usec);
@@ -6997,7 +6997,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 	if (delta_time > (max_delta_time / delta_wcnt)) {
 		if (dmao_mask)
 			IRQ_LOG_KEEPER(
-			    module, m_CurrentPPB, _LOG_INF,
+			    module, m_CurrentPPB, _LOG_DBG,
 			    "WARNING: Cam:%d dma:%d delta time too large: cur %dus max %dus patch wcnt: %d\n",
 			    module, dma_id, delta_time,
 			    max_delta_time, delta_wcnt);
@@ -7017,7 +7017,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 
 	if (dmao_mask)
 		IRQ_LOG_KEEPER(
-			module, m_CurrentPPB, _LOG_INF,
+			module, m_CurrentPPB, _LOG_DBG,
 			"Cam:%d dma:%d wcnt:%d_%d_%d T:%d.%06d_.%06d_%d.%06d\n",
 			module, dma_id, delta_wcnt,
 			IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt,
@@ -7027,7 +7027,7 @@ static int32_t ISP_CompensateMissingSofTime(enum ISP_DEV_NODE_ENUM reg_module,
 	if (IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt
 		!= fbc_ctrl2.Bits.WCNT) {
 		if (dmao_mask)
-			LOG_NOTICE(
+			LOG_DBG(
 			    "ERROR: Cam:%d dma:%d strange WCNT SW_HW: %d_%d\n",
 			    module,
 			    dma_id,
@@ -7065,14 +7065,14 @@ static int32_t ISP_PatchTimestamp(unsigned int module, unsigned int dma_id,
 	last_frm_dt = ((cur_tstp - prev_tstp) - frm_dt*(frmPeriod-1));
 
 	if (frm_dt == 0)
-		LOG_INF("WARNING: timestamp delta too small: %d\n",
+		LOG_DBG("WARNING: timestamp delta too small: %d\n",
 			(int)(cur_tstp - prev_tstp));
 
 	i = 0;
 	while (target_wridx != curr_wridx) {
 
 		if (i > frmPeriod) {
-			LOG_NOTICE(
+			LOG_DBG(
 			    "Error: too many intpl in sub-sample period %d_%d\n",
 			    target_wridx, curr_wridx);
 			return -EFAULT;
@@ -7228,7 +7228,7 @@ irqreturn_t ISP_Irq_CAMSV(
 
 	if ((IrqStatus & SV_HW_PASS1_DON_ST) && (IrqStatus & SV_SOF_INT_ST)) {
 		if (cur_v_cnt != sof_count[module])
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"isp sof_don block, %d_%d\n",
 				cur_v_cnt, sof_count[module]);
 	}
@@ -7247,7 +7247,7 @@ irqreturn_t ISP_Irq_CAMSV(
 			(unsigned int)(sec);
 
 		if (IspInfo.DebugMask & ISP_DBG_INT) {
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"%s P1_DON_%d(0x%08x_0x%08x) stamp[0x%08x]\n",
 				str,
 				(sof_count[module]) ?
@@ -7280,7 +7280,7 @@ irqreturn_t ISP_Irq_CAMSV(
 			}
 
 			IRQ_LOG_KEEPER(
-				module, m_CurrentPPB, _LOG_INF,
+				module, m_CurrentPPB, _LOG_DBG,
 				"%s P1_SOF_%d_%d(0x%08x_0x%08x,0x%08x),int_us:0x%08x, stamp[0x%08x]\n",
 				str,
 				sof_count[module], cur_v_cnt,
@@ -7300,7 +7300,7 @@ irqreturn_t ISP_Irq_CAMSV(
 			if (cur_v_cnt != ((ISP_RD32(
 				CAMSV_REG_TG_INTER_ST(reg_module))
 				& 0x00FF0000) >> 16))
-				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"SW ISR right on next hw p1_done\n");
 
 		}
@@ -7430,7 +7430,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 		cardinalNum = 2;
 		break;
 	default:
-		LOG_NOTICE("Wrong IRQ module: %d", (unsigned int)module);
+		LOG_DBG("Wrong IRQ module: %d", (unsigned int)module);
 		return IRQ_HANDLED;
 	}
 
@@ -7523,7 +7523,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 
 	if ((IrqStatus & HW_PASS1_DON_ST) && (IrqStatus & SOF_INT_ST)) {
 		if (cur_v_cnt != sof_count[module])
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			   "isp sof_don block, %d_%d\n",
 			   cur_v_cnt, sof_count[module]);
 	}
@@ -7531,7 +7531,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 	if ((IrqStatus & HW_PASS1_DON_ST) &&
 		(IspInfo.DebugMask & ISP_DBG_HW_DON)) {
 		IRQ_LOG_KEEPER(
-			module, m_CurrentPPB, _LOG_INF,
+			module, m_CurrentPPB, _LOG_DBG,
 			"CAM%c P1_HW_DON_%d\n",
 			'A'+cardinalNum,
 			(sof_count[module]) ?
@@ -7541,7 +7541,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 	spin_lock(&(IspInfo.SpinLockIrq[module]));
 	if (IrqStatus & VS_INT_ST) {
 		Vsync_cnt[cardinalNum]++;
-		/*LOG_INF("CAMA N3D:0x%x\n", Vsync_cnt[0]);*/
+		/*LOG_DBG("CAMA N3D:0x%x\n", Vsync_cnt[0]);*/
 	}
 	if (IrqStatus & SW_PASS1_DON_ST) {
 		sec = ktime_get(); /* ns */
@@ -7559,7 +7559,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 			/*SW p1_don is not reliable*/
 			if (FrameStatus[module] != CAM_FST_DROP_FRAME) {
 				IRQ_LOG_KEEPER(
-				  module, m_CurrentPPB, _LOG_INF,
+				  module, m_CurrentPPB, _LOG_DBG,
 				  "CAM%c P1_DON_%d(0x%x_0x%x,0x%x_0x%x)\n",
 				  'A'+cardinalNum,
 				  (sof_count[module]) ?
@@ -7637,7 +7637,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 
 		if (FrameStatus[module] == CAM_FST_DROP_FRAME) {
 			IRQ_LOG_KEEPER(
-				module, m_CurrentPPB, _LOG_INF,
+				module, m_CurrentPPB, _LOG_DBG,
 				"CAM%c Lost p1 done_%d (0x%x): ",
 				'A'+cardinalNum, sof_count[module],
 				cur_v_cnt);
@@ -7941,7 +7941,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 			#endif /* (TIMESTAMP_QUEUE_EN == 1) */
 
 			IRQ_LOG_KEEPER(
-			    module, m_CurrentPPB, _LOG_INF,
+			    module, m_CurrentPPB, _LOG_DBG,
 			    "CAM%c P1_SOF_%d_%d(0x%x_0x%x,0x%x_0x%x,0x%x,0x%x,0x%x),int_us:%d,cq:0x%x\n",
 			    'A'+cardinalNum, sof_count[module], cur_v_cnt,
 			    (unsigned int)(ISP_RD32(
@@ -7961,7 +7961,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 
 #ifdef ENABLE_STT_IRQ_LOG /*STT addr*/
 			IRQ_LOG_KEEPER(
-			    module, m_CurrentPPB, _LOG_INF,
+			    module, m_CurrentPPB, _LOG_DBG,
 			    "CAM%c_aa(0x%x_0x%x_0x%x)af(0x%x_0x%x_0x%x),pd(0x%x_0x%x_0x%x),ps(0x%x_0x%x_0x%x)\n",
 			    'A'+cardinalNum,
 			    ISP_RD32(CAM_REG_AAO_BASE_ADDR(reg_module)),
@@ -7992,7 +7992,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 			/* dbg information only */
 			if (cur_v_cnt !=
 			    ISP_RD32_TG_CAM_FRM_CNT(module, reg_module))
-				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"SW ISR right on next hw p1_done\n");
 
 		}
@@ -8017,7 +8017,7 @@ LB_CAM_SOF_IGNORE:
 #ifdef ENABLE_STT_IRQ_LOG
 	if (DmaStatus & (AAO_DONE_ST|AFO_DONE_ST|PDO_DONE_ST|PSO_DONE_ST)) {
 		IRQ_LOG_KEEPER(
-		    module, m_CurrentPPB, _LOG_INF,
+		    module, m_CurrentPPB, _LOG_DBG,
 		    "CAM%c_STT_Done_%d_0x%x\n",
 		    'A'+cardinalNum,
 		    (sof_count[module]) ?
@@ -8088,7 +8088,7 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 			    INT_ST_MASK_CAM_WARN) ||
 			    (g_ISPIntStatus_SMI[irq_module].ispInt3Err &
 			    INT_ST_MASK_CAM_WARN_2)) {
-				LOG_NOTICE(
+				LOG_DBG(
 				    "ERR:SMI_DUMP by module:%d\n", irq_module);
 				smi_debug_bus_hang_detect(false, ISP_DEV_NAME);
 			}
@@ -8097,7 +8097,7 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 				g_ISPIntStatus_SMI[irq_module].ispInt3Err = 0;
 		} else if (g_ISPIntStatus_SMI[irq_module].ispIntErr &
 		    CQ_VS_ERR_ST) {
-			LOG_NOTICE("ERR:SMI_DUMP by module:%d\n", irq_module);
+			LOG_DBG("ERR:SMI_DUMP by module:%d\n", irq_module);
 			smi_debug_bus_hang_detect(false, ISP_DEV_NAME);
 
 			g_ISPIntStatus_SMI[irq_module].ispIntErr =
@@ -8114,7 +8114,7 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 			SV_IMGO_ERR) {
 			if (g_ISPIntStatus_SMI[irq_module].ispIntErr &
 				SV_IMGO_OVERRUN) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ERR:SMI_DUMP by module:%d\n",
 					irq_module);
 				smi_debug_bus_hang_detect(false, ISP_DEV_NAME);
@@ -8124,60 +8124,60 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 		}
 		break;
 	default:
-		LOG_NOTICE("error:unsupported module:%d\n", irq_module);
+		LOG_DBG("error:unsupported module:%d\n", irq_module);
 		break;
 	}
 #endif
 }
 static void ISP_TaskletFunc_CAM_A(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_A_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_A_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAM_A_ST);
 }
 
 static void ISP_TaskletFunc_CAM_B(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_B_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_B_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAM_B_ST);
 }
 
 static void ISP_TaskletFunc_SV_0(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_0_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_0_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_0_ST);
 }
 
 static void ISP_TaskletFunc_SV_1(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_1_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_1_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_1_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_2(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_2_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_2_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_2_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_3(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_3_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_3_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_3_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_4(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_4_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_4_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_4_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_5(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_5_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_5_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_5_ST);
 
 }
@@ -8189,7 +8189,7 @@ static void ISP_BH_Workqueue(struct work_struct *pWork)
 		container_of(pWork, struct IspWorkqueTable, isp_bh_work);
 
 	IRQ_LOG_PRINTER(pWorkTable->module, m_CurrentPPB, _LOG_ERR);
-	IRQ_LOG_PRINTER(pWorkTable->module, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(pWorkTable->module, m_CurrentPPB, _LOG_DBG);
 }
 #endif
 
diff --git a/drivers/misc/mediatek/cameraisp/src/mt6785/cam_qos.c b/drivers/misc/mediatek/cameraisp/src/mt6785/cam_qos.c
index fa5db3117..7b309fa40 100644
--- a/drivers/misc/mediatek/cameraisp/src/mt6785/cam_qos.c
+++ b/drivers/misc/mediatek/cameraisp/src/mt6785/cam_qos.c
@@ -37,7 +37,7 @@
 #define ISP_DEBUG
 #ifdef ISP_DEBUG
 #define LOG_DBG(format, args...) \
-	pr_info(MyTag "[%s] " format, __func__, ##args)
+	pr_debug(MyTag "[%s] " format, __func__, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
@@ -66,7 +66,7 @@
 			ptr = &_gSVBW_LIST[module - \
 				ISP_IRQ_TYPE_INT_CAMSV_0_ST]; \
 		} else { \
-			LOG_NOTICE("sv idx violation , force to ke\n"); \
+			LOG_DBG("sv idx violation , force to ke\n"); \
 		} \
 		ptr; \
 	})
@@ -84,7 +84,7 @@
 			ptr = &_gSV_BW_REQ \
 				[module - ISP_IRQ_TYPE_INT_CAMSV_0_ST][port]; \
 		} else { \
-			LOG_NOTICE("sv idx violation , force to ke\n"); \
+			LOG_DBG("sv idx violation , force to ke\n"); \
 		} \
 		ptr; \
 	})
@@ -117,7 +117,7 @@ static u32 target_clk;
 			mm_qos_remove_all_request(gSVBW_LIST(module));
 			break;
 		default:
-			LOG_NOTICE("unsupported module:%d\n", module);
+			LOG_DBG("unsupported module:%d\n", module);
 			break;
 		}
 	}
@@ -137,7 +137,7 @@ static u32 target_clk;
 					SMI_SOC0);
 				break;
 			default:
-				LOG_NOTICE("unsupported port:%d\n", portID);
+				LOG_DBG("unsupported port:%d\n", portID);
 				break;
 			}
 			break;
@@ -151,14 +151,14 @@ static u32 target_clk;
 						SMI_SOC1);
 					break;
 				default:
-					LOG_NOTICE("unsupported port:%d\n",
+					LOG_DBG("unsupported port:%d\n",
 						portID);
 					break;
 				}
 				break;
 		case ISP_IRQ_TYPE_INT_CAMSV_4_ST: /* FALLTHROUGH */
 		case ISP_IRQ_TYPE_INT_CAMSV_5_ST:
-				LOG_NOTICE("unsupported module:%d\n", module);
+				LOG_DBG("unsupported module:%d\n", module);
 				break;
 		default:
 				switch (portID) {
@@ -267,7 +267,7 @@ static u32 target_clk;
 						SMI_LSCI_2);
 						break;
 					default:
-						LOG_NOTICE(
+						LOG_DBG(
 							"unsupported module:%d\n",
 							module);
 						break;
@@ -284,7 +284,7 @@ static u32 target_clk;
 						SMI_PDI);
 					break;
 				default:
-					LOG_NOTICE("unsupported port:%d\n",
+					LOG_DBG("unsupported port:%d\n",
 						portID);
 					break;
 				}
@@ -327,7 +327,7 @@ static u32 target_clk;
 					bw.avg, bw.peak, BW_COMP_NONE);
 				break;
 			default:
-				LOG_NOTICE("unsupported port:%d\n", portID);
+				LOG_DBG("unsupported port:%d\n", portID);
 				break;
 			}
 			break;
@@ -344,12 +344,12 @@ static u32 target_clk;
 					bw.avg, bw.peak, BW_COMP_DEFAULT);
 				break;
 			default:
-				LOG_NOTICE("unsupported port:%d\n", portID);
+				LOG_DBG("unsupported port:%d\n", portID);
 				break;
 			}
 			break;
 		default:
-			LOG_NOTICE("unsupported module:%d\n", module);
+			LOG_DBG("unsupported module:%d\n", module);
 			break;
 		}
 	}
@@ -372,7 +372,7 @@ static u32 target_clk;
 			mm_qos_update_all_request(gSVBW_LIST(module));
 			break;
 		default:
-			LOG_NOTICE("unsupported module:%d\n", module);
+			LOG_DBG("unsupported module:%d\n", module);
 			break;
 		}
 	}
@@ -402,7 +402,7 @@ static u32 target_clk;
 			mm_qos_update_all_request_zero(gSVBW_LIST(module));
 			break;
 		default:
-			LOG_NOTICE("unsupported module:%d\n", module);
+			LOG_DBG("unsupported module:%d\n", module);
 			break;
 		}
 	}
@@ -438,55 +438,55 @@ static u32 target_clk;
 	inline void mtk_pmqos_remove(
 			enum ISP_IRQ_TYPE_ENUM module)
 	{
-		LOG_NOTICE("MTK_SET_PM_QOS is not supported\n");
+		LOG_DBG("MTK_SET_PM_QOS is not supported\n");
 	}
 	inline void mtk_pmqos_add(
 		enum ISP_IRQ_TYPE_ENUM module,
 		u32 portID)
 	{
-		LOG_NOTICE("MTK_SET_PM_QOS is not supported\n");
+		LOG_DBG("MTK_SET_PM_QOS is not supported\n");
 	}
 	inline void mtk_pmqos_set(
 		enum ISP_IRQ_TYPE_ENUM module,
 		u32 portID,
 		struct ISP_BW bw)
 	{
-		LOG_NOTICE("MTK_SET_PM_QOS is not supported\n");
+		LOG_DBG("MTK_SET_PM_QOS is not supported\n");
 	}
 	inline void mtk_pmqos_update(
 		enum ISP_IRQ_TYPE_ENUM module)
 	{
-		LOG_NOTICE("MTK_SET_PM_QOS is not supported\n");
+		LOG_DBG("MTK_SET_PM_QOS is not supported\n");
 	}
 	inline void mtk_pmqos_clr(
 		enum ISP_IRQ_TYPE_ENUM module)
 	{
-		LOG_NOTICE("MTK_SET_PM_QOS is not supported\n");
+		LOG_DBG("MTK_SET_PM_QOS is not supported\n");
 	}
 
 	inline void mtk_dfs_add(void)
 	{
 		//mmdvfs_pm_qos_add_request(&isp_qos,
 		//	MMDVFS_PM_QOS_SUB_SYS_CAMERA, 0);
-		LOG_NOTICE("mmdvfs_pm_qos_add_request is not supported\n");
+		LOG_DBG("mmdvfs_pm_qos_add_request is not supported\n");
 	}
 	inline void mtk_dfs_remove(void)
 	{
 		//mmdvfs_pm_qos_remove_request(&isp_qos);
-		LOG_NOTICE("mtk_dfs_remove is not supported\n");
+		LOG_DBG("mtk_dfs_remove is not supported\n");
 	}
 	inline void mtk_dfs_clr(void)
 	{
 		//mmdvfs_pm_qos_update_request(&isp_qos,
 		//	MMDVFS_PM_QOS_SUB_SYS_CAMERA, 0);
-		LOG_NOTICE("mtk_dfs_clr is not supported\n");
+		LOG_DBG("mtk_dfs_clr is not supported\n");
 	}
 	inline void mtk_dfs_set(void) {}
 	inline void mtk_dfs_update(u32 clk)
 	{
 		//mmdvfs_pm_qos_update_request(&isp_qos,
 		//	MMDVFS_PM_QOS_SUB_SYS_CAMERA, clk);
-		LOG_NOTICE("mtk_dfs_update is not supported\n");
+		LOG_DBG("mtk_dfs_update is not supported\n");
 	}
 	inline void mtk_dfs_supported(u64 *frq, u32 *step)
 	{
@@ -496,13 +496,13 @@ static u32 target_clk;
 		//	frq[lv] = mmdvfs_qos_get_thres_value(&isp_qos,
 		//		MMDVFS_PM_QOS_SUB_SYS_CAMERA, lv);
 		//}
-		LOG_NOTICE("mtk_dfs_supported is not supported\n");
+		LOG_DBG("mtk_dfs_supported is not supported\n");
 	}
 	inline unsigned int mtk_dfs_cur(void)
 	{
 		//return mmdvfs_qos_get_cur_thres(&isp_qos,
 		//	MMDVFS_PM_QOS_SUB_SYS_CAMERA);
-		LOG_NOTICE("mtk_dfs_cur is not supported\n");
+		LOG_DBG("mtk_dfs_cur is not supported\n");
 	}
 #endif
 
@@ -515,14 +515,14 @@ int ISP_SetPMQOS(
 	int Ret = 0;
 
 	if (module > ISP_IRQ_TYPE_INT_CAM_C_ST) {
-		LOG_NOTICE("supported only to CAM_C\n");
+		LOG_DBG("supported only to CAM_C\n");
 		return 1;
 	}
 
 	switch (cmd) {
 	case E_BW_REMOVE:
 		mtk_pmqos_remove(module);
-		LOG_INF("PM_QOS:module:%d,OFF\n", module);
+		LOG_DBG("PM_QOS:module:%d,OFF\n", module);
 		break;
 	case E_BW_ADD:
 		{
@@ -533,7 +533,7 @@ int ISP_SetPMQOS(
 			for (; i < _cam_max_; i++)
 				mtk_pmqos_add(module, i);
 
-			LOG_INF("PM_QOS:module:%d,ON\n", module);
+			LOG_DBG("PM_QOS:module:%d,ON\n", module);
 		}
 		break;
 	case E_BW_UPDATE:
@@ -554,20 +554,20 @@ int ISP_SetPMQOS(
 	case E_BW_CLR:
 		if (pvalue[0] == MFALSE) {
 			mtk_pmqos_clr(module);
-			LOG_INF("module:%d bw_clr\n", module);
+			LOG_DBG("module:%d bw_clr\n", module);
 		}
 		break;
 	case E_CLK_ADD:
 		mtk_dfs_add();
-		LOG_INF("DFS_add\n");
+		LOG_DBG("DFS_add\n");
 		break;
 	case E_CLK_REMOVE:
 		mtk_dfs_remove();
-		LOG_INF("DFS_remove\n");
+		LOG_DBG("DFS_remove\n");
 		break;
 	case E_CLK_CLR:
 		mtk_dfs_clr();
-		LOG_INF("DFS_clr\n");
+		LOG_DBG("DFS_clr\n");
 		break;
 	case E_CLK_UPDATE:
 		mtk_dfs_set();
@@ -609,7 +609,7 @@ int ISP_SetPMQOS(
 		break;
 	case E_QOS_UNKNOWN:
 	default:
-		LOG_NOTICE("unsupport cmd:%d", cmd);
+		LOG_DBG("unsupport cmd:%d", cmd);
 		Ret = -1;
 		break;
 	}
@@ -627,14 +627,14 @@ int SV_SetPMQOS(
 
 	if ((module < ISP_IRQ_TYPE_INT_CAMSV_0_ST) &&
 		(module > ISP_IRQ_TYPE_INT_CAMSV_5_ST)) {
-		LOG_NOTICE("supported only to SV0 to SV5\n");
+		LOG_DBG("supported only to SV0 to SV5\n");
 		return 1;
 	}
 
 	switch (cmd) {
 	case E_BW_REMOVE:
 		mtk_pmqos_remove(module);
-		LOG_INF("PM_QOS:module:%d,OFF\n", module);
+		LOG_DBG("PM_QOS:module:%d,OFF\n", module);
 		break;
 	case E_BW_ADD:
 		{
@@ -665,7 +665,7 @@ int SV_SetPMQOS(
 	case E_BW_CLR:
 		if (pvalue[0] == MFALSE) {
 			mtk_pmqos_clr(module);
-		    LOG_INF("module:%d BW_clr\n", module);
+		    LOG_DBG("module:%d BW_clr\n", module);
 		}
 		break;
 	case E_QOS_UNKNOWN:
@@ -676,7 +676,7 @@ int SV_SetPMQOS(
 	case E_CLK_SUPPORTED:
 	case E_CLK_CUR:
 	default:
-		LOG_NOTICE("unsupport cmd:%d", cmd);
+		LOG_DBG("unsupport cmd:%d", cmd);
 		Ret = -1;
 		break;
 	}
diff --git a/drivers/misc/mediatek/cameraisp/src/mt6785/camera_isp.c b/drivers/misc/mediatek/cameraisp/src/mt6785/camera_isp.c
index a64cdf3ea..1fd9115d2 100644
--- a/drivers/misc/mediatek/cameraisp/src/mt6785/camera_isp.c
+++ b/drivers/misc/mediatek/cameraisp/src/mt6785/camera_isp.c
@@ -122,7 +122,7 @@
 	 __func__, ##args)
 #define ISP_DEBUG
 #ifdef ISP_DEBUG
-#define LOG_DBG(format, args...)    pr_info(MyTag "[%s] " format, \
+#define LOG_DBG(format, args...)    pr_debug(MyTag "[%s] " format, \
 	 __func__, ##args)
 #else
 #define LOG_DBG(format, args...)
@@ -747,15 +747,15 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 			gSvLog[irq]._lastIrqTime.sec, \
 			gSvLog[irq]._lastIrqTime.usec, \
 			##__VA_ARGS__) < 0) {\
-			LOG_NOTICE("[Error] %s: snprintf failed", __func__);\
+			LOG_DBG("[Error] %s: snprintf failed", __func__);\
 		} \
 		if ('\0' != gSvLog[irq]._str[\
 			ppb][logT][str_leng - 1]) \
-			LOG_NOTICE("log str over flow(%d)", irq); \
+			LOG_DBG("log str over flow(%d)", irq); \
 		while (*ptr++ != '\0') \
 			(*ptr2)++; \
 	} else { \
-		LOG_INF("(%d)(%d)log str avalible=0, print log\n", \
+		LOG_DBG("(%d)(%d)log str avalible=0, print log\n", \
 			 irq, logT); \
 		ptr = pSrc->_str[ppb][logT]; \
 		if (pSrc->_cnt[ppb][logT] != 0) { \
@@ -793,16 +793,16 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 						'\0') { \
 						ptr[NORMAL_STR_LEN*(i+1) - 1] =\
 						'\0'; \
-						LOG_NOTICE("%s", &ptr[\
+						LOG_DBG("%s", &ptr[\
 							NORMAL_STR_LEN*i]); \
 					} else { \
-						LOG_NOTICE("%s", &ptr[\
+						LOG_DBG("%s", &ptr[\
 							NORMAL_STR_LEN*i]); \
 						break; \
 					} \
 				} \
 			} else { \
-				LOG_NOTICE("N.S.%d", logT); \
+				LOG_DBG("N.S.%d", logT); \
 			} \
 			ptr[0] = '\0'; \
 			pSrc->_cnt[ppb][logT] = 0; \
@@ -812,7 +812,7 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 			ptr2 = &(pSrc->_cnt[ppb][logT]); \
 			if (snprintf((char *)(pDes), avaLen,\
 					fmt, ##__VA_ARGS__) < 0) {\
-				LOG_NOTICE("[Error] %s: snprintf failed",\
+				LOG_DBG("[Error] %s: snprintf failed",\
 					   __func__);\
 			} \
 			while (*ptr++ != '\0') \
@@ -877,16 +877,16 @@ static struct SV_LOG_STR gSvLog[ISP_IRQ_TYPE_AMOUNT];
 						ptr[\
 						NORMAL_STR_LEN*(i+1) - 1] = \
 						'\0'; \
-						LOG_NOTICE("%s", \
+						LOG_DBG("%s", \
 						&ptr[NORMAL_STR_LEN*i]); \
 					} else{ \
-						LOG_NOTICE("%s", \
+						LOG_DBG("%s", \
 						&ptr[NORMAL_STR_LEN*i]); \
 						break; \
 					} \
 				} \
 			} else { \
-				LOG_NOTICE("N.S.%d", logT); \
+				LOG_DBG("N.S.%d", logT); \
 			} \
 			ptr[0] = '\0'; \
 			pSrc->_cnt[ppb][logT] = 0; \
@@ -953,7 +953,7 @@ int MET_Event_Get_BPP(enum _isp_dma_enum_ dmao,
 			ret = 14;
 			break;
 		default:
-			LOG_NOTICE("get imgo bpp error fmt_sel:0x%x value=%x\n",
+			LOG_DBG("get imgo bpp error fmt_sel:0x%x value=%x\n",
 				fmt_sel, (fmt_sel >> 4) & 0x1F);
 			break;
 		}
@@ -969,7 +969,7 @@ int MET_Event_Get_BPP(enum _isp_dma_enum_ dmao,
 			ret = 12;
 			break;
 		default:
-			LOG_NOTICE("get rrzo bpp error fmt_sel:0x%x value=%x\n",
+			LOG_DBG("get rrzo bpp error fmt_sel:0x%x value=%x\n",
 				fmt_sel, (fmt_sel >> 2) & 0x3);
 			break;
 		}
@@ -1100,7 +1100,7 @@ static int32_t ISP_GetWaitQCamIndex(enum ISP_IRQ_TYPE_ENUM type)
 	int32_t index = type - ISP_IRQ_TYPE_INT_CAM_A_ST;
 
 	if (index >= CAM_AMOUNT)
-		pr_info("waitq cam index out of range:%d", index);
+		pr_debug("waitq cam index out of range:%d", index);
 
 	return index;
 }
@@ -1113,7 +1113,7 @@ static int32_t ISP_GetWaitQCamsvIndex(enum ISP_IRQ_TYPE_ENUM type)
 	int32_t index = type - ISP_IRQ_TYPE_INT_CAMSV_0_ST;
 
 	if (index >= CAMSV_AMOUNT)
-		pr_info("waitq camsv index out of range:%d", index);
+		pr_debug("waitq camsv index out of range:%d", index);
 
 	return index;
 }
@@ -1143,7 +1143,7 @@ static int32_t ISP_GetWaitQCamIrqIndex(
 	}
 
 	if (index == ISP_WAITQ_HEAD_IRQ_AMOUNT)
-		pr_info("waitq cam irq index out of range:%d_%d",
+		pr_debug("waitq cam irq index out of range:%d_%d",
 				st_type, status);
 
 	return index;
@@ -1165,7 +1165,7 @@ static int32_t ISP_GetWaitQCamsvIrqIndex(
 	}
 
 	if (index == ISP_WAITQ_HEAD_IRQ_SV_AMOUNT)
-		pr_info("waitq camsv irq index out of range:%d_%d",
+		pr_debug("waitq camsv irq index out of range:%d_%d",
 				st_type, status);
 
 	return index;
@@ -1247,7 +1247,7 @@ static void ISP_DumpDmaDeepDbg(enum ISP_IRQ_TYPE_ENUM module)
 		strncpy(cam, "CAM_C", sizeof("CAM_C"));
 		break;
 	default:
-		LOG_NOTICE("unsupported module:0x%x\n", module);
+		LOG_DBG("unsupported module:0x%x\n", module);
 		return;
 	}
 
@@ -1416,38 +1416,38 @@ static inline void Prepare_Enable_ccf_clock(void)
 	 */
 
 	#ifndef EP_MARK_SMI /* enable through smi API */
-	LOG_INF("enable CG/MTCMOS through SMI CLK API\n");
+	LOG_DBG("enable CG/MTCMOS through SMI CLK API\n");
 	smi_bus_prepare_enable(SMI_LARB6, ISP_DEV_NAME);
 	smi_bus_prepare_enable(SMI_LARB7, ISP_DEV_NAME);
 	#endif
 
 	ret = clk_prepare_enable(isp_clk.ISP_SCP_SYS_DIS);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_SCP_SYS_DIS clock\n");
+		LOG_DBG("cannot pre-en ISP_SCP_SYS_DIS clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_SCP_SYS_ISP);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_SCP_SYS_ISP clock\n");
+		LOG_DBG("cannot pre-en ISP_SCP_SYS_ISP clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_SCP_SYS_CAM);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_SCP_SYS_CAM clock\n");
+		LOG_DBG("cannot pre-en ISP_SCP_SYS_CAM clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSYS);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSYS clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSYS clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMTG);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMTG clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMTG clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSV0);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSV0 clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSV0 clock\n");
 
 	ret = clk_prepare_enable(isp_clk.ISP_CAM_CAMSV1);
 	if (ret)
-		LOG_NOTICE("cannot pre-en ISP_CAM_CAMSV1 clock\n");
+		LOG_DBG("cannot pre-en ISP_CAM_CAMSV1 clock\n");
 
 
 }
@@ -1469,7 +1469,7 @@ static inline void Disable_Unprepare_ccf_clock(void)
 	clk_disable_unprepare(isp_clk.ISP_SCP_SYS_DIS);
 
 	#ifndef EP_MARK_SMI
-	LOG_INF("disable CG/MTCMOS through SMI CLK API\n");
+	LOG_DBG("disable CG/MTCMOS through SMI CLK API\n");
 	smi_bus_disable_unprepare(SMI_LARB6, ISP_DEV_NAME);
 	smi_bus_disable_unprepare(SMI_LARB7, ISP_DEV_NAME);
 	#endif
@@ -1488,7 +1488,7 @@ void ISP_Halt_Mask(unsigned int isphaltMask)
 
 	ISP_WR32(ISP_CAMSYS_CONFIG_BASE + 0x120, setReg);
 
-	LOG_INF("ISP halt_en for dvfs:0x%x\n",
+	LOG_DBG("ISP halt_en for dvfs:0x%x\n",
 		ISP_RD32(ISP_CAMSYS_CONFIG_BASE + 0x120));
 }
 EXPORT_SYMBOL(ISP_Halt_Mask);
@@ -1593,7 +1593,7 @@ static void ISP_EnableClock(bool En)
 		G_u4EnableClockCount++;
 		spin_unlock(&(IspInfo.SpinLockClock));
 #else/*CCF*/
-		/*LOG_INF("CCF:prepare_enable clk");*/
+		/*LOG_DBG("CCF:prepare_enable clk");*/
 		spin_lock(&(IspInfo.SpinLockClock));
 		G_u4EnableClockCount++;
 		spin_unlock(&(IspInfo.SpinLockClock));
@@ -1604,7 +1604,7 @@ static void ISP_EnableClock(bool En)
 		 * To avoid ISP halt keep arise
 		 */
 		#if 1/* ALSK TBD */
-		LOG_INF(
+		LOG_DBG(
 		"###### NEED UPDATE CAMSYS_HALT1_EN: LSCI & BPCI SETTING #######");
 		#else
 		ISP_WR32(ISP_CAMSYS_CONFIG_BASE + 0x120, 0xFFFFFF4F);
@@ -1630,11 +1630,11 @@ static void ISP_EnableClock(bool En)
 		}
 		spin_unlock(&(IspInfo.SpinLockClock));
 #else
-		/*LOG_INF("CCF:disable_unprepare clk\n");*/
+		/*LOG_DBG("CCF:disable_unprepare clk\n");*/
 		spin_lock(&(IspInfo.SpinLockClock));
 		if (G_u4EnableClockCount == 0) {
 			spin_unlock(&(IspInfo.SpinLockClock));
-			LOG_INF(
+			LOG_DBG(
 			"G_u4EnableClockCount aleady be 0, do nothing\n");
 			return;
 		}
@@ -1724,7 +1724,7 @@ static inline void ISP_Reset(int module)
 		break;
 	}
 	default:
-		LOG_NOTICE("Not support reset module:%d\n", module);
+		LOG_DBG("Not support reset module:%d\n", module);
 		break;
 	}
 }
@@ -1745,7 +1745,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 	if ((pRegIo->pData == NULL) ||
 		(pRegIo->Count == 0) ||
 		(pRegIo->Count > ISP_REG_RANGE)) {
-		LOG_NOTICE("pRegIo->pData is NULL, Count:%d!!\n",
+		LOG_DBG("pRegIo->pData is NULL, Count:%d!!\n",
 			pRegIo->Count);
 		Ret = -EFAULT;
 		goto EXIT;
@@ -1766,7 +1766,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 
 	if (copy_from_user(pReg, (void __user *)pRegIo->pData,
 		sizeof(struct ISP_REG_STRUCT) * pRegIo->Count) != 0) {
-		LOG_NOTICE("copy_from_user failed\n");
+		LOG_DBG("copy_from_user failed\n");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1803,7 +1803,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 		regBase = ISP_CAM_UNI_BASE;
 		break;
 	default:
-		LOG_NOTICE("Unsupported module(%x)!!!\n", pReg->module);
+		LOG_DBG("Unsupported module(%x)!!!\n", pReg->module);
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1819,7 +1819,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 			(regBase + ispRange)) {
 			pTmp->Val = ISP_RD32(regBase + pTmp->Addr);
 		} else {
-			LOG_NOTICE("Wrong address(0x%lx)\n",
+			LOG_DBG("Wrong address(0x%lx)\n",
 				(unsigned long)(regBase + pTmp->Addr));
 			pTmp->Val = 0;
 		}
@@ -1830,7 +1830,7 @@ static int ISP_ReadReg(struct ISP_REG_IO_STRUCT *pRegIo)
 
 	if (copy_to_user((void __user *)pRegIo->pData, pReg,
 		sizeof(struct ISP_REG_STRUCT) * pRegIo->Count) != 0) {
-		LOG_NOTICE("copy to user fail");
+		LOG_DBG("copy to user fail");
 		Ret = -EFAULT;
 	}
 EXIT:
@@ -1897,7 +1897,7 @@ static int ISP_WriteRegToHw(
 		regBase = ISP_CAM_UNI_BASE;
 		break;
 	default:
-		LOG_NOTICE("Unsupported module(%x) !!!\n",
+		LOG_DBG("Unsupported module(%x) !!!\n",
 			pReg->module);
 		return -EFAULT;
 	}
@@ -1924,7 +1924,7 @@ static int ISP_WriteRegToHw(
 		if (((regBase + pReg[i].Addr) < (regBase + ispRange)))
 			ISP_WR32(regBase + pReg[i].Addr, pReg[i].Val);
 		else
-			LOG_NOTICE("wrong address(0x%lx)\n",
+			LOG_DBG("wrong address(0x%lx)\n",
 				(unsigned long)(regBase + pReg[i].Addr));
 
 	}
@@ -1942,7 +1942,7 @@ static int ISP_WriteReg(struct ISP_REG_IO_STRUCT *pRegIo)
 	struct ISP_REG_STRUCT *pData = NULL;
 
 	if (pRegIo->Count > 0xFFFFFFFF) {
-		LOG_NOTICE("pRegIo->Count error");
+		LOG_DBG("pRegIo->Count error");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -1963,14 +1963,14 @@ static int ISP_WriteReg(struct ISP_REG_IO_STRUCT *pRegIo)
 		goto EXIT;
 	}
 	if ((void __user *)(pRegIo->pData) == NULL) {
-		LOG_NOTICE("NULL pData");
+		LOG_DBG("NULL pData");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
 	/*  */
 	if (copy_from_user(pData, (void __user *)(pRegIo->pData),
 		  pRegIo->Count * sizeof(struct ISP_REG_STRUCT)) != 0) {
-		LOG_NOTICE("copy_from_user failed\n");
+		LOG_DBG("copy_from_user failed\n");
 		Ret = -EFAULT;
 		goto EXIT;
 	}
@@ -2022,7 +2022,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 
 	/*  */
 	if ((void __user *)Param == NULL) {
-		LOG_NOTICE("[rtbc]NULL Param");
+		LOG_DBG("[rtbc]NULL Param");
 		return -EFAULT;
 	}
 	/*  */
@@ -2032,13 +2032,13 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 
 		if (rt_buf_ctrl.module >= ISP_IRQ_TYPE_AMOUNT ||
 		    rt_buf_ctrl.module < 0) {
-			LOG_NOTICE("[rtbc]not supported	module:0x%x\n",
+			LOG_DBG("[rtbc]not supported	module:0x%x\n",
 				rt_buf_ctrl.module);
 			return -EFAULT;
 		}
 
 		if (pstRTBuf[rt_buf_ctrl.module] == NULL)  {
-			LOG_NOTICE("[rtbc]NULL pstRTBuf, module:0x%x\n",
+			LOG_DBG("[rtbc]NULL pstRTBuf, module:0x%x\n",
 				rt_buf_ctrl.module);
 			return -EFAULT;
 		}
@@ -2046,7 +2046,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 		rt_dma = rt_buf_ctrl.buf_id;
 		if (rt_dma >= _cam_max_ ||
 		    rt_dma < 0) {
-			LOG_NOTICE("[rtbc]buf_id error:0x%x\n",
+			LOG_DBG("[rtbc]buf_id error:0x%x\n",
 				rt_dma);
 			return -EFAULT;
 		}
@@ -2056,7 +2056,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 		case ISP_RT_BUF_CTRL_CLEAR:
 			/*  */
 			if (IspInfo.DebugMask & ISP_DBG_BUF_CTRL)
-				LOG_INF("[rtbc][%d][CLEAR]:rt_dma(%d)\n",
+				LOG_DBG("[rtbc][%d][CLEAR]:rt_dma(%d)\n",
 					rt_buf_ctrl.module, rt_dma);
 			/*  */
 
@@ -2180,7 +2180,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 					rt_buf_ctrl.module]->state = 0;
 				break;
 			default:
-				LOG_NOTICE("unsupported module:0x%x\n",
+				LOG_DBG("unsupported module:0x%x\n",
 					rt_buf_ctrl.module);
 				break;
 			}
@@ -2196,7 +2196,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 			unsigned char *pExt;
 
 			if (rt_buf_ctrl.pExtend == NULL) {
-				LOG_NOTICE("NULL pExtend");
+				LOG_DBG("NULL pExtend");
 				Ret = -EFAULT;
 				break;
 			}
@@ -2211,12 +2211,12 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 							z].active = array[z];
 					if (IspInfo.DebugMask &
 							ISP_DBG_BUF_CTRL) {
-						LOG_INF(
+						LOG_DBG(
 							"[rtbc][DMA_EN]:dma_%d:%d",
 							z, array[z]);
 					}
 				} else {
-					LOG_NOTICE(
+					LOG_DBG(
 						"[rtbc][DMA_EN]:get_user failed(%d)",
 						z);
 					Ret = -EFAULT;
@@ -2232,7 +2232,7 @@ static long ISP_Buf_CTRL_FUNC(unsigned long Param)
 
 		}
 	} else {
-		LOG_NOTICE("[rtbc]copy_from_user failed");
+		LOG_DBG("[rtbc]copy_from_user failed");
 		Ret = -EFAULT;
 	}
 
@@ -2249,12 +2249,12 @@ static int ISP_REGISTER_IRQ_USERKEY(char *userName)
 	int length = 0;
 
 	if (userName == NULL) {
-		LOG_NOTICE("userName is NULL\n");
+		LOG_DBG("userName is NULL\n");
 	} else {
 		/* get UserName from user space */
 		length = strnlen(userName, USERKEY_STR_LEN);
 		if (length == 0) {
-			LOG_NOTICE("userName address is not valid\n");
+			LOG_DBG("userName address is not valid\n");
 			return key;
 		}
 
@@ -2273,7 +2273,7 @@ static int ISP_REGISTER_IRQ_USERKEY(char *userName)
 		}
 
 		if (IspInfo.DebugMask & ISP_DBG_INT)
-			pr_info(" [regUser] UserName (%s)\n", userName);
+			pr_debug(" [regUser] UserName (%s)\n", userName);
 
 		/* 1. check the current users is full or not */
 		if (FirstUnusedIrqUserKey >= IRQ_USER_NUM_MAX ||
@@ -2316,7 +2316,7 @@ static int ISP_REGISTER_IRQ_USERKEY(char *userName)
 
 		spin_unlock((spinlock_t *)(&SpinLock_UserKey));
 	}
-	LOG_INF("User(%s)key(%d)\n", userName, key);
+	LOG_DBG("User(%s)key(%d)\n", userName, key);
 	return key;
 }
 
@@ -2329,27 +2329,27 @@ static int ISP_FLUSH_IRQ(struct ISP_WAIT_IRQ_STRUCT *irqinfo)
 	/* FIX to avoid build warning*/
 	unsigned long flags;
 
-	LOG_INF("type(%d)userKey(%d)St_type(%d)St(0x%x)",
+	LOG_DBG("type(%d)userKey(%d)St_type(%d)St(0x%x)",
 		irqinfo->Type, irqinfo->EventInfo.UserKey,
 		irqinfo->EventInfo.St_type,
 		irqinfo->EventInfo.Status);
 
 	if (irqinfo->Type >= ISP_IRQ_TYPE_AMOUNT ||
 	    irqinfo->Type < 0) {
-		LOG_NOTICE("FLUSH_IRQ: type error(%d)", irqinfo->Type);
+		LOG_DBG("FLUSH_IRQ: type error(%d)", irqinfo->Type);
 		return -EFAULT;
 	}
 
 	if (irqinfo->EventInfo.St_type >= ISP_IRQ_ST_AMOUNT ||
 	    irqinfo->EventInfo.St_type < 0) {
-		LOG_NOTICE("FLUSH_IRQ: st_type error(%d)",
+		LOG_DBG("FLUSH_IRQ: st_type error(%d)",
 			irqinfo->EventInfo.St_type);
 		return -EFAULT;
 	}
 
 	if (irqinfo->EventInfo.UserKey >= IRQ_USER_NUM_MAX ||
 	    irqinfo->EventInfo.UserKey < 0) {
-		LOG_NOTICE("FLUSH_IRQ: userkey error(%d)",
+		LOG_DBG("FLUSH_IRQ: userkey error(%d)",
 			irqinfo->EventInfo.UserKey);
 		return -EFAULT;
 	}
@@ -2362,7 +2362,7 @@ static int ISP_FLUSH_IRQ(struct ISP_WAIT_IRQ_STRUCT *irqinfo)
 		irqinfo->EventInfo.Status;
 	spin_unlock_irqrestore(&(IspInfo.SpinLockIrq[irqinfo->Type]), flags);
 
-	LOG_INF("FLUSH_IRQ: IrqInfo.Status=0x%x",
+	LOG_DBG("FLUSH_IRQ: IrqInfo.Status=0x%x",
 		IspInfo.IrqInfo.Status[irqinfo->Type][
 		irqinfo->EventInfo.St_type][
 		irqinfo->EventInfo.UserKey]);
@@ -2420,21 +2420,21 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 
 	if (WaitIrq->Type >= ISP_IRQ_TYPE_AMOUNT ||
 	    WaitIrq->Type < 0) {
-		LOG_NOTICE("WaitIrq: type error(%d)",
+		LOG_DBG("WaitIrq: type error(%d)",
 			WaitIrq->Type);
 		return -EFAULT;
 	}
 
 	if (WaitIrq->EventInfo.St_type >= ISP_IRQ_ST_AMOUNT ||
 	    WaitIrq->EventInfo.St_type < 0) {
-		LOG_NOTICE("WaitIrq: st_type error(%d)",
+		LOG_DBG("WaitIrq: st_type error(%d)",
 			WaitIrq->EventInfo.St_type);
 		return -EFAULT;
 	}
 
 	if (WaitIrq->EventInfo.UserKey >= IRQ_USER_NUM_MAX ||
 	    WaitIrq->EventInfo.UserKey < 0) {
-		LOG_NOTICE("WaitIrq: userkey error(%d)",
+		LOG_DBG("WaitIrq: userkey error(%d)",
 			WaitIrq->EventInfo.UserKey);
 		return -EFAULT;
 	}
@@ -2463,7 +2463,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 	if (WaitIrq->EventInfo.Clear ==
 		ISP_IRQ_CLEAR_STATUS) {
 		if (log_on)
-			LOG_NOTICE("+ [1]update status\n");
+			LOG_DBG("+ [1]update status\n");
 		spin_lock_irqsave(&(IspInfo.SpinLockIrq[
 			WaitIrq->Type]), flags);
 
@@ -2480,13 +2480,13 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 			IspInfo.SpinLockIrq[
 				WaitIrq->Type]), flags);
 		if (log_on)
-			LOG_NOTICE("- [1]update status\n");
+			LOG_DBG("- [1]update status\n");
 		return Ret;
 	}
 
 	{
 		if (log_on)
-			LOG_NOTICE("+ check status\n");
+			LOG_DBG("+ check status\n");
 		spin_lock_irqsave(&(
 			IspInfo.SpinLockIrq[WaitIrq->Type]), flags);
 
@@ -2498,7 +2498,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 				IspInfo.SpinLockIrq[
 					WaitIrq->Type]), flags);
 			if (log_on)
-				LOG_NOTICE("- check status\n");
+				LOG_DBG("- check status\n");
 			/* force to be non_clear wait if marked before
 			 * and check the request wait timing
 			 */
@@ -2530,23 +2530,23 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 			/* Sig                                            Sig */
 			/*  */
 			if (log_on)
-				LOG_NOTICE("+ get freeze_passbysigcnt\n");
+				LOG_DBG("+ get freeze_passbysigcnt\n");
 			freeze_passbysigcnt = !(ISP_GetIRQState(WaitIrq->Type,
 				WaitIrq->EventInfo.St_type,
 				WaitIrq->EventInfo.UserKey,
 				WaitIrq->EventInfo.Status));
 			if (log_on)
-				LOG_NOTICE("- get freeze_passbysigcnt\n");
+				LOG_DBG("- get freeze_passbysigcnt\n");
 		} else {
 			spin_unlock_irqrestore(&(
 				IspInfo.SpinLockIrq[
 					WaitIrq->Type]), flags);
 			if (log_on)
-				LOG_NOTICE("- check status[2]\n");
+				LOG_DBG("- check status[2]\n");
 
 			if (WaitIrq->EventInfo.Clear == ISP_IRQ_CLEAR_WAIT) {
 				if (log_on)
-					LOG_NOTICE("+ [2]update status\n");
+					LOG_DBG("+ [2]update status\n");
 
 				spin_lock_irqsave(&(IspInfo.SpinLockIrq[
 					WaitIrq->Type]), flags);
@@ -2565,11 +2565,11 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 				spin_unlock_irqrestore(&(IspInfo.SpinLockIrq[
 					WaitIrq->Type]), flags);
 				if (log_on)
-					LOG_NOTICE("- [2]update status\n");
+					LOG_DBG("- [2]update status\n");
 			} else if (WaitIrq->EventInfo.Clear ==
 				ISP_IRQ_CLEAR_ALL) {
 				if (log_on)
-					LOG_NOTICE("+ [3]update status\n");
+					LOG_DBG("+ [3]update status\n");
 				spin_lock_irqsave(&(
 					IspInfo.SpinLockIrq[
 						WaitIrq->Type]), flags);
@@ -2580,7 +2580,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 				spin_unlock_irqrestore(&(IspInfo.SpinLockIrq[
 					WaitIrq->Type]), flags);
 				if (log_on)
-					LOG_NOTICE("- [3]update status\n");
+					LOG_DBG("- [3]update status\n");
 			}
 		}
 	}
@@ -2589,7 +2589,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 	 * redeuce time of spin_lock_irqsave
 	 */
 	if (log_on)
-		LOG_NOTICE("+ update irqStatus\n");
+		LOG_DBG("+ update irqStatus\n");
 	spin_lock_irqsave(&(IspInfo.SpinLockIrq[
 		WaitIrq->Type]), flags);
 	irqStatus = IspInfo.IrqInfo.Status[WaitIrq->Type]
@@ -2597,7 +2597,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 	spin_unlock_irqrestore(&(IspInfo.SpinLockIrq[
 		WaitIrq->Type]), flags);
 	if (log_on)
-		LOG_NOTICE("- update irqStatus\n");
+		LOG_DBG("- update irqStatus\n");
 
 	if (WaitIrq->EventInfo.Clear == ISP_IRQ_CLEAR_NONE) {
 		if (IspInfo.IrqInfo.Status[
@@ -2606,7 +2606,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 			& WaitIrq->EventInfo.Status) {
 #ifdef ENABLE_WAITIRQ_LOG
 
-			LOG_INF("%s,%s",
+			LOG_DBG("%s,%s",
 			"Already have irq!!!: WaitIrq Timeout(%d) Clear(%d), Type(%d), StType(%d)",
 			", IrqStatus(0x%08X), WaitStatus(0x%08X), Timeout(%d), userKey(%d)\n",
 			WaitIrq->EventInfo.Timeout,
@@ -2623,13 +2623,13 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 	}
 #ifdef ENABLE_WAITIRQ_LOG
 	if (WaitIrq->EventInfo.UserKey == 1) {
-		LOG_INF("Before wait: C:%d T:%d StT:%d Sts:0x%08X\n",
+		LOG_DBG("Before wait: C:%d T:%d StT:%d Sts:0x%08X\n",
 			WaitIrq->EventInfo.Clear,
 			WaitIrq->Type,
 			WaitIrq->EventInfo.St_type,
 			irqStatus);
 
-		LOG_INF("WSts:0x%08X Timeout:%d key:%d\n",
+		LOG_DBG("WSts:0x%08X Timeout:%d key:%d\n",
 			WaitIrq->EventInfo.Status,
 			WaitIrq->EventInfo.Timeout,
 			WaitIrq->EventInfo.UserKey);
@@ -2637,7 +2637,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 #endif
 	/* 2. start to wait signal */
 	if (log_on)
-		LOG_NOTICE("+ start to wait signal\n");
+		LOG_DBG("+ start to wait signal\n");
 	if (ISP_CheckUseCamWaitQ(WaitIrq->Type,
 		WaitIrq->EventInfo.St_type,
 		WaitIrq->EventInfo.Status)) {
@@ -2679,7 +2679,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 				  WaitIrq->EventInfo.Timeout));
 	}
 	if (log_on)
-		LOG_NOTICE("- start to wait signal\n");
+		LOG_DBG("- start to wait signal\n");
 	/* check if user is interrupted by system signal */
 	if ((Timeout != 0) &&
 		(!ISP_GetIRQState(WaitIrq->Type,
@@ -2718,7 +2718,7 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 			IspInfo.SpinLockIrq[
 				WaitIrq->Type]), flags);
 
-		LOG_NOTICE(
+		LOG_DBG(
 		"ERRRR WaitIrq Clear(%d) Type(%d) StType(%d) Status(0x%08X) WaitStatus(0x%08X) Timeout(%d) key(%d)\n",
 		WaitIrq->EventInfo.Clear,
 		WaitIrq->Type,
@@ -2747,11 +2747,11 @@ static int ISP_WaitIrq(struct ISP_WAIT_IRQ_STRUCT *WaitIrq)
 			WaitIrq->Type]), flags);
 #ifdef ENABLE_WAITIRQ_LOG
 		if (WaitIrq->EventInfo.UserKey == 1) {
-			LOG_INF("Done WaitIrq Clear(%d) Type(%d) StType(%d)\n",
+			LOG_DBG("Done WaitIrq Clear(%d) Type(%d) StType(%d)\n",
 				WaitIrq->EventInfo.Clear,
 				WaitIrq->Type,
 				WaitIrq->EventInfo.St_type);
-			LOG_INF("Sts(0x%08X)WStatus(0x%08X)Time(%d)key(%d)\n",
+			LOG_DBG("Sts(0x%08X)WStatus(0x%08X)Time(%d)key(%d)\n",
 				irqStatus,
 				WaitIrq->EventInfo.Status,
 				WaitIrq->EventInfo.Timeout,
@@ -2940,7 +2940,7 @@ EXIT:
 			WaitIrq->Type]), flags);
 
 	if (WaitIrq->EventInfo.UserKey == 1)
-		LOG_INF("ret = 0x%x\n", Ret);
+		LOG_DBG("ret = 0x%x\n", Ret);
 
 	return Ret;
 }
@@ -2956,12 +2956,12 @@ static void ISP_ion_init(void)
 		pIon_client = ion_client_create(g_ion_device, "camera_isp");
 
 	if (!pIon_client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return;
 	}
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("create ion client 0x%p\n", pIon_client);
+		LOG_DBG("create ion client 0x%p\n", pIon_client);
 }
 
 /*************************************************
@@ -2970,12 +2970,12 @@ static void ISP_ion_init(void)
 static void ISP_ion_uninit(void)
 {
 	if (!pIon_client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return;
 	}
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("destroy ion client 0x%p\n", pIon_client);
+		LOG_DBG("destroy ion client 0x%p\n", pIon_client);
 
 	ion_client_destroy(pIon_client);
 
@@ -2991,23 +2991,23 @@ static struct ion_handle *ISP_ion_import_handle(
 	struct ion_handle *handle = NULL;
 
 	if (!client) {
-		LOG_NOTICE("invalid ion client!\n");
+		LOG_DBG("invalid ion client!\n");
 		return handle;
 	}
 	if (fd == -1) {
-		LOG_NOTICE("invalid ion fd!\n");
+		LOG_DBG("invalid ion fd!\n");
 		return handle;
 	}
 
 	handle = ion_import_dma_buf_fd(client, fd);
 
 	if (IS_ERR(handle)) {
-		LOG_NOTICE("import ion handle failed!\n");
+		LOG_DBG("import ion handle failed!\n");
 		return NULL;
 	}
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("[ion_import_hd]Hd(0x%p)\n", handle);
+		LOG_DBG("[ion_import_hd]Hd(0x%p)\n", handle);
 	return handle;
 }
 
@@ -3019,14 +3019,14 @@ static void ISP_ion_free_handle(
 	*client, struct ion_handle *handle)
 {
 	if (!client) {
-		LOG_NOTICE("invalid ion	client!\n");
+		LOG_DBG("invalid ion	client!\n");
 		return;
 	}
 	if (!handle)
 		return;
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("[ion_free_hd]Hd(0x%p)\n", handle);
+		LOG_DBG("[ion_free_hd]Hd(0x%p)\n", handle);
 
 	ion_free(client, handle);
 
@@ -3044,7 +3044,7 @@ static void ISP_ion_free_handle_by_module(unsigned int module)
 		&gION_TBL[module];
 
 	if (IspInfo.DebugMask & ISP_DBG_ION_CTRL)
-		LOG_INF("[ion_free_hd_by_module]%d\n",
+		LOG_DBG("[ion_free_hd_by_module]%d\n",
 			module);
 
 	for (i = 0; i < _dma_max_wr_; i++) {
@@ -3067,7 +3067,7 @@ static void ISP_ion_free_handle_by_module(unsigned int module)
 			/* */
 			if (IspInfo.DebugMask &
 				ISP_DBG_ION_CTRL) {
-				LOG_INF(
+				LOG_DBG(
 					"ion_free:dev(%d)dma(%d)j(%d)fd(%d)Hnd(0x%p)\n",
 					module, i, j,
 					nFd, p_IonHnd);
@@ -3112,7 +3112,7 @@ static long ISP_ioctl(struct file *pFile,
 
 	/*  */
 	if (pFile->private_data == NULL) {
-		LOG_NOTICE(
+		LOG_DBG(
 			"private_data is NULL, (process, pid, tgid)=(%s, %d, %d)\n",
 			current->comm,
 			current->pid,
@@ -3129,7 +3129,7 @@ static long ISP_ioctl(struct file *pFile,
 		if (copy_from_user(&wakelock_ctrl,
 			(void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get ISP_WAKELOCK_CTRL from user fail\n");
+			LOG_DBG("get ISP_WAKELOCK_CTRL from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			/* Enable wakelock */
@@ -3167,7 +3167,7 @@ static long ISP_ioctl(struct file *pFile,
 		if (copy_from_user(&DebugFlag[0],
 			(void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get irq from user fail\n");
+			LOG_DBG("get irq from user fail\n");
 			Ret = -EFAULT;
 		} else {
 
@@ -3175,7 +3175,7 @@ static long ISP_ioctl(struct file *pFile,
 				ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				DebugFlag[0] >
 				ISP_IRQ_TYPE_INT_CAMSV_1_ST) {
-				LOG_NOTICE("err TG(0x%x)\n", DebugFlag[0]);
+				LOG_DBG("err TG(0x%x)\n", DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
 			}
@@ -3192,7 +3192,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (copy_to_user((void *)Param,
 				&DebugFlag[1],
 				sizeof(unsigned int)) != 0) {
-				LOG_NOTICE("copy to user fail\n");
+				LOG_DBG("copy to user fail\n");
 				Ret = -EFAULT;
 			}
 		}
@@ -3203,7 +3203,7 @@ static long ISP_ioctl(struct file *pFile,
 			sizeof(struct
 				ISP_RAW_INT_STATUS)*ISP_IRQ_TYPE_AMOUNT)
 				!= 0)
-			LOG_NOTICE("get int err fail\n");
+			LOG_DBG("get int err fail\n");
 		else
 			memset((void *)g_ISPIntStatus, 0,
 				sizeof(g_ISPIntStatus));
@@ -3212,11 +3212,11 @@ static long ISP_ioctl(struct file *pFile,
 	case ISP_GET_DMA_ERR:
 		if (copy_from_user(&DebugFlag[0], (void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get module fail\n");
+			LOG_DBG("get module fail\n");
 			Ret = -EFAULT;
 		} else {
 			if (DebugFlag[0] >= (ISP_IRQ_TYPE_AMOUNT)) {
-				LOG_NOTICE("module error(%d)\n",
+				LOG_DBG("module error(%d)\n",
 					DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
@@ -3224,7 +3224,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (copy_to_user(
 			(void *)Param, &g_DmaErr_CAM[DebugFlag[0]],
 				sizeof(unsigned int)*_cam_max_) != 0)
-				LOG_NOTICE("get dma_err fail\n");
+				LOG_DBG("get dma_err fail\n");
 
 		}
 		break;
@@ -3232,13 +3232,13 @@ static long ISP_ioctl(struct file *pFile,
 		if (copy_from_user(&DebugFlag[0],
 			(void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get cur sof from user fail\n");
+			LOG_DBG("get cur sof from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			if (DebugFlag[0] <
 				ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				DebugFlag[0] >= ISP_IRQ_TYPE_AMOUNT) {
-				LOG_NOTICE("cursof: error type (%d)\n",
+				LOG_DBG("cursof: error type (%d)\n",
 					DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
@@ -3247,7 +3247,7 @@ static long ISP_ioctl(struct file *pFile,
 		}
 		if (copy_to_user((void *)Param, &DebugFlag[1],
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("copy to user fail\n");
+			LOG_DBG("copy to user fail\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3255,7 +3255,7 @@ static long ISP_ioctl(struct file *pFile,
 		if (copy_from_user(&module,
 			(void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get hwmodule from user fail\n");
+			LOG_DBG("get hwmodule from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			ISP_Reset(module);
@@ -3273,7 +3273,7 @@ static long ISP_ioctl(struct file *pFile,
 			 */
 			Ret = ISP_ReadReg(&RegIo);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3287,7 +3287,7 @@ static long ISP_ioctl(struct file *pFile,
 			 */
 			Ret = ISP_WriteReg(&RegIo);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3301,7 +3301,7 @@ static long ISP_ioctl(struct file *pFile,
 				ISP_IRQ_TYPE_AMOUNT) ||
 				(IrqInfo.Type < 0)) {
 				Ret = -EFAULT;
-				LOG_NOTICE("invalid type(%d)\n",
+				LOG_DBG("invalid type(%d)\n",
 					IrqInfo.Type);
 				goto EXIT;
 			}
@@ -3309,7 +3309,7 @@ static long ISP_ioctl(struct file *pFile,
 			if ((IrqInfo.EventInfo.St_type >=
 				ISP_IRQ_ST_AMOUNT) ||
 				(IrqInfo.EventInfo.St_type < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"invalid St_type(%d), max(%d), force St_type = 0\n",
 					IrqInfo.EventInfo.St_type,
 					ISP_IRQ_ST_AMOUNT);
@@ -3319,14 +3319,14 @@ static long ISP_ioctl(struct file *pFile,
 			if ((IrqInfo.EventInfo.UserKey >=
 				IRQ_USER_NUM_MAX) ||
 				(IrqInfo.EventInfo.UserKey < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"invalid userKey(%d), max(%d), force userkey = 0\n",
 					IrqInfo.EventInfo.UserKey,
 					IRQ_USER_NUM_MAX);
 				IrqInfo.EventInfo.UserKey = 0;
 			}
 #ifdef ENABLE_WAITIRQ_LOG
-			LOG_INF(
+			LOG_DBG(
 				"IRQ type(%d), userKey(%d), timeout(%d), userkey(%d), st_status(%d), status(%d)\n",
 				IrqInfo.Type, IrqInfo.EventInfo.UserKey,
 				IrqInfo.EventInfo.Timeout,
@@ -3336,7 +3336,7 @@ static long ISP_ioctl(struct file *pFile,
 #endif
 			Ret = ISP_WaitIrq(&IrqInfo);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3349,14 +3349,14 @@ static long ISP_ioctl(struct file *pFile,
 			if ((ClearIrq.Type >= ISP_IRQ_TYPE_AMOUNT) ||
 				(ClearIrq.Type < 0)) {
 				Ret = -EFAULT;
-				LOG_NOTICE("invalid type(%d)\n", ClearIrq.Type);
+				LOG_DBG("invalid type(%d)\n", ClearIrq.Type);
 				goto EXIT;
 			}
 
 			if ((ClearIrq.EventInfo.St_type >=
 				ISP_IRQ_ST_AMOUNT) ||
 				(ClearIrq.EventInfo.St_type < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"invalid St_type(%d), max(%d), force St_type = 0\n",
 					ClearIrq.EventInfo.St_type,
 					ISP_IRQ_ST_AMOUNT);
@@ -3366,7 +3366,7 @@ static long ISP_ioctl(struct file *pFile,
 			/*  */
 			if ((ClearIrq.EventInfo.UserKey >= IRQ_USER_NUM_MAX) ||
 				(ClearIrq.EventInfo.UserKey < 0)) {
-				LOG_NOTICE("errUserEnum(%d)",
+				LOG_DBG("errUserEnum(%d)",
 					ClearIrq.EventInfo.UserKey);
 				Ret = -EFAULT;
 				goto EXIT;
@@ -3391,7 +3391,7 @@ static long ISP_ioctl(struct file *pFile,
 			spin_unlock_irqrestore(&(IspInfo.SpinLockIrq[
 				ClearIrq.Type]), flags);
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3411,14 +3411,14 @@ static long ISP_ioctl(struct file *pFile,
 				&RegUserKey,
 				sizeof(struct ISP_REGISTER_USERKEY_STRUCT))
 				!= 0)
-				LOG_NOTICE("copy_to_user failed\n");
+				LOG_DBG("copy_to_user failed\n");
 
 			if (RegUserKey.userKey < 0) {
-				LOG_NOTICE("query irq user key fail\n");
+				LOG_DBG("query irq user key fail\n");
 				Ret = -1;
 			}
 		} else {
-			LOG_NOTICE("copy from user fail\n");
+			LOG_DBG("copy from user fail\n");
 		}
 
 		break;
@@ -3429,7 +3429,7 @@ static long ISP_ioctl(struct file *pFile,
 			if ((IrqInfo.EventInfo.UserKey >=
 					IRQ_USER_NUM_MAX) ||
 				(IrqInfo.EventInfo.UserKey < 0)) {
-				LOG_NOTICE("invalid userKey(%d), max(%d)\n",
+				LOG_DBG("invalid userKey(%d), max(%d)\n",
 						IrqInfo.EventInfo.UserKey,
 						IRQ_USER_NUM_MAX);
 				Ret = -EFAULT;
@@ -3437,7 +3437,7 @@ static long ISP_ioctl(struct file *pFile,
 			}
 			if ((IrqInfo.Type >= ISP_IRQ_TYPE_AMOUNT) ||
 			(IrqInfo.Type < 0)) {
-				LOG_NOTICE("invalid type(%d), max(%d)\n",
+				LOG_DBG("invalid type(%d), max(%d)\n",
 					IrqInfo.Type,
 					ISP_IRQ_TYPE_AMOUNT);
 				Ret = -EFAULT;
@@ -3446,7 +3446,7 @@ static long ISP_ioctl(struct file *pFile,
 			if ((IrqInfo.EventInfo.St_type >=
 					ISP_IRQ_ST_AMOUNT) ||
 				 (IrqInfo.EventInfo.St_type < 0)) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"invalid St_type(%d), max(%d), force St_type = 0\n",
 					IrqInfo.EventInfo.St_type,
 					ISP_IRQ_ST_AMOUNT);
@@ -3466,7 +3466,7 @@ static long ISP_ioctl(struct file *pFile,
 			 * %x\n",IspInfo.DebugMask);
 			 */
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3483,7 +3483,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (DebugFlag[1] <
 				ISP_CAMSYS_CONFIG_IDX ||
 				DebugFlag[1] > ISP_CAMSV5_IDX) {
-				LOG_NOTICE("CAM Index is out of range:%d",
+				LOG_DBG("CAM Index is out of range:%d",
 					DebugFlag[1]);
 				Ret = -EFAULT;
 				break;
@@ -3542,11 +3542,11 @@ static long ISP_ioctl(struct file *pFile,
 						CAM_REG_CTL_DMA_EN(
 						DebugFlag[1]));
 
-			LOG_INF("CAM_%d viewFinder is ON (SecOn:0x%x)\n",
+			LOG_DBG("CAM_%d viewFinder is ON (SecOn:0x%x)\n",
 					module, sec_on);
 
 			if (vf & 0x1)
-				LOG_NOTICE("CAM_%d: vf already enabled\n",
+				LOG_DBG("CAM_%d: vf already enabled\n",
 					module);
 			else
 				ISP_WR32(CAM_REG_TG_VF_CON(DebugFlag[1]),
@@ -3579,31 +3579,31 @@ static long ISP_ioctl(struct file *pFile,
 				break;
 			}
 			case 0: {
-				LOG_INF("CAM_%d viewFinder is OFF\n", module);
+				LOG_DBG("CAM_%d viewFinder is OFF\n", module);
 
 				if (vf & 0x1)
 					ISP_WR32(
 						CAM_REG_TG_VF_CON(DebugFlag[1]),
 						(vf-0x1));
 				else
-					LOG_NOTICE(
+					LOG_DBG(
 						"CAM_%d: vf already disabled\n",
 						module);
 				break;
 			}
 			/* CAMSV */
 			case 11: {
-				LOG_INF("CAMSV_%d viewFinder is ON\n", module);
+				LOG_DBG("CAMSV_%d viewFinder is ON\n", module);
 				cam_dmao = (ISP_RD32(
 					CAMSV_REG_MODULE_EN(DebugFlag[1])) &
 					0x10);
-				LOG_INF("CAMSV_%d:[DMA_EN]:0x%x\n",
+				LOG_DBG("CAMSV_%d:[DMA_EN]:0x%x\n",
 					module, cam_dmao);
 				vf = ISP_RD32(
 					CAMSV_REG_TG_VF_CON(DebugFlag[1]));
 
 				if (vf & 0x1)
-					LOG_NOTICE(
+					LOG_DBG(
 						"CAMSV_%d:vf already enabled\n",
 						DebugFlag[1]);
 				else
@@ -3620,7 +3620,7 @@ static long ISP_ioctl(struct file *pFile,
 				break;
 			}
 			case 10: {
-				LOG_INF("CAMSV_%d viewFinder is OFF\n",
+				LOG_DBG("CAMSV_%d viewFinder is OFF\n",
 					DebugFlag[1]);
 				vf = ISP_RD32(CAMSV_REG_TG_VF_CON(
 					DebugFlag[1]));
@@ -3629,14 +3629,14 @@ static long ISP_ioctl(struct file *pFile,
 					ISP_WR32(CAMSV_REG_TG_VF_CON(
 						DebugFlag[1]), (vf-0x1));
 				else
-					LOG_NOTICE(
+					LOG_DBG(
 						"CAMSV_%d: vf already disalbed\n",
 						DebugFlag[1]);
 				break;
 			}
 			}
 		} else {
-			LOG_NOTICE("copy_from_user failed\n");
+			LOG_DBG("copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3661,7 +3661,7 @@ static long ISP_ioctl(struct file *pFile,
 			case ISP_IRQ_TYPE_INT_CAM_B_ST:
 				if (ISP_PopBufTimestamp(DebugFlag[0],
 					dma_id, Tstp) != 0)
-					LOG_NOTICE(
+					LOG_DBG(
 						"Get Buf sof timestamp fail\n");
 				break;
 			case ISP_IRQ_TYPE_INT_CAMSV_0_ST:
@@ -3674,7 +3674,7 @@ static long ISP_ioctl(struct file *pFile,
 				Tstp.usec = gSTime[DebugFlag[0]].usec;
 				break;
 			default:
-				LOG_NOTICE("unsupported module:0x%x\n",
+				LOG_DBG("unsupported module:0x%x\n",
 					DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
@@ -3684,7 +3684,7 @@ static long ISP_ioctl(struct file *pFile,
 			#else
 			if ((DebugFlag[0] < ISP_IRQ_TYPE_INT_CAM_A_ST) ||
 				(DebugFlag[0] >	ISP_IRQ_TYPE_INT_CAMSV_5_ST)) {
-				LOG_NOTICE("unsupported module:0x%x",
+				LOG_DBG("unsupported module:0x%x",
 					DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
@@ -3700,7 +3700,7 @@ static long ISP_ioctl(struct file *pFile,
 
 			if (copy_to_user((void *)Param, &Tstp,
 				sizeof(struct S_START_T)) != 0) {
-				LOG_NOTICE("copy_to_user failed");
+				LOG_DBG("copy_to_user failed");
 				Ret = -EFAULT;
 			}
 		}
@@ -3720,7 +3720,7 @@ static long ISP_ioctl(struct file *pFile,
 							ispclks.clklevel);
 
 				if (ispclks.clklevelcnt >= ISP_CLK_LEVEL_CNT) {
-					LOG_NOTICE("clklevelcnt err:%d\n",
+					LOG_DBG("clklevelcnt err:%d\n",
 						ispclks.clklevelcnt);
 					Ret = -EFAULT;
 					break;
@@ -3729,7 +3729,7 @@ static long ISP_ioctl(struct file *pFile,
 						&ispclks,
 						sizeof(struct ISP_CLK_INFO))
 						!= 0) {
-					LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+					LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 					Ret = -EFAULT;
 				}
 			}
@@ -3745,7 +3745,7 @@ static long ISP_ioctl(struct file *pFile,
 						ISP_IRQ_TYPE_INT_CAM_A_ST,
 						NULL);
 			} else {
-				LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+				LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 				Ret = -EFAULT;
 			}
 		}
@@ -3761,7 +3761,7 @@ static long ISP_ioctl(struct file *pFile,
 						ISP_IRQ_TYPE_INT_CAM_A_ST,
 						&dfs_update);
 			} else {
-				LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+				LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 				Ret = -EFAULT;
 			}
 		}
@@ -3777,7 +3777,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (copy_to_user((void *)Param,
 					&getclk,
 					sizeof(struct ISP_GET_CLK_INFO)) != 0) {
-				LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+				LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 				Ret = -EFAULT;
 			}
 		}
@@ -3794,7 +3794,7 @@ static long ISP_ioctl(struct file *pFile,
 					pm_qos_info.module,
 					(unsigned int *)pm_qos_info.port_bw);
 			} else {
-				LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+				LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 				Ret = -EFAULT;
 			}
 		}
@@ -3811,7 +3811,7 @@ static long ISP_ioctl(struct file *pFile,
 					pm_qos_info.module,
 					(unsigned int *)pm_qos_info.port_bw);
 			} else {
-				LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+				LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 				Ret = -EFAULT;
 			}
 		}
@@ -3822,7 +3822,7 @@ static long ISP_ioctl(struct file *pFile,
 				sizeof(unsigned int) * 2) == 0) {
 			ISP_SetPMQOS(E_BW_CLR, DebugFlag[1], DebugFlag);
 		} else {
-			LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+			LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 			Ret = -EFAULT;
 		}
 		break;
@@ -3832,7 +3832,7 @@ static long ISP_ioctl(struct file *pFile,
 				sizeof(unsigned int) * 2) == 0) {
 			SV_SetPMQOS(E_BW_CLR, DebugFlag[1], DebugFlag);
 		} else {
-			LOG_NOTICE("Cmd(%d) copy fail\n", Cmd);
+			LOG_DBG("Cmd(%d) copy fail\n", Cmd);
 			Ret = -EFAULT;
 		}
 		break;
@@ -3862,12 +3862,12 @@ static long ISP_ioctl(struct file *pFile,
 #endif
 				if (copy_to_user((void *)Param, globalTime,
 					sizeof(u64)*TS_TYPE) != 0) {
-					LOG_NOTICE(
+					LOG_DBG(
 						"ISP_GET_GLOBAL_TIME copy_to_user failed\n");
 					Ret = -EFAULT;
 				}
 			} else {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ISP_GET_GLOBAL_TIME copy_from_user failed\n");
 				Ret = -EFAULT;
 			}
@@ -3876,13 +3876,13 @@ static long ISP_ioctl(struct file *pFile,
 	case ISP_GET_VSYNC_CNT:
 		if (copy_from_user(&DebugFlag[0], (void *)Param,
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("get cur sof from user fail");
+			LOG_DBG("get cur sof from user fail");
 			Ret = -EFAULT;
 		} else {
 
 			if (DebugFlag[0] < ISP_IRQ_TYPE_INT_CAM_A_ST ||
 				DebugFlag[0] >= ISP_IRQ_TYPE_AMOUNT) {
-				LOG_NOTICE("err TG(0x%x)\n", DebugFlag[0]);
+				LOG_DBG("err TG(0x%x)\n", DebugFlag[0]);
 				Ret = -EFAULT;
 				break;
 			}
@@ -3891,7 +3891,7 @@ static long ISP_ioctl(struct file *pFile,
 		}
 		if (copy_to_user((void *)Param, &DebugFlag[1],
 			sizeof(unsigned int)) != 0) {
-			LOG_NOTICE("copy to user fail");
+			LOG_DBG("copy to user fail");
 			Ret = -EFAULT;
 		}
 		break;
@@ -3909,7 +3909,7 @@ static long ISP_ioctl(struct file *pFile,
 
 		if (copy_from_user(&cq0_data, (void *)Param,
 			sizeof(unsigned int) * CAM_MAX * 2) != 0) {
-			LOG_NOTICE("copy to user fail");
+			LOG_DBG("copy to user fail");
 			Ret = -EFAULT;
 			break;
 		}
@@ -3918,7 +3918,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (cq0_data[CAM_A][1] != 0) {
 				g_cqBaseAddr[cq0_data[CAM_A][0]][0] =
 					cq0_data[CAM_A][1];
-				/*LOG_NOTICE("(CAM A)CQ0 pa 0x%x, 0x%x",
+				/*LOG_DBG("(CAM A)CQ0 pa 0x%x, 0x%x",
 				 *cq0_data[CAM_A][0], cq0_data[CAM_A][1]);
 				 */
 			}
@@ -3928,7 +3928,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (cq0_data[CAM_B][1] != 0) {
 				g_cqBaseAddr[cq0_data[CAM_B][0]][0] =
 					cq0_data[CAM_B][1];
-				/*LOG_NOTICE("(CAM B)CQ0 pa 0x%x, 0x%x",
+				/*LOG_DBG("(CAM B)CQ0 pa 0x%x, 0x%x",
 				 *cq0_data[CAM_B][0], cq0_data[CAM_B][1]);
 				 */
 			}
@@ -3938,7 +3938,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (cq0_data[CAM_C][1] != 0) {
 				g_cqBaseAddr[cq0_data[CAM_C][0]][0] =
 					cq0_data[CAM_C][1];
-				/*LOG_NOTICE("(CAM C)CQ0 pa 0x%x, 0x%x",
+				/*LOG_DBG("(CAM C)CQ0 pa 0x%x, 0x%x",
 				 *cq0_data[CAM_C][0], cq0_data[CAM_C][1]);
 				 */
 			}
@@ -3953,13 +3953,13 @@ static long ISP_ioctl(struct file *pFile,
 			unsigned int jump;
 
 			if (!pIon_client) {
-				LOG_NOTICE("ion_import:invalid ion client!\n");
+				LOG_DBG("ion_import:invalid ion client!\n");
 				Ret = -EFAULT;
 				break;
 			}
 
 			if (IonNode.devNode >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"[ISP_ION_IMPORT]devNode should be smaller than ISP_DEV_NODE_NUM\n");
 				Ret = -EFAULT;
 				break;
@@ -3967,7 +3967,7 @@ static long ISP_ioctl(struct file *pFile,
 
 			ptbl = &gION_TBL[IonNode.devNode];
 			if (ptbl->node != IonNode.devNode) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_import: devNode not support(%d)!\n",
 					IonNode.devNode);
 				Ret = -EFAULT;
@@ -3975,7 +3975,7 @@ static long ISP_ioctl(struct file *pFile,
 			}
 			if (IonNode.dmaPort < 0 ||
 				IonNode.dmaPort >= _dma_max_wr_) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_import: dmaport error:%d(0~%d)\n",
 					IonNode.dmaPort, _dma_max_wr_);
 				Ret = -EFAULT;
@@ -3983,7 +3983,7 @@ static long ISP_ioctl(struct file *pFile,
 			}
 			jump = IonNode.dmaPort*_ion_keep_max_;
 			if (IonNode.memID <= 0) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_import: dma(%d)invalid ion fd(%d)\n",
 					IonNode.dmaPort, IonNode.memID);
 				Ret = -EFAULT;
@@ -4000,7 +4000,7 @@ static long ISP_ioctl(struct file *pFile,
 			/* */
 			if (i < _ion_keep_max_) {
 				if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-					LOG_INF(
+					LOG_DBG(
 					"ion_import: already exist: dev(%d)dma(%d)i(%d)fd(%d)Hnd(0x%p)\n",
 						IonNode.devNode,
 						IonNode.dmaPort,
@@ -4043,7 +4043,7 @@ static long ISP_ioctl(struct file *pFile,
 					if (IspInfo.DebugMask &
 						ISP_DBG_ION_CTRL) {
 
-						LOG_INF(
+						LOG_DBG(
 						"ion_import:dev(%d)dma(%d)i(%d)fd(%d)Hnd(0x%p)\n",
 						IonNode.devNode,
 						IonNode.dmaPort, i,
@@ -4055,7 +4055,7 @@ static long ISP_ioctl(struct file *pFile,
 			spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
 			/* */
 			if (i == _ion_keep_max_) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_import: dma(%d)no empty space in list(%d_%d)\n",
 					IonNode.dmaPort,
 					IonNode.memID, _ion_keep_max_);
@@ -4064,7 +4064,7 @@ static long ISP_ioctl(struct file *pFile,
 				Ret = -EFAULT;
 			}
 		} else {
-			LOG_NOTICE("[ion import]copy_from_user failed\n");
+			LOG_DBG("[ion import]copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -4075,13 +4075,13 @@ static long ISP_ioctl(struct file *pFile,
 			unsigned int jump;
 
 			if (!pIon_client) {
-				LOG_NOTICE("ion_free: invalid ion client!\n");
+				LOG_DBG("ion_free: invalid ion client!\n");
 				Ret = -EFAULT;
 				break;
 			}
 
 			if (IonNode.devNode >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"[ISP_ION_FREE]devNode should be smaller than ISP_DEV_NODE_NUM\n");
 				Ret = -EFAULT;
 				break;
@@ -4089,7 +4089,7 @@ static long ISP_ioctl(struct file *pFile,
 
 			ptbl = &gION_TBL[IonNode.devNode];
 			if (ptbl->node != IonNode.devNode) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_free: devNode not support(%d)!\n",
 					IonNode.devNode);
 				Ret = -EFAULT;
@@ -4097,14 +4097,14 @@ static long ISP_ioctl(struct file *pFile,
 			}
 			if (IonNode.dmaPort < 0 ||
 				IonNode.dmaPort >= _dma_max_wr_) {
-				LOG_NOTICE("ion_free: dmaport error:%d(0~%d)\n",
+				LOG_DBG("ion_free: dmaport error:%d(0~%d)\n",
 					IonNode.dmaPort, _dma_max_wr_);
 				Ret = -EFAULT;
 				break;
 			}
 			jump = IonNode.dmaPort*_ion_keep_max_;
 			if (IonNode.memID <= 0) {
-				LOG_NOTICE("ion_free: invalid ion fd(%d)\n",
+				LOG_DBG("ion_free: invalid ion fd(%d)\n",
 					IonNode.memID);
 				Ret = -EFAULT;
 				break;
@@ -4118,7 +4118,7 @@ static long ISP_ioctl(struct file *pFile,
 			}
 			if (i == _ion_keep_max_) {
 				spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_free: can't find ion dev(%d)dma(%d)fd(%d) in list\n",
 					IonNode.devNode,
 					IonNode.dmaPort,
@@ -4136,7 +4136,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (--ptbl->pIonCt[jump + i] > 0) {
 				spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
 				if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-					LOG_INF(
+					LOG_DBG(
 					"ion_free: user ct(%d): dev(%d)dma(%d)i(%d)fd(%d)\n",
 					ptbl->pIonCt[jump + i],
 					IonNode.devNode, IonNode.dmaPort, i,
@@ -4145,7 +4145,7 @@ static long ISP_ioctl(struct file *pFile,
 				break;
 			} else if (ptbl->pIonCt[jump + i] < 0) {
 				spin_unlock(&(ptbl->pLock[IonNode.dmaPort]));
-				LOG_NOTICE(
+				LOG_DBG(
 					"ion_free: free more than import (%d): dev(%d)dma(%d)i(%d)fd(%d)\n",
 					ptbl->pIonCt[jump + i],
 					IonNode.devNode, IonNode.dmaPort, i,
@@ -4155,7 +4155,7 @@ static long ISP_ioctl(struct file *pFile,
 			}
 
 			if (IspInfo.DebugMask & ISP_DBG_ION_CTRL) {
-				LOG_INF(
+				LOG_DBG(
 					"ion_free: dev(%d)dma(%d)i(%d)fd(%d)Hnd(0x%p)Ct(%d)\n",
 					IonNode.devNode, IonNode.dmaPort, i,
 					IonNode.memID,
@@ -4171,7 +4171,7 @@ static long ISP_ioctl(struct file *pFile,
 			/*can't in spin_lock*/
 			ISP_ion_free_handle(pIon_client, p_IonHnd);
 		} else {
-			LOG_NOTICE("[ion free]copy_from_user failed\n");
+			LOG_DBG("[ion free]copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
 		break;
@@ -4179,20 +4179,20 @@ static long ISP_ioctl(struct file *pFile,
 		if (copy_from_user(&module, (void *)Param,
 			sizeof(unsigned int)) == 0) {
 			if (module >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE(
+				LOG_DBG(
 				"[ISP_ION_FREE_BY_HWMODULE] module should be smaller than ISP_DEV_NODE_NUM");
 				Ret = -EFAULT;
 				break;
 			}
 			if (gION_TBL[module].node != module) {
-				LOG_NOTICE("module error(%d)\n", module);
+				LOG_DBG("module error(%d)\n", module);
 				Ret = -EFAULT;
 				break;
 			}
 
 			ISP_ion_free_handle_by_module(module);
 		} else {
-			LOG_NOTICE(
+			LOG_DBG(
 				"[ion free by module] copy_from_user failed\n");
 			Ret = -EFAULT;
 		}
@@ -4210,7 +4210,7 @@ static long ISP_ioctl(struct file *pFile,
 			if (multiRAWConfig.HWmodule < 0 ||
 				multiRAWConfig.HWmodule >
 				(ISP_IRQ_TYPE_INT_CAMSV_0_ST - 1)) {
-				LOG_NOTICE("Wrong HWmodule:%d",
+				LOG_DBG("Wrong HWmodule:%d",
 					multiRAWConfig.HWmodule);
 				Ret = -EFAULT;
 				break;
@@ -4363,7 +4363,7 @@ static long ISP_ioctl(struct file *pFile,
 
 		if (copy_from_user(&larbInfo, (void *)Param,
 			sizeof(struct ISP_LARB_MMU_STRUCT)) != 0) {
-			LOG_NOTICE("copy_from_user LARB_MMU_CTL	failed\n");
+			LOG_DBG("copy_from_user LARB_MMU_CTL	failed\n");
 			Ret = -EFAULT;
 			goto EXIT;
 		}
@@ -4373,7 +4373,7 @@ static long ISP_ioctl(struct file *pFile,
 		case 6:
 			break;
 		default:
-			LOG_NOTICE("Wrong SMI_LARB port=%d\n",
+			LOG_DBG("Wrong SMI_LARB port=%d\n",
 				larbInfo.LarbNum);
 			Ret = -EFAULT;
 			goto EXIT;
@@ -4381,7 +4381,7 @@ static long ISP_ioctl(struct file *pFile,
 
 		if ((SMI_LARB_BASE[larbInfo.LarbNum] == NULL) ||
 			(larbInfo.regOffset >= 0x1000)) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"Wrong SMI_LARB port=%d base addr=%p offset=0x%x\n",
 				larbInfo.LarbNum,
 				SMI_LARB_BASE[larbInfo.LarbNum],
@@ -4399,12 +4399,12 @@ static long ISP_ioctl(struct file *pFile,
 	case ISP_SET_SEC_DAPC_REG:
 		if (copy_from_user(Dapc_Reg, (void *)Param,
 			sizeof(unsigned int) * 6) != 0) {
-			LOG_NOTICE("get ISP_SET_SEC_DAPC_REG from user fail\n");
+			LOG_DBG("get ISP_SET_SEC_DAPC_REG from user fail\n");
 			Ret = -EFAULT;
 		} else {
 			if (Dapc_Reg[0] < ISP_CAMSYS_CONFIG_IDX ||
 				Dapc_Reg[0] >= ISP_DEV_NODE_NUM) {
-				LOG_NOTICE("module index(0x%x) error\n",
+				LOG_DBG("module index(0x%x) error\n",
 					Dapc_Reg[0]);
 				Ret = -EFAULT;
 				break;
@@ -4421,7 +4421,7 @@ static long ISP_ioctl(struct file *pFile,
 				lock_reg.CAM_REG_CTL_EN2[Dapc_Reg[
 					0]] = Dapc_Reg[5];
 
-			LOG_INF(
+			LOG_DBG(
 					"[DAPC REG]CTL_EN:0x%x CTL_DMA_EN:0x%x CTL_SEL:0x%x CTL_EN2:0x%x",
 					lock_reg.CAM_REG_CTL_EN[
 						Dapc_Reg[0]],
@@ -4432,7 +4432,7 @@ static long ISP_ioctl(struct file *pFile,
 					lock_reg.CAM_REG_CTL_EN2[
 						Dapc_Reg[0]]);
 			} else {
-				LOG_NOTICE("get wrong sec status(0x%x)\n",
+				LOG_DBG("get wrong sec status(0x%x)\n",
 					Dapc_Reg[1]);
 				Ret = -EFAULT;
 			}
@@ -4440,7 +4440,7 @@ static long ISP_ioctl(struct file *pFile,
 		break;
 	default:
 	{
-		LOG_NOTICE("Unknown Cmd(%d)\n", Cmd);
+		LOG_DBG("Unknown Cmd(%d)\n", Cmd);
 		Ret = -EPERM;
 		break;
 	}
@@ -4448,7 +4448,7 @@ static long ISP_ioctl(struct file *pFile,
 	/*  */
 EXIT:
 	if (Ret != 0)
-		LOG_NOTICE(
+		LOG_DBG(
 			"Fail, Cmd(%d), Pid(%d), (process, pid, tgid)=(%s, %d, %d)\n",
 			Cmd, pUserInfo->Pid, current->comm,
 			current->pid, current->tgid);
@@ -4616,14 +4616,14 @@ static long ISP_ioctl_compat(struct file *filp,
 
 		err = compat_get_isp_read_register_data(data32, data);
 		if (err) {
-			LOG_INF("compat_get_isp_read_register_data error!!!\n");
+			LOG_DBG("compat_get_isp_read_register_data error!!!\n");
 			return err;
 		}
 		ret = filp->f_op->unlocked_ioctl(
 			filp, ISP_READ_REGISTER, (unsigned long)data);
 		err = compat_put_isp_read_register_data(data32, data);
 		if (err) {
-			LOG_INF("compat_put_isp_read_register_data error!!!\n");
+			LOG_DBG("compat_put_isp_read_register_data error!!!\n");
 			return err;
 		}
 		return ret;
@@ -4641,7 +4641,7 @@ static long ISP_ioctl_compat(struct file *filp,
 
 		err = compat_get_isp_read_register_data(data32, data);
 		if (err) {
-			LOG_INF("COMPAT_ISP_WRITE_REGISTER error!!!\n");
+			LOG_DBG("COMPAT_ISP_WRITE_REGISTER error!!!\n");
 			return err;
 		}
 		ret = filp->f_op->unlocked_ioctl(
@@ -4665,7 +4665,7 @@ static long ISP_ioctl_compat(struct file *filp,
 			return err;
 
 		if (err) {
-			LOG_INF(
+			LOG_DBG(
 				"compat_get_isp_buf_ctrl_struct_data error!!!\n");
 			return err;
 		}
@@ -4674,7 +4674,7 @@ static long ISP_ioctl_compat(struct file *filp,
 		err = compat_put_isp_buf_ctrl_struct_data(data32, data);
 
 		if (err) {
-			LOG_INF("compat_put_isp_buf_ctrl_struct_data error!\n");
+			LOG_DBG("compat_put_isp_buf_ctrl_struct_data error!\n");
 			return err;
 		}
 		return ret;
@@ -4693,14 +4693,14 @@ static long ISP_ioctl_compat(struct file *filp,
 
 		err = compat_get_isp_ref_cnt_ctrl_struct_data(data32, data);
 		if (err) {
-			LOG_INF(
+			LOG_DBG(
 				"compat_get_isp_ref_cnt_ctrl_struct_data error!\n");
 			return err;
 		}
 
 		err = compat_put_isp_ref_cnt_ctrl_struct_data(data32, data);
 		if (err) {
-			LOG_INF(
+			LOG_DBG(
 				"compat_put_isp_ref_cnt_ctrl_struct_data error!!!\n");
 			return err;
 		}
@@ -4930,7 +4930,7 @@ EXIT:
 			G_u4EnableClockCount);
 	}
 
-	LOG_INF("- X. Ret: %d. UserCount: %d. G_u4EnableClockCount:%d\n",
+	LOG_DBG("- X. Ret: %d. UserCount: %d. G_u4EnableClockCount:%d\n",
 		Ret, IspInfo.UserCount, G_u4EnableClockCount);
 	mutex_unlock(&open_isp_mutex);
 	return Ret;
@@ -4978,7 +4978,7 @@ static inline void ISP_StopHW(int module)
 		if (regTGSt == 1)
 			break;
 
-		LOG_INF("%s: wait 1VD (%d)\n", moduleName, loopCnt);
+		LOG_DBG("%s: wait 1VD (%d)\n", moduleName, loopCnt);
 		ret = ISP_WaitIrq(&waitirq);
 		/* first wait is clear wait,
 		 * others are non-clear wait
@@ -4987,7 +4987,7 @@ static inline void ISP_StopHW(int module)
 	} while (--loopCnt);
 
 	if (-ERESTARTSYS == ret) {
-		LOG_INF("%s: interrupt by system signal, wait idle\n",
+		LOG_DBG("%s: interrupt by system signal, wait idle\n",
 			moduleName);
 		/* timer*/
 		m_sec = ktime_get();
@@ -5002,14 +5002,14 @@ static inline void ISP_StopHW(int module)
 				break;
 		}
 		if (regTGSt == 1)
-			LOG_INF("%s: wait idle done\n", moduleName);
+			LOG_DBG("%s: wait idle done\n", moduleName);
 		else
-			LOG_INF("%s: wait idle timeout(%lld)\n",
+			LOG_DBG("%s: wait idle timeout(%lld)\n",
 				moduleName, (sec - m_sec));
 	}
 
 RESET:
-	LOG_INF("%s: reset\n", moduleName);
+	LOG_DBG("%s: reset\n", moduleName);
 	/* timer*/
 	m_sec = ktime_get();
 
@@ -5022,7 +5022,7 @@ RESET:
 		sec = ktime_get();
 		/* wait time>timeoutMs, break */
 		if ((sec  - m_sec) > timeoutMs) {
-			LOG_INF("%s: wait SW idle timeout\n", moduleName);
+			LOG_DBG("%s: wait SW idle timeout\n", moduleName);
 			break;
 		}
 	}
@@ -5044,7 +5044,7 @@ RESET:
 		sec = ktime_get();
 		/* wait time>timeoutMs, break */
 		if ((sec  - m_sec) > (timeoutMs/50000)) {
-			LOG_INF("%s: wait SW RST ST 50000 timeout\n",
+			LOG_DBG("%s: wait SW RST ST 50000 timeout\n",
 				moduleName);
 			break;
 		}
@@ -5112,7 +5112,7 @@ static inline void ISP_StopSVHW(int module)
 		if (regTGSt == 1)
 			break;
 
-		LOG_INF("%s: wait 1VD (%d)\n",
+		LOG_DBG("%s: wait 1VD (%d)\n",
 			moduleName, loopCnt);
 		ret = ISP_WaitIrq(&waitirq);
 		/* first wait is clear wait,
@@ -5122,7 +5122,7 @@ static inline void ISP_StopSVHW(int module)
 	} while (--loopCnt);
 
 	if (-ERESTARTSYS == ret) {
-		LOG_INF("%s: interrupt by system signal,wait idle\n",
+		LOG_DBG("%s: interrupt by system signal,wait idle\n",
 			moduleName);
 		/* timer*/
 		m_sec = ktime_get();
@@ -5138,13 +5138,13 @@ static inline void ISP_StopSVHW(int module)
 				break;
 		}
 		if (regTGSt == 1)
-			LOG_INF("%s: wait idle done\n", moduleName);
+			LOG_DBG("%s: wait idle done\n", moduleName);
 		else
-			LOG_INF("%s: wait idle timeout (%lld)\n",
+			LOG_DBG("%s: wait idle timeout (%lld)\n",
 				moduleName, (sec - m_sec));
 	}
 
-	LOG_INF("%s: reset\n", moduleName);
+	LOG_DBG("%s: reset\n", moduleName);
 	/* timer*/
 	m_sec = ktime_get();
 
@@ -5158,7 +5158,7 @@ static inline void ISP_StopSVHW(int module)
 		sec  = ktime_get();
 		/* wait time>timeoutMs, break */
 		if ((sec  - m_sec) > timeoutMs) {
-			LOG_INF("%s: wait SW idle timeout\n",
+			LOG_DBG("%s: wait SW idle timeout\n",
 				moduleName);
 			break;
 		}
@@ -5268,7 +5268,7 @@ static int ISP_release(
 	 */
 	/* the power-saving mode */
 	if (g_WaitLockCt) {
-		LOG_INF("wakelock disable!! cnt(%d)\n",	g_WaitLockCt);
+		LOG_DBG("wakelock disable!! cnt(%d)\n",	g_WaitLockCt);
 #ifdef CONFIG_PM_SLEEP
 		__pm_relax(&isp_wake_lock);
 #endif
@@ -5353,7 +5353,7 @@ static int ISP_release(
 
 EXIT:
 
-	LOG_INF("- X. UserCount: %d. G_u4EnableClockCount:%d",
+	LOG_DBG("- X. UserCount: %d. G_u4EnableClockCount:%d",
 		IspInfo.UserCount,
 		G_u4EnableClockCount);
 	mutex_unlock(&open_isp_mutex);
@@ -5375,7 +5375,7 @@ static int ISP_mmap(struct file *pFile, struct vm_area_struct *pVma)
 	pVma->vm_page_prot = pgprot_noncached(pVma->vm_page_prot);
 	pfn = pVma->vm_pgoff << PAGE_SHIFT;
 
-	/* LOG_INF("ISP_mmap: vm_pgoff(0x%lx),
+	/* LOG_DBG("ISP_mmap: vm_pgoff(0x%lx),
 	 * pfn(0x%x),phy(0x%lx),vm_start(0x%lx),
 	 * vm_end(0x%lx),length(0x%lx)\n",
 	 * pVma->vm_pgoff, pfn,
@@ -5388,7 +5388,7 @@ static int ISP_mmap(struct file *pFile, struct vm_area_struct *pVma)
 	case CAM_B_BASE_HW:
 	case CAM_C_BASE_HW:
 		if (length > ISP_REG_RANGE) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"mmap range error :module(0x%x) length(0x%lx),ISP_REG_RANGE(0x%lx)!\n",
 				pfn, length, ISP_REG_RANGE);
 			return -EAGAIN;
@@ -5402,14 +5402,14 @@ static int ISP_mmap(struct file *pFile, struct vm_area_struct *pVma)
 	case CAMSV_5_BASE_HW:
 	case UNI_A_BASE_HW:
 		if (length > ISP_REG_RANGE/2) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"mmap range error :module(0x%x) length(0x%lx),ISP_REG_RANGE(0x%lx)!\n",
 				pfn, length, ISP_REG_RANGE/2);
 			return -EAGAIN;
 		}
 		break;
 	default:
-		LOG_NOTICE("Illegal starting HW addr for mmap!\n");
+		LOG_DBG("Illegal starting HW addr for mmap!\n");
 		return -EAGAIN;
 	}
 	if (remap_pfn_range(pVma,
@@ -5470,13 +5470,13 @@ static inline int ISP_RegCharDev(void)
 	/*  */
 	Ret = alloc_chrdev_region(&IspDevNo, 0, 1, ISP_DEV_NAME);
 	if ((Ret) < 0) {
-		LOG_NOTICE("alloc_chrdev_region failed, %d\n", Ret);
+		LOG_DBG("alloc_chrdev_region failed, %d\n", Ret);
 		return Ret;
 	}
 	/* Allocate driver */
 	pIspCharDrv = cdev_alloc();
 	if (pIspCharDrv == NULL) {
-		LOG_NOTICE("cdev_alloc failed\n");
+		LOG_DBG("cdev_alloc failed\n");
 		Ret = -ENOMEM;
 		goto EXIT;
 	}
@@ -5487,7 +5487,7 @@ static inline int ISP_RegCharDev(void)
 	/* Add to system */
 	Ret = cdev_add(pIspCharDrv, IspDevNo, 1);
 	if ((Ret) < 0) {
-		LOG_NOTICE("Attatch file operation failed, %d\n", Ret);
+		LOG_DBG("Attatch file operation failed, %d\n", Ret);
 		goto EXIT;
 	}
 	/*  */
@@ -5517,7 +5517,7 @@ static int ISP_probe(struct platform_device *pDev)
 	struct device *dev = NULL;
 #endif
 
-	LOG_INF("- E. ISP driver probe.\n");
+	LOG_DBG("- E. ISP driver probe.\n");
 
 	/* Get platform_device parameters */
 #ifdef CONFIG_OF
@@ -5551,7 +5551,7 @@ static int ISP_probe(struct platform_device *pDev)
 		return -ENOMEM;
 	}
 
-	LOG_INF("nr_isp_devs=%d,devnode(%s), map_addr=0x%lx\n",
+	LOG_DBG("nr_isp_devs=%d,devnode(%s), map_addr=0x%lx\n",
 		nr_isp_devs, pDev->dev.of_node->name,
 		(unsigned long)isp_dev->regs);
 
@@ -5589,7 +5589,7 @@ static int ISP_probe(struct platform_device *pDev)
 					return Ret;
 				}
 
-			LOG_INF("nr_isp_devs=%d, devnode(%s), irq=%d,ISR: %s\n",
+			LOG_DBG("nr_isp_devs=%d, devnode(%s), irq=%d,ISR: %s\n",
 					nr_isp_devs,
 					pDev->dev.of_node->name,
 					isp_dev->irq,
@@ -5599,14 +5599,14 @@ static int ISP_probe(struct platform_device *pDev)
 		}
 
 		if (i >= ISP_IRQ_TYPE_AMOUNT)
-			LOG_INF(
+			LOG_DBG(
 				"No corresponding ISR!!:nr_isp_devs=%d,devnode(%s), irq=%d\n",
 				nr_isp_devs, pDev->dev.of_node->name,
 				isp_dev->irq);
 
 
 	} else {
-		LOG_INF("No IRQ!!: nr_isp_devs=%d, devnode(%s), irq=%d\n",
+		LOG_DBG("No IRQ!!: nr_isp_devs=%d, devnode(%s), irq=%d\n",
 			nr_isp_devs, pDev->dev.of_node->name,
 			isp_dev->irq);
 	}
@@ -5624,7 +5624,7 @@ static int ISP_probe(struct platform_device *pDev)
 		pIspClass = class_create(THIS_MODULE, "ispdrv");
 		if (IS_ERR(pIspClass)) {
 			Ret = PTR_ERR(pIspClass);
-			LOG_NOTICE("Unable to create class, err = %d\n", Ret);
+			LOG_DBG("Unable to create class, err = %d\n", Ret);
 			goto EXIT;
 		}
 		dev = device_create(pIspClass, NULL,
@@ -5677,31 +5677,31 @@ static int ISP_probe(struct platform_device *pDev)
 			devm_clk_get(&pDev->dev, "CAMSYS_CAMSV1_CGPDN");
 
 		if (IS_ERR(isp_clk.ISP_SCP_SYS_DIS)) {
-			LOG_NOTICE("cannot get ISP_SCP_SYS_DIS clock\n");
+			LOG_DBG("cannot get ISP_SCP_SYS_DIS clock\n");
 			return PTR_ERR(isp_clk.ISP_SCP_SYS_DIS);
 		}
 		if (IS_ERR(isp_clk.ISP_SCP_SYS_ISP)) {
-			LOG_NOTICE("cannot get ISP_SCP_SYS_ISP clock\n");
+			LOG_DBG("cannot get ISP_SCP_SYS_ISP clock\n");
 			return PTR_ERR(isp_clk.ISP_SCP_SYS_ISP);
 		}
 		if (IS_ERR(isp_clk.ISP_SCP_SYS_CAM)) {
-			LOG_NOTICE("cannot get ISP_SCP_SYS_CAM clock\n");
+			LOG_DBG("cannot get ISP_SCP_SYS_CAM clock\n");
 			return PTR_ERR(isp_clk.ISP_SCP_SYS_CAM);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSYS)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSYS clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSYS clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSYS);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMTG)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMTG clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMTG clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMTG);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSV0)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSV0 clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSV0 clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSV0);
 		}
 		if (IS_ERR(isp_clk.ISP_CAM_CAMSV1)) {
-			LOG_NOTICE("cannot get ISP_CAM_CAMSV1 clock\n");
+			LOG_DBG("cannot get ISP_CAM_CAMSV1 clock\n");
 			return PTR_ERR(isp_clk.ISP_CAM_CAMSV1);
 		}
 
@@ -5845,7 +5845,7 @@ EXIT:
 
 	}
 
-	LOG_INF("- X. ISP driver probe.\n");
+	LOG_DBG("- X. ISP driver probe.\n");
 
 	return Ret;
 }
@@ -5919,7 +5919,7 @@ static int ISP_suspend(
 				G_u4EnableClockCount,
 				atomic_read(&G_u4DevNodeCt));
 		} else if (IspInfo.UserCount != 0) {
-			LOG_INF(
+			LOG_DBG(
 				"%s - X. UserCount=%d,G_u4EnableClockCount=0,wakelock:%d,devct:%d\n",
 				moduleName,
 				IspInfo.UserCount,
@@ -5965,7 +5965,7 @@ static int ISP_suspend(
 		module = ISP_CAMSV5_IDX;
 		break;
 	case ISP_IRQ_TYPE_AMOUNT:
-		LOG_NOTICE("dev name is not found (%s)", moduleName);
+		LOG_DBG("dev name is not found (%s)", moduleName);
 		break;
 	case ISP_IRQ_TYPE_INT_UNI_A_ST:
 	default:
@@ -5980,7 +5980,7 @@ static int ISP_suspend(
 	/*LOG_DBG("%s: Rs_TG(0x%08x)\n", moduleName, regVal);*/
 
 	if (regVal & 0x01) {
-		LOG_INF("%s_suspend,disable VF,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_suspend,disable VF,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName,
 			g_WaitLockCt,
 			G_u4EnableClockCount,
@@ -6006,7 +6006,7 @@ static int ISP_suspend(
 			if (regTGSt == 1)
 				break;
 
-			LOG_INF("%s: wait 1VD (%d)\n", moduleName, loopCnt);
+			LOG_DBG("%s: wait 1VD (%d)\n", moduleName, loopCnt);
 			ret = ISP_WaitIrq(&waitirq);
 			/* first wait is clear wait,
 			 * others are non-clear wait
@@ -6015,7 +6015,7 @@ static int ISP_suspend(
 		} while (--loopCnt);
 
 		if (-ERESTARTSYS == ret) {
-			LOG_INF("%s: interrupt by system signal,wait idle\n",
+			LOG_DBG("%s: interrupt by system signal,wait idle\n",
 				moduleName);
 			/* timer*/
 			m_sec = ktime_get();
@@ -6031,9 +6031,9 @@ static int ISP_suspend(
 					break;
 			}
 			if (regTGSt == 1)
-				LOG_INF("%s: wait idle done\n", moduleName);
+				LOG_DBG("%s: wait idle done\n", moduleName);
 			else
-				LOG_INF("%s: wait idle timeout(%lld)\n",
+				LOG_DBG("%s: wait idle timeout(%lld)\n",
 					moduleName, (sec - m_sec));
 		}
 
@@ -6048,7 +6048,7 @@ static int ISP_suspend(
 		regVal = ISP_RD32(CAM_REG_TG_SEN_MODE(module));
 		ISP_WR32(CAM_REG_TG_SEN_MODE(module), (regVal & (~0x01)));
 	} else {
-		LOG_INF("%s_suspend,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_suspend,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName,
 			g_WaitLockCt,
 			G_u4EnableClockCount,
@@ -6063,7 +6063,7 @@ EXIT:
 		loopCnt = G_u4EnableClockCount;
 		spin_unlock(&(IspInfo.SpinLockClock));
 
-		LOG_INF("%s - X. wakelock:%d, last dev node,disable clk:%d\n",
+		LOG_DBG("%s - X. wakelock:%d, last dev node,disable clk:%d\n",
 			moduleName, g_WaitLockCt, loopCnt);
 		while (loopCnt > 0) {
 			ISP_EnableClock(MFALSE);
@@ -6135,7 +6135,7 @@ static int ISP_resume(struct platform_device *pDev)
 		module = ISP_CAMSV5_IDX;
 		break;
 	case ISP_IRQ_TYPE_AMOUNT:
-		LOG_NOTICE("dev name is not found(%s)", moduleName);
+		LOG_DBG("dev name is not found(%s)", moduleName);
 		break;
 	case ISP_IRQ_TYPE_INT_UNI_A_ST:
 	default:
@@ -6152,7 +6152,7 @@ static int ISP_resume(struct platform_device *pDev)
 	ISP_EnableClock(MTRUE);
 
 	if (SuspnedRecord[module]) {
-		LOG_INF("%s_resume,enable VF,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_resume,enable VF,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName,
 			g_WaitLockCt,
 			G_u4EnableClockCount,
@@ -6170,7 +6170,7 @@ static int ISP_resume(struct platform_device *pDev)
 		ISP_WR32(
 			CAM_REG_TG_VF_CON(module), (regVal | 0x01));
 	} else {
-		LOG_INF("%s_resume,wakelock:%d,clk:%d,devct:%d\n",
+		LOG_DBG("%s_resume,wakelock:%d,clk:%d,devct:%d\n",
 			moduleName,
 			g_WaitLockCt,
 			G_u4EnableClockCount,
@@ -6267,7 +6267,7 @@ static ssize_t ISP_DumpRegToProc(
 	size_t off,
 	loff_t *Count)
 {
-	LOG_NOTICE("%s: Not implement", __func__);
+	LOG_DBG("%s: Not implement", __func__);
 	return 0;
 }
 
@@ -6280,7 +6280,7 @@ static ssize_t ISP_RegDebug(
 	size_t Count,
 	loff_t *pData)
 {
-	LOG_NOTICE("%s: Not implement", __func__);
+	LOG_DBG("%s: Not implement", __func__);
 	return 0;
 }
 
@@ -6293,7 +6293,7 @@ static ssize_t CAMIO_DumpRegToProc(
 	size_t off,
 	loff_t *Count)
 {
-	LOG_NOTICE("%s: Not implement", __func__);
+	LOG_DBG("%s: Not implement", __func__);
 	return 0;
 }
 
@@ -6306,7 +6306,7 @@ static ssize_t CAMIO_RegDebug(
 	size_t Count,
 	loff_t *pData)
 {
-	LOG_NOTICE("%s: Not implement", __func__);
+	LOG_DBG("%s: Not implement", __func__);
 	return 0;
 }
 
@@ -6342,7 +6342,7 @@ static int __init ISP_Init(void)
 	/*  */
 	Ret = platform_driver_register(&IspDriver);
 	if ((Ret) < 0) {
-		LOG_NOTICE("platform_driver_register fail");
+		LOG_DBG("platform_driver_register fail");
 		return Ret;
 	}
 
@@ -6360,7 +6360,7 @@ static int __init ISP_Init(void)
 
 		comp_str = kmalloc(64, GFP_KERNEL);
 		if (comp_str == NULL) {
-			LOG_NOTICE("kmalloc failed for finding compatible\n");
+			LOG_DBG("kmalloc failed for finding compatible\n");
 			break;
 		}
 
@@ -6368,24 +6368,24 @@ static int __init ISP_Init(void)
 
 			if (snprintf(comp_str, 64,
 					"mediatek,smi_larb%d", i) < 0) {
-				LOG_NOTICE("[Error] %s: snprintf failed",
+				LOG_DBG("[Error] %s: snprintf failed",
 					   __func__);
 			}
-			LOG_INF("Finding SMI_LARB compatible:%s\n", comp_str);
+			LOG_DBG("Finding SMI_LARB compatible:%s\n", comp_str);
 
 			node = of_find_compatible_node(NULL, NULL, comp_str);
 			if (!node) {
-				LOG_NOTICE("find %s node failed!\n", comp_str);
+				LOG_DBG("find %s node failed!\n", comp_str);
 				SMI_LARB_BASE[i] = 0;
 				continue;
 			}
 			SMI_LARB_BASE[i] = of_iomap(node, 0);
 			if (!SMI_LARB_BASE[i]) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"unable to map SMI_LARB_BASE registers!\n");
 				break;
 			}
-			LOG_INF("SMI_LARB%d_BASE: %p\n", i, SMI_LARB_BASE[i]);
+			LOG_DBG("SMI_LARB%d_BASE: %p\n", i, SMI_LARB_BASE[i]);
 		}
 
 		/* if (comp_str) coverity: no need if, kfree is safe */
@@ -6394,7 +6394,7 @@ static int __init ISP_Init(void)
 	#endif
 	node = of_find_compatible_node(NULL, NULL, "mediatek,mmsys_config");
 	if (!node) {
-		LOG_NOTICE("find mmsys_config node failed!!!\n");
+		LOG_DBG("find mmsys_config node failed!!!\n");
 		return -ENODEV;
 	}
 
@@ -6422,7 +6422,7 @@ static int __init ISP_Init(void)
 				pBuf_kmalloc[j] = kmalloc(
 					i + 2 * PAGE_SIZE, GFP_KERNEL);
 				if ((pBuf_kmalloc[j]) == NULL) {
-					LOG_NOTICE("mem not enough\n");
+					LOG_DBG("mem not enough\n");
 					return -ENOMEM;
 				}
 				memset(pBuf_kmalloc[j], 0x00, i);
@@ -6432,7 +6432,7 @@ static int __init ISP_Init(void)
 					RT_BUF_TBL_NPAGES + 2) *
 					PAGE_SIZE, GFP_KERNEL);
 				if ((pBuf_kmalloc[j]) == NULL) {
-					LOG_NOTICE("mem not enough\n");
+					LOG_DBG("mem not enough\n");
 					return -ENOMEM;
 				}
 				memset(pBuf_kmalloc[j], 0x00, (
@@ -6468,7 +6468,7 @@ static int __init ISP_Init(void)
 	}
 	pLog_kmalloc = kmalloc(i, GFP_KERNEL);
 	if ((pLog_kmalloc) == NULL) {
-		LOG_NOTICE("mem not enough\n");
+		LOG_DBG("mem not enough\n");
 		return -ENOMEM;
 	}
 	memset(pLog_kmalloc, 0x00, i);
@@ -6481,7 +6481,7 @@ static int __init ISP_Init(void)
 			 */
 			tmp = (void *)((char *)tmp +
 				(NORMAL_STR_LEN * DBG_PAGE));
-			gSvLog[j]._str[i][_LOG_INF] = (char *)tmp;
+			gSvLog[j]._str[i][_LOG_DBG] = (char *)tmp;
 			/* tmp = (void*) ((unsigned int)tmp +
 			 * (NORMAL_STR_LEN*INF_PAGE));
 			 */
@@ -6782,7 +6782,7 @@ enum CAM_FrameST Irq_CAM_FrameStatus(
 	unsigned int i;
 
 	if ((module < ISP_CAM_A_IDX) || (module >= ISP_CAMSV0_IDX)) {
-		LOG_NOTICE("unsupported module:0x%x\n", module);
+		LOG_DBG("unsupported module:0x%x\n", module);
 		return CAM_FST_DROP_FRAME;
 	}
 
@@ -6907,7 +6907,7 @@ enum CAM_FrameST Irq_CAM_FrameStatus(
 							fbc_ctrl2[dma_arry_map[
 							i]].Bits.FBC_CNT;
 				} else {
-					LOG_INF(
+					LOG_DBG(
 					"cam:%d dma:%d overwrite preveFbcDropCnt %d <= %d subsample:%d\n",
 					irq_mod, i,
 					IspInfo.TstpQInfo[irq_mod]
@@ -7277,20 +7277,20 @@ static enum CAM_FrameST Irq_CAM_SttFrameStatus(
 	case ISP_CAM_B_IDX:
 	case ISP_CAM_C_IDX:
 		if (dma_id >= _cam_max_) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"LINE_%d ERROR: unsupported module:0x%x dma:%d\n",
 				__LINE__, module, dma_id);
 			return CAM_FST_DROP_FRAME;
 		}
 		if (dma_arry_map[dma_id] < 0) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"LINE_%d ERROR: unsupported module:0x%x dma:%d\n",
 				__LINE__, module, dma_id);
 			return CAM_FST_DROP_FRAME;
 		}
 		break;
 	default:
-		LOG_NOTICE(
+		LOG_DBG(
 			"LINE_%d ERROR: unsupported module:0x%x dma:%d\n",
 			__LINE__, module, dma_id);
 		return CAM_FST_DROP_FRAME;
@@ -7363,7 +7363,7 @@ static enum CAM_FrameST Irq_CAM_SttFrameStatus(
 				else
 					product *= fbc_ctrl2.Bits.FBC_CNT;
 			} else {
-				LOG_INF(
+				LOG_DBG(
 				"cam:%d dma:%d overwrite preveFbcDropCnt %d <= %d\n",
 					irq_mod,
 					dma_id,
@@ -7458,7 +7458,7 @@ static int32_t ISP_PushBufTimestamp(unsigned int module,
 		reg_module = ISP_CAM_C_IDX;
 		break;
 	default:
-		LOG_NOTICE("Unsupport module:x%x\n", module);
+		LOG_DBG("Unsupport module:x%x\n", module);
 		return -EFAULT;
 	}
 
@@ -7516,7 +7516,7 @@ static int32_t ISP_PushBufTimestamp(unsigned int module,
 				CAM_REG_FBC_UFGO_CTL2(reg_module));
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
@@ -7531,7 +7531,7 @@ static int32_t ISP_PushBufTimestamp(unsigned int module,
 
 	if (((fbc_ctrl2.Bits.WCNT + frmPeriod) & 63) ==
 		IspInfo.TstpQInfo[module].Dmao[dma_id].PrevFbcWCnt) {
-		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			"Cam:%d dma:%d ignore push wcnt_%d_%d\n",
 			module, dma_id, IspInfo.TstpQInfo[
 				module].Dmao[dma_id].PrevFbcWCnt,
@@ -7586,7 +7586,7 @@ static int32_t ISP_PopBufTimestamp(unsigned int module,
 		case _ufgo_:
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
@@ -7600,12 +7600,12 @@ static int32_t ISP_PopBufTimestamp(unsigned int module,
 		case _camsv_imgo_:
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
 	default:
-		LOG_NOTICE("Unsupport module:x%x\n", module);
+		LOG_DBG("Unsupport module:x%x\n", module);
 		return -EFAULT;
 	}
 
@@ -7643,7 +7643,7 @@ static int32_t ISP_WaitTimestampReady(unsigned int
 		return 0;
 	}
 
-	LOG_INF("Wait module:%d dma:%d timestamp ready W/R:%d/%d\n",
+	LOG_DBG("Wait module:%d dma:%d timestamp ready W/R:%d/%d\n",
 		module,	dma_id,
 		(unsigned int)IspInfo.TstpQInfo[
 			module].Dmao[dma_id].TotalWrCnt,
@@ -7663,7 +7663,7 @@ static int32_t ISP_WaitTimestampReady(unsigned int
 			module].Dmao[dma_id].TotalWrCnt >
 				IspInfo.TstpQInfo[module].Dmao[
 					dma_id].TotalRdCnt))) {
-			LOG_INF(
+			LOG_DBG(
 				"interrupted by system signal,return value(%d)\n",
 				_timeout);
 			return -ERESTARTSYS;
@@ -7672,11 +7672,11 @@ static int32_t ISP_WaitTimestampReady(unsigned int
 		if (_timeout > 0)
 			break;
 
-		LOG_INF("WARNING: cam:%d dma:%d wait left count %d\n",
+		LOG_DBG("WARNING: cam:%d dma:%d wait left count %d\n",
 			module, dma_id, wait_cnt);
 	}
 	if (wait_cnt == 0) {
-		LOG_NOTICE("ERROR: cam:%d dma:%d wait timestamp timeout!!!\n",
+		LOG_DBG("ERROR: cam:%d dma:%d wait timestamp timeout!!!\n",
 			module, dma_id);
 		return -EFAULT;
 	}
@@ -7759,7 +7759,7 @@ static int32_t ISP_CompensateMissingSofTime(
 				CAM_REG_FBC_UFGO_CTL2(reg_module));
 			break;
 		default:
-			LOG_NOTICE("Unsupport dma:x%x\n", dma_id);
+			LOG_DBG("Unsupport dma:x%x\n", dma_id);
 			return -EFAULT;
 		}
 		break;
@@ -7770,7 +7770,7 @@ static int32_t ISP_CompensateMissingSofTime(
 	case ISP_IRQ_TYPE_INT_CAMSV_4_ST:
 	case ISP_IRQ_TYPE_INT_CAMSV_5_ST:
 	default:
-		LOG_NOTICE("Unsupport module:x%x\n", module);
+		LOG_DBG("Unsupport module:x%x\n", module);
 		return -EFAULT;
 	}
 
@@ -7785,7 +7785,7 @@ static int32_t ISP_CompensateMissingSofTime(
 		if (dmao_mask) {
 			IRQ_LOG_KEEPER(module,
 				m_CurrentPPB,
-				_LOG_INF,
+				_LOG_DBG,
 				"Cam:%d dma:%d ignore compensate wcnt_%d_%d\n",
 				module, dma_id, IspInfo.TstpQInfo[
 					module].Dmao[dma_id].PrevFbcWCnt,
@@ -7805,7 +7805,7 @@ static int32_t ISP_CompensateMissingSofTime(
 
 	if (delta_wcnt > 255) {
 		if (dmao_mask) {
-			LOG_NOTICE("ERROR: Cam:%d dma:%d WRONG WCNT:%d_%d_%d\n",
+			LOG_DBG("ERROR: Cam:%d dma:%d WRONG WCNT:%d_%d_%d\n",
 				module,
 				dma_id,
 				delta_wcnt,
@@ -7816,7 +7816,7 @@ static int32_t ISP_CompensateMissingSofTime(
 		return -EFAULT;
 	} else if (delta_wcnt > 6) {
 		if (dmao_mask) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"WARNING: Cam:%d dma:%d SUSPICIOUS WCNT:%d_%d_%d\n",
 				module,
 				dma_id,
@@ -7856,7 +7856,7 @@ static int32_t ISP_CompensateMissingSofTime(
 			1000000 + usec) - time_prev1.usec;
 	} else {
 		if (dmao_mask) {
-			LOG_NOTICE(
+			LOG_DBG(
 			"ERROR: Cam:%d dma:%d current timestamp:cur: %d.%06d prev1: %d.%06d\n",
 				module, dma_id, sec, usec,
 				time_prev1.sec, time_prev1.usec);
@@ -7871,7 +7871,7 @@ static int32_t ISP_CompensateMissingSofTime(
 			time_prev1.usec) - time_prev2.usec;
 	} else {
 		if (dmao_mask) {
-			LOG_NOTICE(
+			LOG_DBG(
 			"ERROR: Cam:%d dma:%d previous timestamp:prev1: %d.%06d prev2: %d.%06d\n",
 				module, dma_id, time_prev1.sec, time_prev1.usec,
 				time_prev2.sec, time_prev2.usec);
@@ -7882,7 +7882,7 @@ static int32_t ISP_CompensateMissingSofTime(
 	if (delta_time > (max_delta_time / delta_wcnt)) {
 		if (dmao_mask) {
 			IRQ_LOG_KEEPER(module, m_CurrentPPB,
-				_LOG_INF,
+				_LOG_DBG,
 				"WARNING: Cam:%d dma:%d delta time too large:cur %dus max %dus patch wcnt: %d\n",
 				module, dma_id, delta_time,
 				max_delta_time, delta_wcnt);
@@ -7902,7 +7902,7 @@ static int32_t ISP_CompensateMissingSofTime(
 	}
 
 	if (dmao_mask) {
-		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			"Cam:%d dma:%d wcnt:%d_%d_%d T:%d.%06d_.%06d_%d.%06d\n",
 			module, dma_id, delta_wcnt,
 			IspInfo.TstpQInfo[module].Dmao[
@@ -7915,7 +7915,7 @@ static int32_t ISP_CompensateMissingSofTime(
 	if (IspInfo.TstpQInfo[module].Dmao[
 		dma_id].PrevFbcWCnt != fbc_ctrl2.Bits.WCNT) {
 		if (dmao_mask) {
-			LOG_NOTICE(
+			LOG_DBG(
 			"ERROR: Cam:%d dma:%d strange WCNT SW_HW: %d_%d\n",
 				module, dma_id,
 				IspInfo.TstpQInfo[module].Dmao[
@@ -7961,7 +7961,7 @@ static int32_t ISP_PatchTimestamp(unsigned int module,
 		cur_tstp - prev_tstp) - frm_dt*(frmPeriod-1));
 
 	if (frm_dt == 0) {
-		LOG_INF("WARNING: timestamp delta too small:%d\n",
+		LOG_DBG("WARNING: timestamp delta too small:%d\n",
 			(int)(cur_tstp - prev_tstp));
 	}
 
@@ -7969,7 +7969,7 @@ static int32_t ISP_PatchTimestamp(unsigned int module,
 	while (target_wridx != curr_wridx) {
 
 		if (i > frmPeriod) {
-			LOG_NOTICE(
+			LOG_DBG(
 				"Error: too many intpl in sub-sample period %d_%d\n",
 				target_wridx, curr_wridx);
 			return -EFAULT;
@@ -8144,7 +8144,7 @@ irqreturn_t ISP_Irq_CAMSV(enum ISP_IRQ_TYPE_ENUM irq_module,
 	if ((IrqStatus & SV_HW_PASS1_DON_ST) &&
 		(IrqStatus & SV_SOF_INT_ST)) {
 		if (cur_v_cnt != sof_count[module])
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"isp sof_don block, %d_%d\n",
 				cur_v_cnt, sof_count[module]);
 	}
@@ -8165,7 +8165,7 @@ irqreturn_t ISP_Irq_CAMSV(enum ISP_IRQ_TYPE_ENUM irq_module,
 		if (IspInfo.DebugMask & ISP_DBG_INT) {
 			IRQ_LOG_KEEPER(module,
 				m_CurrentPPB,
-				_LOG_INF,
+				_LOG_DBG,
 				"%s P1_DON_%d(0x%08x_0x%08x) stamp[0x%08x]\n",
 				str,
 				(sof_count[module]) ?
@@ -8198,7 +8198,7 @@ irqreturn_t ISP_Irq_CAMSV(enum ISP_IRQ_TYPE_ENUM irq_module,
 				gSTime[module].usec = usec;
 			}
 
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			"%s P1_SOF_%d_%d(0x%08x_0x%08x,0x%08x),int_us:0x%08x, stamp[0x%08x]\n",
 				str,
 				sof_count[module],
@@ -8219,7 +8219,7 @@ irqreturn_t ISP_Irq_CAMSV(enum ISP_IRQ_TYPE_ENUM irq_module,
 			/* dbg information only */
 			if (cur_v_cnt != ((ISP_RD32(CAMSV_REG_TG_INTER_ST(
 				reg_module)) & 0x00FF0000) >> 16)) {
-				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 					"SW ISR right on next hw p1_done\n");
 			}
 
@@ -8377,11 +8377,11 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 			reg_module = ISP_CAM_C_IDX;
 			break;
 		default:
-			LOG_NOTICE("Wrong IRQ module: %d",
+			LOG_DBG("Wrong IRQ module: %d",
 				(unsigned int)irg_module);
 			break;
 		}
-		LOG_NOTICE("+CQ recover");
+		LOG_DBG("+CQ recover");
 		reg_module_array[0] = reg_module;
 		twinStatus.Raw = ISP_RD32(CAM_REG_CTL_TWIN_STATUS(reg_module));
 
@@ -8406,7 +8406,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 					reg_module_array[1] = ISP_CAM_C_IDX;
 						break;
 					default:
-					LOG_NOTICE(
+					LOG_DBG(
 					"twin module is invalid! recover fail");
 					goto EXIT_CQ_RECOVER;
 					}
@@ -8422,7 +8422,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 					reg_module_array[2] = ISP_CAM_C_IDX;
 					break;
 					default:
-					LOG_NOTICE(
+					LOG_DBG(
 					"twin module is invalid! recover fail");
 					goto EXIT_CQ_RECOVER;
 					}
@@ -8530,28 +8530,28 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 		(ISP_RD32(CAM_REG_TG_VF_CON(reg_module)) & 0xFFFFFFFE));
 	ISP_WR32(CAM_REG_TG_SEN_MODE(reg_module),
 		(ISP_RD32(CAM_REG_TG_SEN_MODE(reg_module)) & 0xFFFFFFFE));
-	LOG_NOTICE("disable viewfinder & cmos to do CQ recover");
+	LOG_DBG("disable viewfinder & cmos to do CQ recover");
 
 	/* 3. disable double buffer */
 	for (i = 0; i < reg_module_count; i++) {
 		tmp_module = reg_module_array[i];
 		ISP_WR32(CAM_REG_CTL_MISC(tmp_module),
 			(ISP_RD32(CAM_REG_CTL_MISC(tmp_module)) & 0xFFFFFFEF));
-		LOG_NOTICE("disable double buffer CAM%d to do CQ recover",
+		LOG_DBG("disable double buffer CAM%d to do CQ recover",
 			tmp_module);
 	}
 
-	LOG_NOTICE("start HW recover due to CQ over Vsync ...\n");
-	LOG_NOTICE("fbc:imgo:0x%x,rrzo:0x%x,ufeo:0x%x, ufgo:0x%x\n",
+	LOG_DBG("start HW recover due to CQ over Vsync ...\n");
+	LOG_DBG("fbc:imgo:0x%x,rrzo:0x%x,ufeo:0x%x, ufgo:0x%x\n",
 			fbc_ctrl2[reg_module][_imgo_].Raw,
 			fbc_ctrl2[reg_module][_rrzo_].Raw,
 			fbc_ctrl2[reg_module][_ufeo_].Raw,
 			fbc_ctrl2[reg_module][_ufgo_].Raw);
-	LOG_NOTICE("rsso:0x%x,lmvo:0x%x,lcso:0x%x\n",
+	LOG_DBG("rsso:0x%x,lmvo:0x%x,lcso:0x%x\n",
 			fbc_ctrl2[reg_module][_rsso_].Raw,
 			fbc_ctrl2[reg_module][_lmvo_].Raw,
 			fbc_ctrl2[reg_module][_lcso_].Raw);
-	LOG_NOTICE("fbc:aao:0x%x,afo:0x%x,flko:0x%x,pdo:0x%x,pso:0x%x\n",
+	LOG_DBG("fbc:aao:0x%x,afo:0x%x,flko:0x%x,pdo:0x%x,pso:0x%x\n",
 			fbc_ctrl2[reg_module][_aao_].Raw,
 			fbc_ctrl2[reg_module][_afo_].Raw,
 			fbc_ctrl2[reg_module][_flko_].Raw,
@@ -8647,14 +8647,14 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 		if (cq_ctrl.Bits.CAMCQ_CQ_EN == 0x1) {
 			ISP_WR32(CAM_REG_CQ_THR0_BASEADDR(tmp_module),
 				g_cqBaseAddr[tmp_module][0]);
-			LOG_NOTICE("CQ0 base0x%x\n",
+			LOG_DBG("CQ0 base0x%x\n",
 				g_cqBaseAddr[tmp_module][0]);
 			if ((g_cqBaseAddr[tmp_module][0] -
 				(unsigned int)ISP_RD32(
 				CAM_REG_CQ_THR0_BASEADDR(tmp_module))) != 0) {
 				ISP_WR32(CAM_REG_CQ_THR0_BASEADDR(tmp_module),
 					g_cqBaseAddr[tmp_module][0]);
-				LOG_NOTICE("restore CQ0 again\n");
+				LOG_DBG("restore CQ0 again\n");
 			}
 		}
 	}
@@ -8667,12 +8667,12 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 	if (cq_ctrl.Bits.CAMCQ_CQ_EN == 0x1) {
 		ISP_WR32(CAM_REG_CQ_THR4_BASEADDR(tmp_module),
 			g_cqBaseAddr[tmp_module][4]);
-		LOG_NOTICE("CQ4 base0x%x\n", g_cqBaseAddr[tmp_module][4]);
+		LOG_DBG("CQ4 base0x%x\n", g_cqBaseAddr[tmp_module][4]);
 		if ((g_cqBaseAddr[tmp_module][4] - (unsigned int)ISP_RD32(
 			CAM_REG_CQ_THR4_BASEADDR(tmp_module))) != 0) {
 			ISP_WR32(CAM_REG_CQ_THR4_BASEADDR(tmp_module),
 				g_cqBaseAddr[tmp_module][4]);
-			LOG_NOTICE("restore CQ4 again\n");
+			LOG_DBG("restore CQ4 again\n");
 		}
 	}
 	cq_ctrl.Raw = (unsigned int)ISP_RD32(CAM_REG_CQ_THR5_CTL(tmp_module));
@@ -8687,12 +8687,12 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 	if (cq_ctrl.Bits.CAMCQ_CQ_EN == 0x1) {
 		ISP_WR32(CAM_REG_CQ_THR8_BASEADDR(tmp_module),
 			g_cqBaseAddr[tmp_module][8]);
-		LOG_NOTICE("CQ8 base0x%x\n", g_cqBaseAddr[tmp_module][8]);
+		LOG_DBG("CQ8 base0x%x\n", g_cqBaseAddr[tmp_module][8]);
 		if ((g_cqBaseAddr[tmp_module][8] - (unsigned int)ISP_RD32(
 			CAM_REG_CQ_THR8_BASEADDR(tmp_module))) != 0) {
 			ISP_WR32(CAM_REG_CQ_THR8_BASEADDR(tmp_module),
 				g_cqBaseAddr[tmp_module][8]);
-			LOG_NOTICE("restore CQ8 again\n");
+			LOG_DBG("restore CQ8 again\n");
 		}
 	}
 	cq_ctrl.Raw = (unsigned int)ISP_RD32(CAM_REG_CQ_THR10_CTL(tmp_module));
@@ -8703,12 +8703,12 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 	if (cq_ctrl.Bits.CAMCQ_CQ_EN == 0x1) {
 		ISP_WR32(CAM_REG_CQ_THR12_BASEADDR(tmp_module),
 			g_cqBaseAddr[tmp_module][12]);
-		LOG_NOTICE("CQ12 base0x%x\n", g_cqBaseAddr[tmp_module][12]);
+		LOG_DBG("CQ12 base0x%x\n", g_cqBaseAddr[tmp_module][12]);
 		if ((g_cqBaseAddr[tmp_module][12] - (unsigned int)ISP_RD32(
 			CAM_REG_CQ_THR12_BASEADDR(tmp_module))) != 0) {
 			ISP_WR32(CAM_REG_CQ_THR12_BASEADDR(tmp_module),
 				g_cqBaseAddr[tmp_module][12]);
-			LOG_NOTICE("restore CQ12 again\n");
+			LOG_DBG("restore CQ12 again\n");
 		}
 	}
 
@@ -8780,7 +8780,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("waitCQ0 timeout0x%x,0x%x\n",
+					LOG_DBG("waitCQ0 timeout0x%x,0x%x\n",
 					(unsigned int)ISP_RD32(
 					CAM_REG_CTL_START(tmp_module)),
 					cq_done);
@@ -8790,7 +8790,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				DmaStatus2.Raw = g_cqDoneStatus[tmp_module];
 				cq_done |= DmaStatus2.Bits.CQ_THR0_DONE_ST;
 			}
-			LOG_NOTICE("wait CQ0 start 0x%x, base 0x%x\n",
+			LOG_DBG("wait CQ0 start 0x%x, base 0x%x\n",
 			(unsigned int)ISP_RD32(CAM_REG_CTL_START(tmp_module)),
 			(unsigned int)ISP_RD32(CAM_REG_CQ_THR0_BASEADDR(
 			tmp_module)));
@@ -8822,7 +8822,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("wait CQ1 timeout\n");
+					LOG_DBG("wait CQ1 timeout\n");
 					ret = MFALSE;
 					break;
 				}
@@ -8853,7 +8853,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("waitCQ4 timeout0x%x,0x%x\n",
+					LOG_DBG("waitCQ4 timeout0x%x,0x%x\n",
 					(unsigned int)ISP_RD32(
 					CAM_REG_CTL_START(tmp_module)),
 					cq_done);
@@ -8863,7 +8863,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				DmaStatus2.Raw = g_cqDoneStatus[tmp_module];
 				cq_done |= DmaStatus2.Bits.CQ_THR4_DONE_ST;
 			}
-			LOG_NOTICE("wait CQ4 start 0x%x, base 0x%x\n",
+			LOG_DBG("wait CQ4 start 0x%x, base 0x%x\n",
 			(unsigned int)ISP_RD32(CAM_REG_CTL_START(tmp_module)),
 			(unsigned int)ISP_RD32(CAM_REG_CQ_THR4_BASEADDR(
 				tmp_module)));
@@ -8895,7 +8895,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("wait CQ5 timeout\n");
+					LOG_DBG("wait CQ5 timeout\n");
 					ret = MFALSE;
 					break;
 				}
@@ -8926,7 +8926,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("wait CQ7 timeout\n");
+					LOG_DBG("wait CQ7 timeout\n");
 					ret = MFALSE;
 					break;
 				}
@@ -8957,7 +8957,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("waitCQ8 timeout0x%x,0x%x\n",
+					LOG_DBG("waitCQ8 timeout0x%x,0x%x\n",
 					(unsigned int)ISP_RD32(
 					CAM_REG_CTL_START(tmp_module)),
 					cq_done);
@@ -8967,7 +8967,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				DmaStatus2.Raw = g_cqDoneStatus[tmp_module];
 				cq_done |= DmaStatus2.Bits.CQ_THR8_DONE_ST;
 			}
-			LOG_NOTICE("wait CQ8 start 0x%x, base 0x%x\n",
+			LOG_DBG("wait CQ8 start 0x%x, base 0x%x\n",
 			(unsigned int)ISP_RD32(CAM_REG_CTL_START(tmp_module)),
 			(unsigned int)ISP_RD32(CAM_REG_CQ_THR8_BASEADDR(
 			tmp_module)));
@@ -8999,7 +8999,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("wait CQ10 timeout\n");
+					LOG_DBG("wait CQ10 timeout\n");
 					ret = MFALSE;
 					break;
 				}
@@ -9030,7 +9030,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				do_div(sec, 1000); /* usec */
 				usec = do_div(sec, 1000000);/* sec and usec */
 				if ((usec  - m_usec) > timeoutMs) {
-					LOG_NOTICE("CQ12 timeout0x%x, 0x%x\n",
+					LOG_DBG("CQ12 timeout0x%x, 0x%x\n",
 					(unsigned int)ISP_RD32(
 					CAM_REG_CTL_START(tmp_module)),
 					cq_done);
@@ -9040,7 +9040,7 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 				DmaStatus2.Raw = g_cqDoneStatus[tmp_module];
 				cq_done |= DmaStatus2.Bits.CQ_THR12_DONE_ST;
 			}
-			LOG_NOTICE("wait CQ12 start 0x%x, base 0x%x\n",
+			LOG_DBG("wait CQ12 start 0x%x, base 0x%x\n",
 			(unsigned int)ISP_RD32(CAM_REG_CTL_START(tmp_module)),
 			(unsigned int)ISP_RD32(CAM_REG_CQ_THR12_BASEADDR(
 			tmp_module)));
@@ -9100,18 +9100,18 @@ unsigned int CQ_Recover(unsigned int ErrStatus,
 		tmp_module = reg_module_array[i];
 		ISP_WR32(CAM_REG_CTL_MISC(tmp_module),
 			(ISP_RD32(CAM_REG_CTL_MISC(tmp_module)) | 0x10));
-		LOG_NOTICE("en double buf CAM%d for CQ recover", tmp_module);
+		LOG_DBG("en double buf CAM%d for CQ recover", tmp_module);
 	}
 	/* 11. enable TG CMOS & viewFinder */
 	ISP_WR32(CAM_REG_TG_SEN_MODE(reg_module),
 		(ISP_RD32(CAM_REG_TG_SEN_MODE(reg_module)) | 0x1));
 	ISP_WR32(CAM_REG_TG_VF_CON(reg_module),
 		(ISP_RD32(CAM_REG_TG_VF_CON(reg_module)) | 0x1));
-	LOG_NOTICE("turn on TG VF, CMOS to do CQ recover 0x%x, 0x%x",
+	LOG_DBG("turn on TG VF, CMOS to do CQ recover 0x%x, 0x%x",
 		(unsigned int)ISP_RD32(CAM_REG_TG_SEN_MODE(reg_module)),
 		(unsigned int)ISP_RD32(CAM_REG_TG_VF_CON(reg_module)));
 EXIT_CQ_RECOVER:
-		LOG_NOTICE("-CQ recover");
+		LOG_DBG("-CQ recover");
 		/**/
 	}
 	return 0;
@@ -9165,7 +9165,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 		cardinalNum = 2;
 		break;
 	default:
-		LOG_NOTICE("Wrong IRQ module: %d", (unsigned int)module);
+		LOG_DBG("Wrong IRQ module: %d", (unsigned int)module);
 		return IRQ_HANDLED;
 	}
 
@@ -9262,14 +9262,14 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 
 	if ((IrqStatus & HW_PASS1_DON_ST) && (IrqStatus & SOF_INT_ST)) {
 		if (cur_v_cnt != sof_count[module])
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"isp sof_don block, %d_%d\n",
 				cur_v_cnt, sof_count[module]);
 	}
 
 	if ((IrqStatus & HW_PASS1_DON_ST) &&
 		(IspInfo.DebugMask & ISP_DBG_HW_DON)) {
-		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 					"CAM%c P1_HW_DON_%d\n",
 					'A'+cardinalNum,
 					(sof_count[module]) ?
@@ -9280,7 +9280,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 	spin_lock(&(IspInfo.SpinLockIrq[module]));
 	if (IrqStatus & VS_INT_ST) {
 		Vsync_cnt[cardinalNum]++;
-		/*LOG_INF("CAMA N3D:0x%x\n", Vsync_cnt[0]);*/
+		/*LOG_DBG("CAMA N3D:0x%x\n", Vsync_cnt[0]);*/
 	}
 	if (IrqStatus & SW_PASS1_DON_ST) {
 		sec = ktime_get(); /* ns */
@@ -9297,7 +9297,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 		if (IspInfo.DebugMask & ISP_DBG_INT) {
 			/*SW p1_don is not reliable*/
 			if (FrameStatus[module] != CAM_FST_DROP_FRAME) {
-				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 					"CAM%c P1_DON_%d(0x%x_0x%x,0x%x_0x%x)\n",
 					'A'+cardinalNum,
 					(sof_count[module]) ?
@@ -9380,7 +9380,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 			reg_module, module, irqDelay);
 
 		if (FrameStatus[module] == CAM_FST_DROP_FRAME) {
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 				"CAM%c Lost p1 done_%d (0x%x): ",
 				'A'+cardinalNum, sof_count[module], cur_v_cnt);
 		}
@@ -9429,7 +9429,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 					usec);
 			#endif
 
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			"CAM%c P1_SOF_%d_%d(0x%x_0x%x,0x%x_0x%x,0x%x,0x%x,0x%x),int_us:%d,cq:0x%x,dbg:0x%x\n",
 					'A'+cardinalNum,
 					sof_count[module],
@@ -9456,7 +9456,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 					(CAM_REG_CTL_DBG_PORT(reg_module)));
 
 #ifdef ENABLE_STT_IRQ_LOG /*STT addr*/
-			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+			IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			"CAM%c_aa(0x%x_0x%x_0x%x) af(0x%x_0x%x_0x%x),pd(0x%x_0x%x_0x%x),ps(0x%x_0x%x_0x%x)\n",
 					'A'+cardinalNum,
 					ISP_RD32(CAM_REG_AAO_BASE_ADDR(
@@ -9491,7 +9491,7 @@ irqreturn_t ISP_Irq_CAM(enum ISP_IRQ_TYPE_ENUM irq_module)
 			/* dbg information only */
 			if (cur_v_cnt !=
 				ISP_RD32_TG_CAM_FRM_CNT(module, reg_module))
-				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+				IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 					"SW ISR right on next hw p1_done\n");
 
 		}
@@ -9519,7 +9519,7 @@ LB_CAM_SOF_IGNORE:
 #ifdef ENABLE_STT_IRQ_LOG
 	if (DmaStatus & (AAO_DONE_ST|AFO_DONE_ST|PDO_DONE_ST|PSO_DONE_ST)) {
 		IRQ_LOG_KEEPER(module, m_CurrentPPB,
-			_LOG_INF,
+			_LOG_DBG,
 			"CAM%c_STT_Done_%d_0x%x\n",
 			'A'+cardinalNum,
 			(sof_count[module]) ? (
@@ -9572,7 +9572,7 @@ LB_CAM_SOF_IGNORE:
 	}
 	if (DmaStatus & AAO_DONE_ST) {
 #ifdef ENABLE_STT_IRQ_LOG
-		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_INF,
+		IRQ_LOG_KEEPER(module, m_CurrentPPB, _LOG_DBG,
 			"CAM_%c AAO_DONE_%d_%d(aao_ctrl_1:0x%x,aao_ctrl_2:0x%x)\n",
 			'A'+cardinalNum, sof_count[module],
 			ISP_RD32_TG_CAM_FRM_CNT(module, reg_module),
@@ -9631,7 +9631,7 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 				INT_ST_MASK_CAM_WARN) ||
 				(g_ISPIntStatus_SMI[irq_module].ispInt3Err &
 				INT_ST_MASK_CAM_WARN_2)) {
-				LOG_NOTICE(
+				LOG_DBG(
 					"ERR:SMI_DUMP by module:%d\n",
 					irq_module);
 				smi_debug_bus_hang_detect(false, ISP_DEV_NAME);
@@ -9646,7 +9646,7 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 			CQ_Recover(g_ISPIntStatus_SMI[irq_module].ispIntErr,
 				irq_module);
 #endif
-			LOG_NOTICE("ERR:SMI_DUMP by module:%d\n", irq_module);
+			LOG_DBG("ERR:SMI_DUMP by module:%d\n", irq_module);
 			smi_debug_bus_hang_detect(false, ISP_DEV_NAME);
 			g_ISPIntStatus_SMI[irq_module].ispIntErr =
 				g_ISPIntStatus_SMI[irq_module].ispInt3Err = 0;
@@ -9662,7 +9662,7 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 			SV_IMGO_ERR) {
 			if (g_ISPIntStatus_SMI[irq_module].ispIntErr &
 				SV_IMGO_OVERRUN) {
-				LOG_NOTICE("ERR:SMI_DUMP by module:%d\n",
+				LOG_DBG("ERR:SMI_DUMP by module:%d\n",
 					irq_module);
 				smi_debug_bus_hang_detect(false, ISP_DEV_NAME);
 			}
@@ -9671,60 +9671,60 @@ static void SMI_INFO_DUMP(enum ISP_IRQ_TYPE_ENUM irq_module)
 		}
 		break;
 	default:
-		LOG_NOTICE("error:unsupported module:%d\n", irq_module);
+		LOG_DBG("error:unsupported module:%d\n", irq_module);
 		break;
 	}
 #endif
 }
 static void ISP_TaskletFunc_CAM_A(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_A_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_A_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAM_A_ST);
 }
 
 static void ISP_TaskletFunc_CAM_B(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_B_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAM_B_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAM_B_ST);
 }
 
 static void ISP_TaskletFunc_SV_0(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_0_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_0_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_0_ST);
 }
 
 static void ISP_TaskletFunc_SV_1(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_1_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_1_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_1_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_2(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_2_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_2_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_2_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_3(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_3_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_3_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_3_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_4(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_4_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_4_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_4_ST);
 
 }
 
 static void ISP_TaskletFunc_SV_5(unsigned long data)
 {
-	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_5_ST, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(ISP_IRQ_TYPE_INT_CAMSV_5_ST, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(ISP_IRQ_TYPE_INT_CAMSV_5_ST);
 
 }
@@ -9736,7 +9736,7 @@ static void ISP_BH_Workqueue(struct work_struct *pWork)
 	container_of(pWork, struct IspWorkqueTable, isp_bh_work);
 
 	IRQ_LOG_PRINTER(pWorkTable->module, m_CurrentPPB, _LOG_ERR);
-	IRQ_LOG_PRINTER(pWorkTable->module, m_CurrentPPB, _LOG_INF);
+	IRQ_LOG_PRINTER(pWorkTable->module, m_CurrentPPB, _LOG_DBG);
 	SMI_INFO_DUMP(pWorkTable->module);
 }
 #endif
diff --git a/drivers/misc/mediatek/cameraisp/tsf/isp_50/camera_tsf.c b/drivers/misc/mediatek/cameraisp/tsf/isp_50/camera_tsf.c
index f949dfa85..84e816af1 100644
--- a/drivers/misc/mediatek/cameraisp/tsf/isp_50/camera_tsf.c
+++ b/drivers/misc/mediatek/cameraisp/tsf/isp_50/camera_tsf.c
@@ -137,11 +137,11 @@ struct TSF_CLK_STRUCT TSF_clk;
 #define LOG_VRB(format,	args...)    pr_debug(MyTag format, ##args)
 
 #ifdef TSF_DEBUG_USE
-#define LOG_DBG(format, args...)    pr_info(MyTag format, ##args)
+#define LOG_DBG(format, args...)    pr_debug(MyTag format, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
-#define LOG_ERR(format, args...)    pr_info(MyTag format,  ##args)
+#define LOG_ERR(format, args...)    pr_err(MyTag format,  ##args)
 #define LOG_INF(format, args...)    pr_info(MyTag format,  ##args)
 #define LOG_NOTICE(format, args...) pr_notice(MyTag format,  ##args)
 
diff --git a/drivers/misc/mediatek/cameraisp/wpe/isp_50/camera_wpe.c b/drivers/misc/mediatek/cameraisp/wpe/isp_50/camera_wpe.c
index 8e3a72864..ecde31386 100644
--- a/drivers/misc/mediatek/cameraisp/wpe/isp_50/camera_wpe.c
+++ b/drivers/misc/mediatek/cameraisp/wpe/isp_50/camera_wpe.c
@@ -141,7 +141,7 @@ pr_debug(MyTag "[%s] " format, __func__, ##args)
 #define WPE_DEBUG
 #ifdef WPE_DEBUG
 #define LOG_DBG(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_debug(MyTag "[%s] " format, __func__, ##args)
 #else
 #define LOG_DBG(format, args...)
 #endif
@@ -151,9 +151,9 @@ pr_info(MyTag "[%s] " format, __func__, ##args)
 #define LOG_NOTICE(format, args...) \
 pr_notice(MyTag "[%s] " format, __func__, ##args)
 #define LOG_WRN(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_warn(MyTag "[%s] " format, __func__, ##args)
 #define LOG_ERR(format, args...) \
-pr_info(MyTag "[%s] " format, __func__, ##args)
+pr_err(MyTag "[%s] " format, __func__, ##args)
 #define LOG_AST(format, args...) \
 pr_debug(MyTag "[%s] " format, __func__, ##args)
 
diff --git a/drivers/misc/mediatek/ccci_util/ccci_util_lib_fo.c b/drivers/misc/mediatek/ccci_util/ccci_util_lib_fo.c
index 742fcef31..183339b4d 100644
--- a/drivers/misc/mediatek/ccci_util/ccci_util_lib_fo.c
+++ b/drivers/misc/mediatek/ccci_util/ccci_util_lib_fo.c
@@ -236,7 +236,7 @@ static unsigned int compatible_convert(unsigned int src_rat)
 		 i < (sizeof(ubin_convert_table_src)/sizeof(unsigned int));
 		 i++) {
 		if (ubin_convert_table_src[i] == src_rat) {
-			CCCI_UTIL_INF_MSG(
+			CCCI_UTIL_DBG_MSG(
 				"ccci rat convert from 0x%x to 0x%x\r\n",
 				src_rat, ubin_convert_table_des[i]);
 			return ubin_convert_table_des[i];
@@ -316,7 +316,7 @@ static int find_ccci_tag_inf(char *name, char *buf, unsigned int size)
 		return -2;
 
 	curr = (char *)s_g_lk_inf_base;
-	CCCI_UTIL_INF_MSG("------curr tags:%s----------\n", name);
+	CCCI_UTIL_DBG_MSG("------curr tags:%s----------\n", name);
 	for (i = 0; i < s_g_tag_cnt; i++) {
 		/* 1. Copy tag */
 		memcpy_fromio(&tag, curr, sizeof(union u_tag));
@@ -335,11 +335,11 @@ static int find_ccci_tag_inf(char *name, char *buf, unsigned int size)
 			sizeof(int));
 
 		#ifdef LK_LOAD_MD_INFO_DEBUG_EN
-		CCCI_UTIL_INF_MSG("tag->name:%s\n", tag_name);
-		CCCI_UTIL_INF_MSG("tag->data_offset:%d\n", data_offset);
-		CCCI_UTIL_INF_MSG("tag->data_size:%d\n", data_size);
-		CCCI_UTIL_INF_MSG("tag->next_tag_offset:%d\n", next_tag_offset);
-		CCCI_UTIL_INF_MSG("tag value:%d\n", tmp_buf);
+		CCCI_UTIL_DBG_MSG("tag->name:%s\n", tag_name);
+		CCCI_UTIL_DBG_MSG("tag->data_offset:%d\n", data_offset);
+		CCCI_UTIL_DBG_MSG("tag->data_size:%d\n", data_size);
+		CCCI_UTIL_DBG_MSG("tag->next_tag_offset:%d\n", next_tag_offset);
+		CCCI_UTIL_DBG_MSG("tag value:%d\n", tmp_buf);
 		#endif
 
 		/* 2. compare tag value. */
@@ -419,14 +419,14 @@ int ccci_get_opt_val(char *opt_name)
 	for (i = 0; i < ARRAY_SIZE(ccci_fos_setting); i++) {
 		if (strcmp(opt_name, ccci_fos_setting[i].name) == 0) {
 			ret = ccci_fos_setting[i].value;
-			CCCI_UTIL_INF_MSG("%s:%s->%d\n", __func__,
+			CCCI_UTIL_DBG_MSG("%s:%s->%d\n", __func__,
 				opt_name, ret);
 			return ret;
 		}
 	}
 
 	/* not found */
-	CCCI_UTIL_INF_MSG("%s:%s->-1\n", __func__, opt_name);
+	CCCI_UTIL_DBG_MSG("%s:%s->-1\n", __func__, opt_name);
 	return -1;
 }
 
@@ -465,7 +465,7 @@ static void ccci_dump_opt_tbl(void)
 	for (i = 0; i < ARRAY_SIZE(ccci_fos_setting); i++) {
 		ccci_name = ccci_fos_setting[i].name;
 		ccci_value = ccci_fos_setting[i].value;
-		CCCI_UTIL_INF_MSG("FO:%s -> %08x\n", ccci_name, ccci_value);
+		CCCI_UTIL_DBG_MSG("FO:%s -> %08x\n", ccci_name, ccci_value);
 	}
 }
 
@@ -502,9 +502,9 @@ static void parse_option_setting_from_lk(void)
 	}
 
 	if (using_default)
-		CCCI_UTIL_INF_MSG("All option using default setting\n");
+		CCCI_UTIL_DBG_MSG("All option using default setting\n");
 	else {
-		CCCI_UTIL_INF_MSG("LK has new setting, Dump final\n");
+		CCCI_UTIL_DBG_MSG("LK has new setting, Dump final\n");
 		ccci_dump_opt_tbl();
 	}
 
@@ -598,7 +598,7 @@ static int parse_meta_boot_arguments(unsigned int *raw_ptr)
 	else
 		meta_boot_arguments[active_id] = md_info_tag_array[0];
 
-	CCCI_UTIL_INF_MSG("md type at lk:0x%x] with rat 0x%x\n",
+	CCCI_UTIL_DBG_MSG("md type at lk:0x%x] with rat 0x%x\n",
 			md_type_at_lk[active_id], md_info_tag_array[0]);
 
 	return 0;
@@ -702,7 +702,7 @@ static void nc_smem_info_parsing(void)
 	}
 
 	for (i = 0; i < num; i++) {
-		CCCI_UTIL_INF_MSG("nc_smem<%d>: ap:0x%08x md:0x%08x[0x%08x]\n",
+		CCCI_UTIL_DBG_MSG("nc_smem<%d>: ap:0x%08x md:0x%08x[0x%08x]\n",
 			s_nc_layout[i].id, s_nc_layout[i].ap_offset,
 			s_nc_layout[i].md_offset, s_nc_layout[i].size);
 	}
@@ -711,11 +711,11 @@ static void nc_smem_info_parsing(void)
 	/* DFD part */
 	if (get_nc_smem_region_info(SMEM_USER_RAW_DFD, NULL, NULL,
 					(unsigned int *)&md1_smem_dfd_size))
-		CCCI_UTIL_INF_MSG("change dfd to: 0x%x\n", md1_smem_dfd_size);
+		CCCI_UTIL_DBG_MSG("change dfd to: 0x%x\n", md1_smem_dfd_size);
 	/* AMMS POS part */
 	if (get_nc_smem_region_info(SMEM_USER_RAW_AMMS_POS, NULL, NULL,
 					(unsigned int *)&smem_amms_pos_size))
-		CCCI_UTIL_INF_MSG("change POS to: 0x%x\n", smem_amms_pos_size);
+		CCCI_UTIL_DBG_MSG("change POS to: 0x%x\n", smem_amms_pos_size);
 }
 
 
@@ -782,7 +782,7 @@ OLD_LK_CSMEM:
 	csmem_layout[0].csmem_buffer_size = csmem_info.csmem_buffer_size;
 	csmem_layout[0].md_offset = 0;
 	csmem_layout[0].item_cnt = SMEM_USER_CCB_START;
-	CCCI_UTIL_INF_MSG("ccci_util get csmem: data:%llx data_size:%d\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get csmem: data:%llx data_size:%d\n",
 		csmem_info.csmem_buffer_addr,
 		csmem_info.csmem_buffer_size);
 }
@@ -811,7 +811,7 @@ static void share_memory_info_parsing(void)
 		CCCI_UTIL_ERR_MSG("Invalid ccb info dt para\n");
 	}
 
-	CCCI_UTIL_INF_MSG("ccci_util get ccb: data:%llx data_size:%d\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get ccb: data:%llx data_size:%d\n",
 			ccb_info.ccb_data_buffer_addr,
 			ccb_info.ccb_data_buffer_size);
 
@@ -821,7 +821,7 @@ static void share_memory_info_parsing(void)
 		sizeof(struct _udc_info)) != sizeof(struct _udc_info))
 		CCCI_UTIL_ERR_MSG("Invalid udc layout info dt para\n");
 
-	CCCI_UTIL_INF_MSG(
+	CCCI_UTIL_DBG_MSG(
 		"ccci_util get udc: cache_size:0x%x noncache_size:0x%x\n",
 		udc_size.cache_size, udc_size.noncache_size);
 
@@ -832,7 +832,7 @@ static void share_memory_info_parsing(void)
 			!= sizeof(sib_info))
 		CCCI_UTIL_ERR_MSG("get sib info fail\n");
 
-	CCCI_UTIL_INF_MSG("ccci_util get sib addr: 0x%llx size: %d\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get sib addr: 0x%llx size: %d\n",
 			sib_info.md1_sib_addr, sib_info.md1_sib_size);
 
 	/* Get md1_phy_cap_size  */
@@ -842,7 +842,7 @@ static void share_memory_info_parsing(void)
 			!= sizeof(md1_phy_cap_size))
 		CCCI_UTIL_ERR_MSG("using 0 as phy capture size\n");
 
-	CCCI_UTIL_INF_MSG("ccci_util get md1_phy_cap_size: 0x%x\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get md1_phy_cap_size: 0x%x\n",
 				md1_phy_cap_size);
 
 	/* Get md1_smem_dfd_size  */
@@ -852,7 +852,7 @@ static void share_memory_info_parsing(void)
 			!= sizeof(md1_smem_dfd_size))
 		CCCI_UTIL_ERR_MSG("get smem dfd size fail\n");
 
-	CCCI_UTIL_INF_MSG("ccci_util get md1_smem_dfd_size: %d\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get md1_smem_dfd_size: %d\n",
 			md1_smem_dfd_size);
 
 	/* Get smem_amms_pos_size  */
@@ -860,7 +860,7 @@ static void share_memory_info_parsing(void)
 		sizeof(smem_amms_pos_size)) != sizeof(smem_amms_pos_size))
 		CCCI_UTIL_ERR_MSG("get smem amms pos size fail\n");
 
-	CCCI_UTIL_INF_MSG("ccci_util get smem_amms_pos_size: %d\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get smem_amms_pos_size: %d\n",
 			smem_amms_pos_size);
 
 	/* Get smem_align_padding_size  */
@@ -870,7 +870,7 @@ static void share_memory_info_parsing(void)
 				sizeof(smem_align_padding_size))
 		CCCI_UTIL_ERR_MSG("get smem align padding size fail\n");
 
-	CCCI_UTIL_INF_MSG("ccci_util get smem_align_padding_size: %d\n",
+	CCCI_UTIL_DBG_MSG("ccci_util get smem_align_padding_size: %d\n",
 			smem_align_padding_size);
 
 	/* Get smem cachable offset  */
@@ -881,7 +881,7 @@ static void share_memory_info_parsing(void)
 			!= sizeof(md1_bank4_cache_offset))
 		/* Using 128MB offset as default */
 		md1_bank4_cache_offset = 0x8000000;
-	CCCI_UTIL_INF_MSG("smem cachable offset 0x%X\n",
+	CCCI_UTIL_DBG_MSG("smem cachable offset 0x%X\n",
 				md1_bank4_cache_offset);
 	/* MD*_SMEM_SIZE */
 	md_resv_smem_size[MD_SYS1] = smem_layout.ap_md1_smem_size;
@@ -900,17 +900,17 @@ static void share_memory_info_parsing(void)
 		(unsigned long long)smem_layout.md1_md3_smem_offset);
 	md_resv_smem_addr[MD_SYS3] = (phys_addr_t)(smem_layout.base_addr +
 		(unsigned long long)smem_layout.ap_md3_smem_offset);
-	CCCI_UTIL_INF_MSG("AP  <--> MD1 SMEM(0x%08X):%016llx~%016llx\n",
+	CCCI_UTIL_DBG_MSG("AP  <--> MD1 SMEM(0x%08X):%016llx~%016llx\n",
 			md_resv_smem_size[MD_SYS1],
 			(unsigned long long)md_resv_smem_addr[MD_SYS1],
 			(unsigned long long)(md_resv_smem_addr[MD_SYS1]
 			+ md_resv_smem_size[MD_SYS1]-1));
-	CCCI_UTIL_INF_MSG("MD1 <--> MD3 SMEM(0x%08X):%016llx~%016llx\n",
+	CCCI_UTIL_DBG_MSG("MD1 <--> MD3 SMEM(0x%08X):%016llx~%016llx\n",
 			md1md3_resv_smem_size,
 			(unsigned long long)md1md3_resv_smem_addr,
 			(unsigned long long)(md1md3_resv_smem_addr
 			+ md1md3_resv_smem_size-1));
-	CCCI_UTIL_INF_MSG("AP  <--> MD3 SMEM(0x%08X):%016llx~%016llx\n",
+	CCCI_UTIL_DBG_MSG("AP  <--> MD3 SMEM(0x%08X):%016llx~%016llx\n",
 			md_resv_smem_size[MD_SYS3],
 			(unsigned long long)md_resv_smem_addr[MD_SYS3],
 			(unsigned long long)(md_resv_smem_addr[MD_SYS3]
@@ -933,7 +933,7 @@ static void share_memory_info_parsing(void)
 		sizeof(md_mtee_support)) != sizeof(md_mtee_support))
 		CCCI_UTIL_ERR_MSG("using 0 as MTEE support\n");
 	else
-		CCCI_UTIL_INF_MSG("MTEE support: 0x%x\n", md_mtee_support);
+		CCCI_UTIL_DBG_MSG("MTEE support: 0x%x\n", md_mtee_support);
 
 	nc_smem_info_parsing();
 
@@ -942,7 +942,7 @@ static void share_memory_info_parsing(void)
 	int i;
 
 	for (i = 0; i < csmem_info.item_cnt; i++) {
-		CCCI_UTIL_INF_MSG(
+		CCCI_UTIL_DBG_MSG(
 			"csmem_region[%d][%d]: data_offset:%x data_size:%d\n",
 			i, csmem_layout[i].item_cnt,
 			csmem_layout[i].md_offset,
@@ -967,21 +967,21 @@ static void md_mem_info_parsing(void)
 	}
 
 	find_ccci_tag_inf("hdr_tbl_inf", (char *)md_inf, sizeof(md_inf));
-	CCCI_UTIL_INF_MSG("md_num:%d\n", md_num);
+	CCCI_UTIL_DBG_MSG("md_num:%d\n", md_num);
 	curr = md_inf;
 
 	/* MD ROM and RW part */
 	while (md_num--) {
 		#ifdef LK_LOAD_MD_INFO_DEBUG_EN
-		CCCI_UTIL_INF_MSG("===== Dump modem memory info (%d)=====\n",
+		CCCI_UTIL_DBG_MSG("===== Dump modem memory info (%d)=====\n",
 			(int)sizeof(struct _modem_info));
-		CCCI_UTIL_INF_MSG("base address : 0x%llX\n", curr->base_addr);
-		CCCI_UTIL_INF_MSG("memory size  : 0x%08X\n", curr->size);
-		CCCI_UTIL_INF_MSG("md id        : %d\n", (int)curr->md_id);
-		CCCI_UTIL_INF_MSG("ver          : %d\n", (int)curr->ver);
-		CCCI_UTIL_INF_MSG("type         : %d\n", (int)curr->md_type);
-		CCCI_UTIL_INF_MSG("errno        : %d\n", (int)curr->errno);
-		CCCI_UTIL_INF_MSG("=============================\n");
+		CCCI_UTIL_DBG_MSG("base address : 0x%llX\n", curr->base_addr);
+		CCCI_UTIL_DBG_MSG("memory size  : 0x%08X\n", curr->size);
+		CCCI_UTIL_DBG_MSG("md id        : %d\n", (int)curr->md_id);
+		CCCI_UTIL_DBG_MSG("ver          : %d\n", (int)curr->ver);
+		CCCI_UTIL_DBG_MSG("type         : %d\n", (int)curr->md_type);
+		CCCI_UTIL_DBG_MSG("errno        : %d\n", (int)curr->errno);
+		CCCI_UTIL_DBG_MSG("=============================\n");
 		#endif
 		md_id = (int)curr->md_id;
 		if ((md_id < MAX_MD_NUM_AT_LK)
@@ -995,13 +995,13 @@ static void md_mem_info_parsing(void)
 			else
 				lk_load_img_err_no[md_id] = (int)curr->errno;
 
-			CCCI_UTIL_INF_MSG("md%d lk_load_img_err_no: %d\n",
+			CCCI_UTIL_DBG_MSG("md%d lk_load_img_err_no: %d\n",
 				md_id+1, lk_load_img_err_no[md_id]);
 
 			if (lk_load_img_err_no[md_id] == 0)
 				s_g_md_env_rdy_flag |= 1<<md_id;
 			md_type_at_lk[md_id] = (int)curr->md_type;
-			CCCI_UTIL_INF_MSG(
+			CCCI_UTIL_DBG_MSG(
 				"md%d MemStart: 0x%016llx, MemSize:0x%08X\n",
 				md_id+1,
 				(unsigned long long)md_resv_mem_addr[md_id],
@@ -1037,14 +1037,14 @@ void __iomem *ccci_map_phy_addr(phys_addr_t phy_addr, unsigned int size)
 	phy_addr &= PAGE_MASK;
 	if (!pfn_valid(__phys_to_pfn(phy_addr))) {
 		map_addr = ioremap_wc(phy_addr, size);
-		CCCI_UTIL_INF_MSG(
+		CCCI_UTIL_DBG_MSG(
 			"ioremap_wc: (%lx %p %d)\n",
 			(unsigned long)phy_addr, map_addr, size);
 	} else {
 		prot = pgprot_writecombine(PAGE_KERNEL);
 		map_addr = (void __iomem *)vmap_reserved_mem(
 			phy_addr, size, prot);
-		CCCI_UTIL_INF_MSG(
+		CCCI_UTIL_DBG_MSG(
 			"vmap_reserved_mem: (%lx %p %d)\n",
 			(unsigned long)phy_addr, map_addr, size);
 	}
@@ -1117,11 +1117,11 @@ static void lk_info_parsing_v1(unsigned int *raw_ptr)
 
 	memcpy((void *)&lk_inf, raw_ptr, sizeof(struct _ccci_lk_info));
 
-	CCCI_UTIL_INF_MSG("lk info.lk_info_base_addr: 0x%llX\n",
+	CCCI_UTIL_DBG_MSG("lk info.lk_info_base_addr: 0x%llX\n",
 		lk_inf.lk_info_base_addr);
-	CCCI_UTIL_INF_MSG("lk info.lk_info_size:      0x%x\n",
+	CCCI_UTIL_DBG_MSG("lk info.lk_info_size:      0x%x\n",
 		lk_inf.lk_info_size);
-	CCCI_UTIL_INF_MSG("lk info.lk_info_tag_num:   0x%x\n",
+	CCCI_UTIL_DBG_MSG("lk info.lk_info_tag_num:   0x%x\n",
 		lk_inf.lk_info_tag_num);
 	s_g_tag_inf_size = lk_inf.lk_info_size;
 
@@ -1156,11 +1156,11 @@ static int lk_info_parsing_v2(unsigned int *raw_ptr)
 
 	memcpy((void *)&lk_inf, raw_ptr, sizeof(struct _ccci_lk_info_v2));
 
-	CCCI_UTIL_INF_MSG("lk info.lk_info_base_addr: 0x%llX\n",
+	CCCI_UTIL_DBG_MSG("lk info.lk_info_base_addr: 0x%llX\n",
 		lk_inf.lk_info_base_addr);
-	CCCI_UTIL_INF_MSG("lk info.lk_info_size:      0x%x\n",
+	CCCI_UTIL_DBG_MSG("lk info.lk_info_size:      0x%x\n",
 		lk_inf.lk_info_size);
-	CCCI_UTIL_INF_MSG("lk info.lk_info_tag_num:   0x%x\n",
+	CCCI_UTIL_DBG_MSG("lk info.lk_info_tag_num:   0x%x\n",
 		lk_inf.lk_info_tag_num);
 
 	s_g_lk_ld_md_errno = lk_inf.lk_info_err_no;
@@ -1218,7 +1218,7 @@ static void verify_md_enable_setting(void)
 		s_g_lk_load_img_status |= LK_KERNEL_SETTING_MIS_SYNC;
 	} else if ((!(s_g_md_usage_case & (1<<MD_SYS1)))
 		&& (!(s_g_md_env_rdy_flag & (1<<MD_SYS1)))) {
-		CCCI_UTIL_INF_MSG("md1: both lk and kernel dis\n");
+		CCCI_UTIL_ERR_MSG("md1: both lk and kernel dis\n");
 		s_g_md_usage_case &= ~(1<<MD_SYS1);
 		/* For this case, clear error */
 		lk_load_img_err_no[MD_SYS1] = 0;
@@ -1236,7 +1236,7 @@ static void verify_md_enable_setting(void)
 		s_g_lk_load_img_status |= LK_KERNEL_SETTING_MIS_SYNC;
 	} else if ((!(s_g_md_usage_case & (1<<MD_SYS3)))
 		&& (!(s_g_md_env_rdy_flag & (1<<MD_SYS3)))) {
-		CCCI_UTIL_INF_MSG("md3: both lk and kernel dis\n");
+		CCCI_UTIL_ERR_MSG("md3: both lk and kernel dis\n");
 		s_g_md_usage_case &= ~(1<<MD_SYS3);
 		/* For this case, clear error */
 		lk_load_img_err_no[MD_SYS3] = 0;
@@ -1283,13 +1283,13 @@ static void dump_retrieve_info(void)
 		return;
 	}
 
-	CCCI_UTIL_INF_MSG("retrieve number is %d.\n", retrieve_num);
+	CCCI_UTIL_DBG_MSG("retrieve number is %d.\n", retrieve_num);
 
 	for (i = 0; i < retrieve_num; i++) {
 		snprintf(buf, 32, "retrieve%d", i);
 		if (find_ccci_tag_inf(buf,
 				(char *)&array, sizeof(array))) {
-			CCCI_UTIL_INF_MSG(
+			CCCI_UTIL_DBG_MSG(
 				"AP view(0x%llx ~ 0x%llx), MD view(0x%llx ~ 0x%llx)\n",
 				array[0], array[0] + array[1],
 				array[0] - md1_mem_addr,
@@ -1300,11 +1300,11 @@ static void dump_retrieve_info(void)
 					&& free_in_kernel == 1) {
 				ret = free_reserved_memory(array[0],
 						array[0] + array[1]);
-				CCCI_UTIL_INF_MSG(
+				CCCI_UTIL_DBG_MSG(
 				"free_reserved_memory result=%d\n",
 				ret);
 			} else {
-				CCCI_UTIL_INF_MSG(
+				CCCI_UTIL_DBG_MSG(
 					"no free_in_kernel found, free_in_kernel=%d\n",
 					free_in_kernel);
 			}
@@ -1331,7 +1331,7 @@ static int __init collect_lk_boot_arguments(void)
 	/* This function will initialize s_g_dt_chosen_node */
 	ret = of_scan_flat_dt(early_init_dt_get_chosen, NULL);
 	if (ret == 0) {
-		CCCI_UTIL_INF_MSG("device node no chosen node\n");
+		CCCI_UTIL_ERR_MSG("device node no chosen node\n");
 		return -1;
 	}
 
@@ -1344,7 +1344,7 @@ static int __init collect_lk_boot_arguments(void)
 		goto _common_process;
 	}
 
-	CCCI_UTIL_INF_MSG("ccci,modem_info_v2 not found, try v1\n");
+	CCCI_UTIL_ERR_MSG("ccci,modem_info_v2 not found, try v1\n");
 	raw_ptr = (unsigned int *)of_get_flat_dt_prop(s_g_dt_chosen_node,
 				"ccci,modem_info", NULL);
 	if (raw_ptr != NULL) {
@@ -1352,7 +1352,7 @@ static int __init collect_lk_boot_arguments(void)
 		goto _common_process;
 	}
 
-	CCCI_UTIL_INF_MSG("ccci,modem_info_v1 still not found, using v0!!!\n");
+	CCCI_UTIL_ERR_MSG("ccci,modem_info_v1 still not found, using v0!!!\n");
 	return -1;
 
 _common_process:
@@ -1371,7 +1371,7 @@ _common_process:
 	raw_ptr = (unsigned int *)of_get_flat_dt_prop(s_g_dt_chosen_node,
 				"atag,mdinfo", NULL);
 	if (raw_ptr == NULL)
-		CCCI_UTIL_INF_MSG("atag,mdinfo not found\n");
+		CCCI_UTIL_ERR_MSG("atag,mdinfo not found\n");
 	else
 		/* This function must at the end for global var */
 		parse_meta_boot_arguments(raw_ptr);
@@ -1387,7 +1387,7 @@ _common_process:
 			vunmap(s_g_lk_inf_base);
 			ret = free_reserved_memory(s_g_tag_phy_addr,
 				s_g_tag_phy_addr + MAX_LK_INFO_SIZE);
-			CCCI_UTIL_INF_MSG(
+			CCCI_UTIL_DBG_MSG(
 				"unmap && free reserved tag result=%d\n", ret);
 		}
 	}
@@ -1406,7 +1406,7 @@ int get_lk_load_md_info(char buf[], int size)
 			"LK Load MD:[Enabled](0x%08x)\n",
 			s_g_lk_load_img_status);
 		if (has_write < 0) {
-			CCCI_UTIL_INF_MSG("%s-%d:snprintf fail,has_write=%d,status=%d\n",
+			CCCI_UTIL_ERR_MSG("%s-%d:snprintf fail,has_write=%d,status=%d\n",
 				__func__, __LINE__, has_write, s_g_lk_load_img_status);
 			has_write = 0;
 		} else if (has_write >= size)
@@ -1416,7 +1416,7 @@ int get_lk_load_md_info(char buf[], int size)
 			"LK Load MD:[Disabled](0x%08x)\n",
 			s_g_lk_load_img_status);
 		if (has_write < 0) {
-			CCCI_UTIL_INF_MSG("%s-%d:snprintf fail,has_write=%d,status=%d\n",
+			CCCI_UTIL_ERR_MSG("%s-%d:snprintf fail,has_write=%d,status=%d\n",
 				__func__, __LINE__, has_write, s_g_lk_load_img_status);
 			has_write = 0;
 		} else if (has_write >= size)
@@ -1707,10 +1707,10 @@ int set_modem_support_cap(int md_id, int new_val)
 		if ((get_boot_mode() == META_BOOT)
 			|| (get_boot_mode() == ADVMETA_BOOT)) {
 			meta_md_support[md_id] = new_val;
-			CCCI_UTIL_INF_MSG("md%d: meta md type:[0x%x]\n",
+			CCCI_UTIL_DBG_MSG("md%d: meta md type:[0x%x]\n",
 				md_id + 1, new_val);
 		} else {
-			CCCI_UTIL_INF_MSG("md%d: new mdtype(/wmid):0x%x\n",
+			CCCI_UTIL_DBG_MSG("md%d: new mdtype(/wmid):0x%x\n",
 				md_id + 1, new_val);
 			md_support[md_id] = new_val;
 		}
@@ -1752,7 +1752,7 @@ int __init ccci_parse_meta_md_setting(void)
 	/* This function will initialize s_g_dt_chosen_node */
 	ret = of_scan_flat_dt(early_init_dt_get_chosen, NULL);
 	if (ret == 0) {
-		CCCI_UTIL_INF_MSG("device node no chosen node\n");
+		CCCI_UTIL_ERR_MSG("device node no chosen node\n");
 		return -1;
 	}
 
@@ -1760,7 +1760,7 @@ int __init ccci_parse_meta_md_setting(void)
 	raw_ptr = (unsigned int *)of_get_flat_dt_prop(s_g_dt_chosen_node,
 				"atag,mdinfo", NULL);
 	if (raw_ptr == NULL)
-		CCCI_UTIL_INF_MSG("atag,mdinfo not found\n");
+		CCCI_UTIL_ERR_MSG("atag,mdinfo not found\n");
 	else
 		return parse_meta_boot_arguments(raw_ptr);
 
@@ -1791,7 +1791,7 @@ static void cal_md_settings(int md_id)
 		md_support[md_id] = (unsigned int)val;
 	}
 	if (!(md_en && (s_g_md_usage_case & (1 << md_id)))) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"md%d is disabled\n", (md_id + 1));
 		return;
 	}
@@ -1863,7 +1863,7 @@ static void cal_md_settings(int md_id)
 	md_resv_smem_addr[md_id] = md_resv_mem_list[md_id]
 			+ md_resv_mem_size[md_id];
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"md%d modem_total_size=0x%x,md_size=0x%x, smem_size=0x%x\n",
 		(md_id + 1),
 		md_resv_size_list[md_id], md_resv_mem_size[md_id],
@@ -1884,11 +1884,11 @@ static void cal_md_settings(int md_id)
 			&md_resv_smem_addr[md_id],
 			CCCI_SMEM_ALIGN_MD1);
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"MemStart: %016llx, MemSize:0x%08X\n",
 		(unsigned long long)md_resv_mem_addr[md_id],
 		md_resv_mem_size[md_id]);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"SMemStart: %016llx, SMemSize:0x%08X\n",
 		(unsigned long long)md_resv_smem_addr[md_id],
 		md_resv_smem_size[md_id]);
@@ -1901,7 +1901,7 @@ static void cal_md_settings_v2(struct device_node *node)
 	char tmp_buf[30];
 	int i;
 
-	CCCI_UTIL_INF_MSG("using kernel dt mem setting for md\n");
+	CCCI_UTIL_DBG_MSG("using kernel dt mem setting for md\n");
 
 	/* MTK_MD*_SUPPORT */
 	for (i  = 0; i < MAX_MD_NUM_AT_LK; i++) {
@@ -1915,29 +1915,29 @@ static void cal_md_settings_v2(struct device_node *node)
 	for (i = 0; i < MAX_MD_NUM_AT_LK; i++) {
 		snprintf(tmp_buf, 30, "mediatek,md%d-smem-size", i+1);
 		if (!of_property_read_u32(node, tmp_buf, &tmp)) {
-			CCCI_UTIL_INF_MSG("DT[%s]:%08X\n", tmp_buf, tmp);
+			CCCI_UTIL_DBG_MSG("DT[%s]:%08X\n", tmp_buf, tmp);
 			md_resv_smem_size[MD_SYS1+i] = tmp;
 		} else
-			CCCI_UTIL_INF_MSG("DT[%s]:%08X\n",
+			CCCI_UTIL_DBG_MSG("DT[%s]:%08X\n",
 				tmp_buf, md_resv_smem_size[MD_SYS1+i]);
 	}
 
 	/* MD1MD3_SMEM_SIZE*/
 	snprintf(tmp_buf, 30, "mediatek,md1md3-smem-size");
 	if (!of_property_read_u32(node, tmp_buf, &tmp)) {
-		CCCI_UTIL_INF_MSG("DT[%s]:%08X\n", tmp_buf, tmp);
+		CCCI_UTIL_DBG_MSG("DT[%s]:%08X\n", tmp_buf, tmp);
 		md1md3_resv_smem_size = tmp;
 	} else
-		CCCI_UTIL_INF_MSG("DT[%s]:%08X\n",
+		CCCI_UTIL_DBG_MSG("DT[%s]:%08X\n",
 			tmp_buf, md1md3_resv_smem_size);
 
 	/* CFG version */
 	snprintf(tmp_buf, 30, "mediatek,version");
 	tmp = 0;
 	of_property_read_u32(node, tmp_buf, &tmp);
-	CCCI_UTIL_INF_MSG("DT[%s]:%08X\n", tmp_buf, tmp);
+	CCCI_UTIL_DBG_MSG("DT[%s]:%08X\n", tmp_buf, tmp);
 	if (tmp != 1) {
-		CCCI_UTIL_INF_MSG("Un-support version:%d\n", tmp);
+		CCCI_UTIL_ERR_MSG("Un-support version:%d\n", tmp);
 		return;
 	}
 
@@ -1946,7 +1946,7 @@ static void cal_md_settings_v2(struct device_node *node)
 		if (s_g_md_usage_case & (1 << i)) {
 			md_resv_mem_size[i] = md_resv_size_list[i];
 			md_resv_mem_addr[i] = md_resv_mem_list[i];
-			CCCI_UTIL_INF_MSG(
+			CCCI_UTIL_DBG_MSG(
 				"md%d MemStart: 0x%016llx, MemSize:0x%08X\n",
 				i+1,
 				(unsigned long long)md_resv_mem_addr[i],
@@ -1970,19 +1970,19 @@ static void cal_md_settings_v2(struct device_node *node)
 		md_resv_smem_addr[MD_SYS3] = 0;
 		md_resv_smem_size[MD_SYS3] = 0;
 	}
-	CCCI_UTIL_INF_MSG(
+	CCCI_UTIL_DBG_MSG(
 			"AP  <--> MD1 SMEM(0x%08X):%016llx~%016llx\n",
 			md_resv_smem_size[MD_SYS1],
 			(unsigned long long)md_resv_smem_addr[MD_SYS1],
 			(unsigned long long)(md_resv_smem_addr[MD_SYS1]
 			+ md_resv_smem_size[MD_SYS1]-1));
-	CCCI_UTIL_INF_MSG(
+	CCCI_UTIL_DBG_MSG(
 			"MD1 <--> MD3 SMEM(0x%08X):%016llx~%016llx\n",
 			md1md3_resv_smem_size,
 			(unsigned long long)md1md3_resv_smem_addr,
 			(unsigned long long)(md1md3_resv_smem_addr
 			+ md1md3_resv_smem_size-1));
-	CCCI_UTIL_INF_MSG(
+	CCCI_UTIL_DBG_MSG(
 			"AP  <--> MD3 SMEM(0x%08X):%016llx~%016llx\n",
 			md_resv_smem_size[MD_SYS3],
 			(unsigned long long)md_resv_smem_addr[MD_SYS3],
@@ -2117,7 +2117,7 @@ int get_legacy_md_type(int md_id)
 
 void ccci_md_mem_reserve(void)
 {
-	CCCI_UTIL_INF_MSG("%s phased out.\n", __func__);
+	CCCI_UTIL_DBG_MSG("%s phased out.\n", __func__);
 }
 
 #ifdef CONFIG_OF_RESERVED_MEM
@@ -2141,18 +2141,18 @@ int ccci_reserve_mem_of_init(struct reserved_mem *rmem)
 		md_id = MD_SYS3;
 	else {
 		if (strstr(CCCI_MD1MD3_SMEM_RESERVED_KEY, rmem->name)) {
-			CCCI_UTIL_INF_MSG(
+			CCCI_UTIL_DBG_MSG(
 			"reserve_mem_of_init, rptr=0x%pa, rsize=0x%x\n",
 			&rptr, rsize);
 			resv_smem_addr = rptr;
 			resv_smem_size = rsize;
 		} else
-			CCCI_UTIL_INF_MSG("memory reserve key %s not support\n",
+			CCCI_UTIL_ERR_MSG("memory reserve key %s not support\n",
 				rmem->name);
 
 		return 0;
 	}
-	CCCI_UTIL_INF_MSG("reserve_mem_of_init, rptr=0x%pa, rsize=0x%x\n",
+	CCCI_UTIL_DBG_MSG("reserve_mem_of_init, rptr=0x%pa, rsize=0x%x\n",
 			&rptr, rsize);
 	md_resv_mem_list[md_id] = rptr;
 	md_resv_size_list[md_id] = rsize;
@@ -2179,21 +2179,21 @@ int __init ccci_util_fo_init(void)
 	int idx;
 	struct device_node *node = NULL;
 
-	CCCI_UTIL_INF_MSG("%s 0.\n", __func__);
+	CCCI_UTIL_DBG_MSG("%s 0.\n", __func__);
 
-	CCCI_UTIL_INF_MSG("Dump default setting(@P/K)\n");
+	CCCI_UTIL_DBG_MSG("Dump default setting(@P/K)\n");
 	ccci_dump_opt_tbl();
-	CCCI_UTIL_INF_MSG("ubin: num(%lu),start(%d), end(%lu)\n",
+	CCCI_UTIL_DBG_MSG("ubin: num(%lu),start(%d), end(%lu)\n",
 			LEGACY_UBIN_NUM, LEGACY_UBIN_START_ID,
 			LEGACY_UBIN_END_ID);
 	if (collect_lk_boot_arguments() == 0) {
-		CCCI_UTIL_INF_MSG("using v3.\n");
+		CCCI_UTIL_DBG_MSG("using v3.\n");
 		return 0;
 	}
 
 	node = of_find_compatible_node(NULL, NULL, "mediatek,ccci_util_cfg");
 	if (node == NULL) {
-		CCCI_UTIL_INF_MSG("using v1.\n");
+		CCCI_UTIL_DBG_MSG("using v1.\n");
 		/* Parse META setting */
 		ccci_parse_meta_md_setting();
 
@@ -2201,9 +2201,9 @@ int __init ccci_util_fo_init(void)
 		for (idx = 0; idx < MAX_MD_NUM_AT_LK; idx++)
 			cal_md_settings(idx);
 	} else {
-		CCCI_UTIL_INF_MSG("using v2.\n");
+		CCCI_UTIL_DBG_MSG("using v2.\n");
 		cal_md_settings_v2(node);
 	}
-	CCCI_UTIL_INF_MSG("%s 2.\n", __func__);
+	CCCI_UTIL_DBG_MSG("%s 2.\n", __func__);
 	return 0;
 }
diff --git a/drivers/misc/mediatek/ccci_util/ccci_util_lib_load_img.c b/drivers/misc/mediatek/ccci_util/ccci_util_lib_load_img.c
index 68504a5be..9c552a9cf 100644
--- a/drivers/misc/mediatek/ccci_util/ccci_util_lib_load_img.c
+++ b/drivers/misc/mediatek/ccci_util/ccci_util_lib_load_img.c
@@ -136,7 +136,7 @@ static int check_md_header_v3(int md_id, void *parse_addr,
 	for (idx = 0; idx < sizeof(struct md_check_header_v3); idx++)
 		*start++ = *ptr++;
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"**********MD image check V3 %d**************\n",
 		(int)sizeof(struct md_check_header_v3));
 	ret = strncmp(head->check_header, MD_HEADER_MAGIC_NO, 12);
@@ -209,7 +209,7 @@ static int check_md_header_v3(int md_id, void *parse_addr,
 
 	if (md_type_check && md_plat_check
 		&& md_sys_match && md_size_check) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"Modem header check OK!\n");
 	} else {
 		CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
@@ -234,16 +234,16 @@ static int check_md_header_v3(int md_id, void *parse_addr,
 		ret = -CCCI_ERR_LOAD_IMG_MD_CHECK;
 	}
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[type]=%s, (AP)[type]=%s\n",
 			image->img_info.image_type,
 			image->ap_info.image_type);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[plat]=%s, (AP)[plat]=%s\n",
 			image->img_info.platform,
 			image->ap_info.platform);
 	if (head->header_verno >= 2) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[size]=%x, (AP)[size]=%x\n",
 			image->img_info.mem_size,
 			image->ap_info.mem_size);
@@ -286,18 +286,18 @@ static int check_md_header_v3(int md_id, void *parse_addr,
 		/* else {image->size -= 0x1A0;}
 		 * workaround for md not check in check header
 		 */
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[img_size]=%x, (AP)[img_size]=%x\n",
 			head->md_img_size, image->size);
 	}
 	if (head->header_verno >= 3) {
 		image->dsp_offset = head->dsp_img_offset;
 		image->dsp_size = head->dsp_img_size;
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"DSP image offset=%x size=%x\n", image->dsp_offset,
 			image->dsp_size);
 		if (image->dsp_offset == 0xCDCDCDAA) {
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"DSP on EMI disabled\n");
 		} else if (((image->dsp_offset&0xFFFF) != 0)
 				&& (head->header_verno == 3)) {
@@ -324,7 +324,7 @@ static int check_md_header_v3(int md_id, void *parse_addr,
 				head->region_info[region_id].region_offset;
 			image->rmpu_info.region_info[region_id].region_size =
 				head->region_info[region_id].region_size;
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"load_image: check_header_v4, region(%d): size = %x , offset = %x\n",
 				region_id,
 				head->region_info[region_id].region_size,
@@ -336,21 +336,21 @@ static int check_md_header_v3(int md_id, void *parse_addr,
 			 domain_id++) {
 			image->rmpu_info.domain_attr[domain_id]
 				= head->domain_attr[domain_id];
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"load_image: check_header_v4, domain(%d): attr = %x\n",
 				domain_id,
 				head->domain_attr[domain_id]);
 		}
 	}
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"(MD)[build_ver]=%s, [build_time]=%s\n",
 				image->img_info.build_ver,
 				image->img_info.build_time);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"(MD)[product_ver]=%s\n",
 				image->img_info.product_ver);
 EXIT_CHECK_V3:
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"********MD image check V3*********\n");
 
 	return ret;
@@ -379,7 +379,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 	get_md_resv_mem_info(md_id, NULL, &md_size, NULL, NULL);
 
 	header_size = *(((unsigned int *)parse_addr) - 1);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"MD image header size = %d\n", header_size);
 
 	if (header_size == sizeof(struct md_check_header_v3)) { /* v3, v4 */
@@ -414,7 +414,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 	for (idx = 0; idx < header_size; idx++)
 		*start++ = *ptr++;
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"******MD image check v%d %d*****\n",
 			(int)head->header_verno, (int)header_size);
 	ret = strncmp(head->check_header, MD_HEADER_MAGIC_NO, 12);
@@ -455,7 +455,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 			md_size_check = true;
 		} else if (head->mem_size < md_size) {
 			md_size_check = true;
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_WARN_MSG_WITH_ID(md_id,
 				"[Warning]md size in md header isn't sync to DFO setting: (%08x, %08x)\n",
 				head->mem_size, md_size);
 		}
@@ -485,41 +485,41 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 		&& md_plat_check
 		&& md_sys_match
 		&& md_size_check) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"Modem header check OK!\n");
 	} else {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 			"[Error]Modem header check fail!\n");
 		if (!md_type_check)
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"[Reason]MD type(2G/3G) mis-match to AP!\n");
 
 		if (!md_plat_check)
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"[Reason]MD platform mis-match to AP!\n");
 
 		if (!md_sys_match)
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"[Reason]MD image is not for MD SYS%d!\n",
 				md_id + 1);
 
 		if (!md_size_check)
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"[Reason]MD mem size mis-match to AP setting!\n");
 
 		ret = -CCCI_ERR_LOAD_IMG_MD_CHECK;
 	}
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"(MD)[type]=%s, (AP)[type]=%s\n",
 		image->img_info.image_type,
 		image->ap_info.image_type);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"(MD)[plat]=%s, (AP)[plat]=%s\n",
 		image->img_info.platform,
 		image->ap_info.platform);
 	if (head->header_verno >= 2) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[size]=%x, (AP)[size]=%x\n",
 			image->img_info.mem_size,
 			image->ap_info.mem_size);
@@ -551,7 +551,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 					(const char *)title,
 					DB_OPT_DEFAULT);
 #endif
-				CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+				CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 					"[Reason]MD image size mis-match to AP!\n");
 				ret = -CCCI_ERR_LOAD_IMG_MD_CHECK;
 			}
@@ -563,7 +563,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 		/* else {image->size -= 0x1A0;}
 		 * workaround for md not check in check header
 		 */
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[img_size]=%x, (AP)[img_size]=%x\n",
 			head->md_img_size, image->size);
 	}
@@ -572,21 +572,21 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 	if (head->header_verno >= 3) {
 		image->dsp_offset = headv34->dsp_img_offset;
 		image->dsp_size = headv34->dsp_img_size;
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"DSP image offset=%x size=%x\n",
 			image->dsp_offset,
 			image->dsp_size);
 		if (image->dsp_offset == 0xCDCDCDAA) {
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"DSP on EMI disabled\n");
 		} else if (((image->dsp_offset&0xFFFF) != 0)
 				&& (head->header_verno == 3)) {
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"DSP image offset not 64KB align\n");
 			ret = -CCCI_ERR_LOAD_IMG_MD_CHECK;
 		} else if (image->dsp_offset
 					+ image->dsp_size > md_size) {
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"DSP image size too large %x\n",
 				md_size);
 			ret = -CCCI_ERR_LOAD_IMG_MD_CHECK;
@@ -604,7 +604,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 			headv34->region_info[region_id].region_offset;
 			image->rmpu_info.region_info[region_id].region_size =
 			headv34->region_info[region_id].region_size;
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"load_image: check_header_v4, region(%d): size = %x , offset = %x\n",
 				region_id,
 				headv34->region_info[region_id].region_size,
@@ -615,7 +615,7 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 			 domain_id++) {
 			image->rmpu_info.domain_attr[domain_id]
 				= headv34->domain_attr[domain_id];
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"load_image: check_header_v4, domain(%d): attr = %x\n",
 				domain_id,
 				headv34->domain_attr[domain_id]);
@@ -627,25 +627,25 @@ static int md_check_header_parser(int md_id, void *parse_addr,
 		if (headv5) {
 			image->arm7_offset = headv5->arm7_img_offset;
 			image->arm7_size = headv5->arm7_img_size;
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"load_image: check_header_v5, arm7_offset = 0x%08X, arm_size = 0x%08X\n",
 				image->arm7_offset,
 				image->arm7_size);
 		} else
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"load_image: headv5 is null.\n");
 	}
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[build_ver]=%s, [build_time]=%s\n",
 			image->img_info.build_ver,
 			image->img_info.build_time);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"(MD)[product_ver]=%s\n",
 			image->img_info.product_ver);
 
 CHECK_HEADER_PARSER:
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"*****MD image check end******\n");
 
 	return ret;
@@ -667,7 +667,7 @@ static int check_md_header(int md_id, void *parse_addr,
 
 	get_md_resv_mem_info(md_id, NULL, &md_size, NULL, NULL);
 	header_size = *(((unsigned int *)parse_addr) - 1);
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"MD image header size = %d\n", header_size);
 	/* v3, v4 */
 	if (header_size == sizeof(struct md_check_header_v3))
@@ -687,7 +687,7 @@ static int check_md_header(int md_id, void *parse_addr,
 	for (idx = 0; idx < sizeof(struct md_check_header); idx++)
 		*start++ = *ptr++;
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"******MD image check %d******\n",
 		(int)sizeof(struct md_check_header));
 	ret = strncmp(head->check_header, MD_HEADER_MAGIC_NO, 12);
@@ -782,16 +782,16 @@ static int check_md_header(int md_id, void *parse_addr,
 				ret = -CCCI_ERR_LOAD_IMG_MD_CHECK;
 			}
 
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"(MD)[type]=%s, (AP)[type]=%s\n",
 				image->img_info.image_type,
 				image->ap_info.image_type);
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"(MD)[plat]=%s, (AP)[plat]=%s\n",
 				image->img_info.platform,
 				image->ap_info.platform);
 			if (head->header_verno >= 2) {
-				CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+				CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 					"(MD)[size]=%x, (AP)[size]=%x\n",
 					image->img_info.mem_size,
 					image->ap_info.mem_size);
@@ -809,20 +809,20 @@ static int check_md_header(int md_id, void *parse_addr,
 					image->img_info.md_img_size
 						= head->md_img_size;
 				}
-				CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+				CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 					"(MD)[img_size]=%x, (AP)[img_size]=%x\n",
 					head->md_img_size, image->size);
 			}
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"(MD)[build_ver]=%s, [build_time]=%s\n",
 				image->img_info.build_ver,
 				image->img_info.build_time);
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 				"(MD)[product_ver]=%s\n",
 				image->img_info.product_ver);
 		}
 	}
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"******MD image check*******\n");
 
 	return ret;
@@ -1038,7 +1038,7 @@ TRY_LOAD_IMG:
 		 * img_name, ret);
 		 */
 		if (i <= scan_max) {
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id, "Curr i:%d\n", i);
+			CCCI_UTIL_DBG_MSG_WITH_ID(md_id, "Curr i:%d\n", i);
 			if (img->type == IMG_MD)
 				val = snprintf(img_name, IMG_NAME_LEN,
 					"modem_%d_%s_n.img",
@@ -1185,12 +1185,12 @@ TRY_LOAD_IMG:
 		if (ret == -CCCI_ERR_LOAD_IMG_SIGN_FAIL) {
 			val = snprintf(img_err_str, IMG_ERR_STR_LEN,
 				"%s Signature check fail\n", img->file_name);
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"signature check fail!\n");
 		} else if (ret == -CCCI_ERR_LOAD_IMG_CIPHER_FAIL) {
 			val = snprintf(img_err_str, IMG_ERR_STR_LEN,
 				"%s Cipher chekc fail\n", img->file_name);
-			CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+			CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 				"cipher check fail!\n");
 		} else if (ret == -CCCI_ERR_LOAD_IMG_FILE_OPEN) {
 			val = snprintf(img_err_str, IMG_ERR_STR_LEN,
@@ -1212,9 +1212,9 @@ int ccci_init_security(void)
 {
 	int ret = 0;
 #ifdef ENABLE_MD_IMG_SECURITY_FEATURE
-	CCCI_UTIL_INF_MSG("security is on!\n");
+	CCCI_UTIL_DBG_MSG("security is on!\n");
 #else
-	CCCI_UTIL_INF_MSG("security is off!\n");
+	CCCI_UTIL_DBG_MSG("security is off!\n");
 #endif
 	return ret;
 }
@@ -1275,7 +1275,7 @@ int ccci_get_md_check_hdr_inf(int md_id, void *img_inf, char post_fix[])
 
 	buf = kmalloc(1024, GFP_KERNEL);
 	if (buf == NULL) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 			"fail to allocate memor for chk_hdr\n");
 		return -1;
 	}
@@ -1284,7 +1284,7 @@ int ccci_get_md_check_hdr_inf(int md_id, void *img_inf, char post_fix[])
 
 	ret = get_raw_check_hdr(md_id, buf, 1024);
 	if (ret < 0) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 			"fail to load header(%d)!\n", ret);
 		kfree(buf);
 		return -1;
@@ -1293,7 +1293,7 @@ int ccci_get_md_check_hdr_inf(int md_id, void *img_inf, char post_fix[])
 	img_ptr->size = get_md_img_raw_size(md_id);
 	ret = check_md_header(md_id, buf+ret, img_ptr);
 	if (ret < 0) {
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_ERR_MSG_WITH_ID(md_id,
 			"check header fail(%d)!\n", ret);
 		kfree(buf);
 		return -1;
@@ -1313,19 +1313,19 @@ int ccci_get_md_check_hdr_inf(int md_id, void *img_inf, char post_fix[])
 		img_ptr->ap_info.platform, img_ptr->ap_info.mem_size,
 		img_ptr->img_info.mem_size);
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"check header str[%s]!\n", img_str);
 
 	if (md_id == MD_SYS1) {
 		curr_ubin_id = md_type;
-		CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+		CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 			"type @ header(%d)!\n", curr_ubin_id);
 	}
 
 	snprintf(post_fix, IMG_POSTFIX_LEN,
 		"%d_%s_n", md_id+1, img_ptr->img_info.image_type);
 
-	CCCI_UTIL_INF_MSG_WITH_ID(md_id,
+	CCCI_UTIL_DBG_MSG_WITH_ID(md_id,
 		"post fix[%s]!\n", post_fix);
 
 	return 0;
diff --git a/drivers/misc/mediatek/ccci_util/ccci_util_lib_sys.c b/drivers/misc/mediatek/ccci_util/ccci_util_lib_sys.c
index 852e4e002..d37c0bcca 100644
--- a/drivers/misc/mediatek/ccci_util/ccci_util_lib_sys.c
+++ b/drivers/misc/mediatek/ccci_util/ccci_util_lib_sys.c
@@ -94,7 +94,7 @@ static int get_md_status(int md_id, char val[], int size)
 	int ret = 0;
 
 	if (md_id < 0 || md_id >= MAX_MD_NUM) {
-		CCCI_UTIL_INF_MSG("invalid md_id = %d\n", md_id);
+		CCCI_UTIL_ERR_MSG("invalid md_id = %d\n", md_id);
 		return -1;
 	}
 	if ((md_id < MAX_MD_NUM)
@@ -103,7 +103,7 @@ static int get_md_status(int md_id, char val[], int size)
 	else {
 		ret = snprintf(val, 32, "md%d:n/a", md_id + 1);
 		if (ret < 0 || ret >= 32) {
-			CCCI_UTIL_INF_MSG("%s-%d:snprintf fail,ret=%d\n",
+			CCCI_UTIL_ERR_MSG("%s-%d:snprintf fail,ret=%d\n",
 				__func__, __LINE__, ret);
 			return -1;
 		}
@@ -114,7 +114,7 @@ static int get_md_status(int md_id, char val[], int size)
 static int trigger_md_boot(int md_id)
 {
 	if (md_id < 0 || md_id >= MAX_MD_NUM) {
-		CCCI_UTIL_INF_MSG("invalid md_id = %d\n", md_id);
+		CCCI_UTIL_ERR_MSG("invalid md_id = %d\n", md_id);
 		return -1;
 	}
 	if ((md_id < MAX_MD_NUM) && (boot_md_func[md_id] != NULL))
@@ -151,14 +151,14 @@ static ssize_t boot_status_store(const char *buf, size_t count)
 	unsigned int md_id;
 
 	md_id = buf[0] - '0';
-	CCCI_UTIL_INF_MSG("md%d get boot store\n", md_id + 1);
+	CCCI_UTIL_DBG_MSG("md%d get boot store\n", md_id + 1);
 	if (md_id < MAX_MD_NUM) {
 		if (trigger_md_boot(md_id) != 0)
-			CCCI_UTIL_INF_MSG("md%d n/a\n", md_id + 1);
+			CCCI_UTIL_DBG_MSG("md%d n/a\n", md_id + 1);
 		else
 			clear_meta_1st_boot_arg(md_id);
 	} else
-		CCCI_UTIL_INF_MSG("invalid id(%d)\n", md_id + 1);
+		CCCI_UTIL_ERR_MSG("invalid id(%d)\n", md_id + 1);
 	return count;
 }
 
@@ -231,7 +231,7 @@ static ssize_t debug_enable_show(char *buf)
 
 	curr = snprintf(buf, 16, "%d\n", ccci_debug_enable);
 	if (curr < 0 || curr >= 16) {
-		CCCI_UTIL_INF_MSG(
+		CCCI_UTIL_ERR_MSG(
 			"%s-%d:snprintf fail,curr=%d\n", __func__, __LINE__, curr);
 		return -1;
 	}
@@ -265,7 +265,7 @@ int __attribute__((weak)) ccci_get_plat_ft_inf(char buf[], int size)
 static ssize_t ccci_ft_inf_show(char *buf)
 {
 	if (ccci_get_plat_ft_inf) {
-		CCCI_UTIL_INF_MSG("using platform setting\n");
+		CCCI_UTIL_DBG_MSG("using platform setting\n");
 		return (ssize_t)ccci_get_plat_ft_inf(buf, 4095);
 	}
 	/* Enter here means using default setting */
@@ -282,14 +282,14 @@ static int get_md_image_type(void)
 	if (!curr_ubin_id) {
 		buf = kmalloc(1024, GFP_KERNEL);
 		if (buf == NULL) {
-			CCCI_UTIL_INF_MSG_WITH_ID(-1,
+			CCCI_UTIL_ERR_MSG_WITH_ID(-1,
 				"fail to allocate memor for md_check_header\n");
 			return -1;
 		}
 
 		ret = get_raw_check_hdr(MD_SYS1, (char *)buf, 1024);
 		if (ret < 0) {
-			CCCI_UTIL_INF_MSG_WITH_ID(-1,
+			CCCI_UTIL_ERR_MSG_WITH_ID(-1,
 				"fail to load header(%d)!\n", ret);
 			kfree(buf);
 			return -1;
@@ -392,7 +392,7 @@ static ssize_t kcfg_setting_show(char *buf)
 		actual_write = 4096 - curr - 1;
 	curr += actual_write;
 
-	CCCI_UTIL_INF_MSG("cfg_info_buffer size:%d\n",
+	CCCI_UTIL_DBG_MSG("cfg_info_buffer size:%d\n",
 		curr);
 	return (ssize_t) curr;
 }
diff --git a/drivers/misc/mediatek/ccci_util/ccci_util_log.h b/drivers/misc/mediatek/ccci_util/ccci_util_log.h
index 5cf07a059..4710889e1 100644
--- a/drivers/misc/mediatek/ccci_util/ccci_util_log.h
+++ b/drivers/misc/mediatek/ccci_util/ccci_util_log.h
@@ -36,11 +36,19 @@ do {\
 		CCCI_DUMP_TIME_FLAG, "[0/util]" fmt, ##args);\
 } while (0)
 
+#define CCCI_UTIL_WARN_MSG(fmt, args...) \
+do {\
+	ccci_dump_write(0, CCCI_DUMP_INIT,\
+		CCCI_DUMP_TIME_FLAG, "[0/util]" fmt, ##args);\
+	ccci_dump_write(0, CCCI_DUMP_NORMAL,\
+		CCCI_DUMP_TIME_FLAG, "[0/util]" fmt, ##args);\
+} while (0)
+
 #define CCCI_UTIL_ERR_MSG(fmt, args...) \
 do {\
 	ccci_dump_write(0, CCCI_DUMP_INIT,\
 		CCCI_DUMP_TIME_FLAG, "[0/util]" fmt, ##args);\
-	pr_notice("[ccci0/util]" fmt, ##args);\
+	pr_err("[ccci0/util]" fmt, ##args);\
 } while (0)
 
 /* With MD id message part */
@@ -67,11 +75,19 @@ do {\
 	pr_notice("[ccci%d/util]" fmt, (id+1), ##args);\
 } while (0)
 
+#define CCCI_UTIL_WARN_MSG_WITH_ID(id, fmt, args...) \
+do {\
+	ccci_dump_write(id, CCCI_DUMP_INIT,\
+		CCCI_DUMP_TIME_FLAG, "[%d/util]" fmt, (id+1), ##args);\
+	ccci_dump_write(id, CCCI_DUMP_NORMAL,\
+		CCCI_DUMP_TIME_FLAG, "[%d/util]" fmt, (id+1), ##args);\
+} while (0)
+
 #define CCCI_UTIL_ERR_MSG_WITH_ID(id, fmt, args...) \
 do {\
 	ccci_dump_write(id, CCCI_DUMP_INIT,\
 		CCCI_DUMP_TIME_FLAG, "[%d/util]" fmt, (id+1), ##args);\
-	pr_notice("[ccci%d/util]" fmt, (id+1), ##args);\
+	pr_err("[ccci%d/util]" fmt, (id+1), ##args);\
 } while (0)
 
 #else
@@ -80,19 +96,22 @@ do {\
 /* For bring up stage log */
 /* ------------------------------------------------------------------------- */
 /* No MD id message part */
-#define CCCI_UTIL_DBG_MSG(fmt, args...) pr_notice("[ccci0/util]" fmt, ##args)
-#define CCCI_UTIL_INF_MSG(fmt, args...) pr_notice("[ccci0/util]" fmt, ##args)
-#define CCCI_UTIL_ERR_MSG(fmt, args...) pr_notice("[ccci0/util]" fmt, ##args)
+#define CCCI_UTIL_DBG_MSG(fmt, args...) pr_debug("[ccci0/util]" fmt, ##args)
+#define CCCI_UTIL_INF_MSG(fmt, args...) pr_info("[ccci0/util]" fmt, ##args)
+#define CCCI_UTIL_WARN_MSG(fmt, args...) pr_warn("[ccci0/util]" fmt, ##args)
+#define CCCI_UTIL_ERR_MSG(fmt, args...) pr_err("[ccci0/util]" fmt, ##args)
 
 /* With MD id message part */
 #define CCCI_UTIL_DBG_MSG_WITH_ID(id, fmt, args...) \
-	pr_notice("[ccci%d/util]" fmt, (id+1), ##args)
+	pr_debug("[ccci%d/util]" fmt, (id+1), ##args)
 #define CCCI_UTIL_INF_MSG_WITH_ID(id, fmt, args...) \
-	pr_notice("[ccci%d/util]" fmt, (id+1), ##args)
+	pr_info("[ccci%d/util]" fmt, (id+1), ##args)
 #define CCCI_UTIL_NOTICE_MSG_WITH_ID(id, fmt, args...) \
 	pr_notice("[ccci%d/util]" fmt, (id+1), ##args)
+#define CCCI_UTIL_WARN_MSG_WITH_ID(id, fmt, args...) \
+	pr_warn("[ccci%d/util]" fmt, (id+1), ##args)
 #define CCCI_UTIL_ERR_MSG_WITH_ID(id, fmt, args...) \
-	pr_notice("[ccci%d/util]" fmt, (id+1), ##args)
+	pr_err("[ccci%d/util]" fmt, (id+1), ##args)
 
 
 #endif /* end of #ifndef BRING_UP_LOG_MODE */
diff --git a/drivers/misc/mediatek/ccmni/ccmni.c b/drivers/misc/mediatek/ccmni/ccmni.c
index 0dacf7320..bbeac4f7f 100644
--- a/drivers/misc/mediatek/ccmni/ccmni.c
+++ b/drivers/misc/mediatek/ccmni/ccmni.c
@@ -1240,7 +1240,7 @@ static int ccmni_init(int md_id, struct ccmni_ccci_ops *ccci_info)
 		ccmni_dev_init(md_id, dev);
 
 		/* used to support auto add ipv6 mroute */
-		dev->type = ARPHRD_PUREIP;
+		dev->type = ARPHRD_RAWIP;
 
 		sprintf(dev->name, "%s%d", ctlb->ccci_ops->name, i);
 
diff --git a/drivers/misc/mediatek/ccu/src/1.1/ccu_i2c.c b/drivers/misc/mediatek/ccu/src/1.1/ccu_i2c.c
index 1fe0f2698..09169443d 100644
--- a/drivers/misc/mediatek/ccu/src/1.1/ccu_i2c.c
+++ b/drivers/misc/mediatek/ccu/src/1.1/ccu_i2c.c
@@ -58,8 +58,6 @@ static inline u32 i2c_readl_dma(struct mt_i2c *i2c, u16 offset);
 static inline void i2c_writel_dma(u32 value, struct mt_i2c *i2c, u16 offset);
 static inline u16 i2c_readw(struct mt_i2c *i2c, u16 offset);
 static inline void i2c_writew(u16 value, struct mt_i2c *i2c, u16 offset);
-static void ccu_i2c_dump_info(struct mt_i2c *i2c);
-
 
 static enum CCU_I2C_CHANNEL g_ccuI2cChannel = CCU_I2C_CHANNEL_UNDEF;
 static struct i2c_client *g_ccuI2cClientMain;
@@ -383,60 +381,4 @@ void ccu_i2c_dump_errr(void)
 	}
 
 	i2c = i2c_get_adapdata(pClient->adapter);
-	ccu_i2c_dump_info(i2c);
-}
-
-static void ccu_i2c_dump_info(struct mt_i2c *i2c)
-{
-	/* I2CFUC(); */
-	/* int val=0; */
-	pr_info("i2c_dump_info ++++++++++++++++++++++++++++++++++++++++++\n");
-	pr_info("base address 0x%p\n", i2c->base);
-	pr_info("I2C register:\n"
-	       I2CTAG "SLAVE_ADDR=%x,INTR_MASK=%x,INTR_STAT=%x,"
-	       I2CTAG "CONTROL=%x,TRANSFER_LEN=%x\n"
-	       I2CTAG "TRANSAC_LEN=%x,DELAY_LEN=%x,"
-	       I2CTAG "TIMING=%x,START=%x,FIFO_STAT=%x\n"
-	       I2CTAG "IO_CONFIG=%x,HS=%x,DCM_EN=%x,DEBUGSTAT=%x,"
-	       I2CTAG "EXT_CONF=%x,TRANSFER_LEN_AUX=%x\n",
-	       (i2c_readw(i2c, 0x200 + OFFSET_SLAVE_ADDR)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_INTR_MASK)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_INTR_STAT)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_CONTROL)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_TRANSFER_LEN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_TRANSAC_LEN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_DELAY_LEN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_TIMING)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_START)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_FIFO_STAT)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_IO_CONFIG)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_HS)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_DCM_EN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_DEBUGSTAT)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_EXT_CONF)),
-		   (i2c_readw(i2c, 0x200 + OFFSET_TRANSFER_LEN_AUX)));
-
-	pr_info("DMA register(0x%p):\n"
-	       I2CTAG "INT_FLAG=%x,INT_EN=%x,EN=%x,RST=%x,\n"
-	       I2CTAG "STOP=%x,FLUSH=%x,CON=%x,TX_MEM_ADDR=%x, RX_MEM_ADDR=%x\n"
-	       I2CTAG "TX_LEN=%x,RX_LEN=%x,INT_BUF_SIZE=%x,DEBUG_STATUS=%x\n"
-	       I2CTAG "TX_MEM_ADDR2=%x, RX_MEM_ADDR2=%x\n",
-	       i2c->pdmabase,
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_INT_FLAG)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_INT_EN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_EN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RST)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_STOP)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_FLUSH)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_CON)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_TX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_TX_LEN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RX_LEN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_INT_BUF_SIZE)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_DEBUG_STA)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_TX_MEM_ADDR2)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RX_MEM_ADDR2)));
-	pr_info("i2c_dump_info ------------------------------------------\n");
-
 }
diff --git a/drivers/misc/mediatek/ccu/src/1.2/ccu_i2c.c b/drivers/misc/mediatek/ccu/src/1.2/ccu_i2c.c
index 490c682b6..229909b0e 100644
--- a/drivers/misc/mediatek/ccu/src/1.2/ccu_i2c.c
+++ b/drivers/misc/mediatek/ccu/src/1.2/ccu_i2c.c
@@ -60,7 +60,6 @@ static inline u32 i2c_readl_dma(struct mt_i2c *i2c, u16 offset);
 static inline void i2c_writel_dma(u32 value, struct mt_i2c *i2c, u16 offset);
 static inline u16 i2c_readw(struct mt_i2c *i2c, u16 offset);
 static inline void i2c_writew(u16 value, struct mt_i2c *i2c, u16 offset);
-static void ccu_i2c_dump_info(struct mt_i2c *i2c);
 
 static const struct i2c_device_id ccu_i2c_2_ids[] = {
 	{CCU_I2C_BUS2_HW_DRVNAME, 0},
@@ -330,60 +329,4 @@ void ccu_i2c_dump_errr(void)
 		return;
 	}
 	i2c = i2c_get_adapdata(pClient->adapter);
-	ccu_i2c_dump_info(i2c);
-}
-
-static void ccu_i2c_dump_info(struct mt_i2c *i2c)
-{
-	/* I2CFUC(); */
-	/* int val=0; */
-	pr_info("i2c_dump_info ++++++++++++++++++++++++++++++++++++++++++\n");
-	pr_info("base address 0x%p\n", i2c->base);
-	pr_info("I2C register:\n"
-	       I2CTAG "SLAVE_ADDR=%x,INTR_MASK=%x,INTR_STAT=%x,"
-	       I2CTAG "CONTROL=%x,TRANSFER_LEN=%x\n"
-	       I2CTAG "TRANSAC_LEN=%x,DELAY_LEN=%x,"
-	       I2CTAG "TIMING=%x,START=%x,FIFO_STAT=%x\n"
-	       I2CTAG "IO_CONFIG=%x,HS=%x,DCM_EN=%x,DEBUGSTAT=%x,"
-	       I2CTAG "EXT_CONF=%x,TRANSFER_LEN_AUX=%x\n",
-	       (i2c_readw(i2c, 0x200 + OFFSET_SLAVE_ADDR)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_INTR_MASK)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_INTR_STAT)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_CONTROL)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_TRANSFER_LEN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_TRANSAC_LEN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_DELAY_LEN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_TIMING)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_START)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_FIFO_STAT)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_IO_CONFIG)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_HS)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_DCM_EN)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_DEBUGSTAT)),
-	       (i2c_readw(i2c, 0x200 + OFFSET_EXT_CONF)),
-		   (i2c_readw(i2c, 0x200 + OFFSET_TRANSFER_LEN_AUX)));
-
-	pr_info("DMA register(0x%p):\n"
-	       I2CTAG "INT_FLAG=%x,INT_EN=%x,EN=%x,RST=%x,\n"
-	       I2CTAG "STOP=%x,FLUSH=%x,CON=%x,TX_MEM_ADDR=%x, RX_MEM_ADDR=%x\n"
-	       I2CTAG "TX_LEN=%x,RX_LEN=%x,INT_BUF_SIZE=%x,DEBUG_STATUS=%x\n"
-	       I2CTAG "TX_MEM_ADDR2=%x, RX_MEM_ADDR2=%x\n",
-	       i2c->pdmabase,
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_INT_FLAG)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_INT_EN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_EN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RST)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_STOP)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_FLUSH)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_CON)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_TX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_TX_LEN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RX_LEN)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_INT_BUF_SIZE)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_DEBUG_STA)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_TX_MEM_ADDR2)),
-	       (i2c_readl_dma(i2c, 0x80 + OFFSET_RX_MEM_ADDR2)));
-	pr_info("i2c_dump_info ------------------------------------------\n");
-
-}
+}
\ No newline at end of file
diff --git a/drivers/misc/mediatek/ccu/src/2.0/ccu_i2c.c b/drivers/misc/mediatek/ccu/src/2.0/ccu_i2c.c
index 336fc1633..d794a1c5a 100644
--- a/drivers/misc/mediatek/ccu/src/2.0/ccu_i2c.c
+++ b/drivers/misc/mediatek/ccu/src/2.0/ccu_i2c.c
@@ -62,7 +62,6 @@ static int ccu_i2c_remove(struct i2c_client *client);
 /*ccu i2c operation*/
 static struct i2c_client *get_ccu_i2c_client(
 	enum CCU_I2C_CHANNEL i2c_controller_id);
-static void ccu_i2c_dump_info(struct mt_i2c *i2c);
 static int ccu_i2c_controller_en(
 	enum CCU_I2C_CHANNEL i2c_controller_id, int enable);
 static int i2c_query_dma_buffer_addr(
@@ -406,7 +405,6 @@ void ccu_i2c_dump_errr(void)
 		pClient = get_ccu_i2c_client((enum CCU_I2C_CHANNEL)i);
 		if (pClient != NULL) {
 			i2c = i2c_get_adapdata(pClient->adapter);
-			ccu_i2c_dump_info(i2c);
 		} else {
 			LOG_INF_MUST(
 			"I2C controller[%d] CCU client is null\n", i);
@@ -548,61 +546,3 @@ static inline void i2c_writew(u16 value, struct mt_i2c *i2c, u16 offset)
 {
 	writew(value, i2c->base + offset);
 }
-
-static void ccu_i2c_dump_info(struct mt_i2c *i2c)
-{
-	/* I2CFUC(); */
-	/* int val=0; */
-	pr_info("i2c_dump_info ++++++++++++++++++++++++++++++++++++++++++\n");
-	pr_info("I2C structure:\n"
-	I2CTAG "Clk=%d,Id=%d,Op=%x,Irq_stat=%x,Total_len=%x\n"
-	I2CTAG "Trans_len=%x,Trans_num=%x,Trans_auxlen=%x,speed=%d\n"
-	I2CTAG "Trans_stop=%u\n",
-	15600, i2c->id, i2c->op, i2c->irq_stat, i2c->total_len,
-	i2c->msg_len, 1, i2c->msg_aux_len, i2c->speed_hz, i2c->trans_stop);
-
-	pr_info("base address 0x%p\n", i2c->base);
-pr_info("I2C register:\n"
-I2CTAG "SLAVE_ADR=%x,INTR_MASK=%x,INTR_STAT=%x,CONTROL=%x,TRANSFER_LEN=%x\n"
-I2CTAG "TRANSAC_LEN=%x,DELAY_LEN=%x,TIMING=%x,START=%x,FIFO_STAT=%x\n"
-I2CTAG "IO_CONFIG=%x,HS=%x,DCM_EN=%x,DBGSTAT=%x,EXT_CONF=%x,LEN_AUX=%x\n",
-(i2c_readw(i2c, OFFSET_SLAVE_ADDR)),
-(i2c_readw(i2c, OFFSET_INTR_MASK)),
-(i2c_readw(i2c, OFFSET_INTR_STAT)),
-(i2c_readw(i2c, OFFSET_CONTROL)),
-(i2c_readw(i2c, OFFSET_TRANSFER_LEN)),
-(i2c_readw(i2c, OFFSET_TRANSAC_LEN)),
-(i2c_readw(i2c, OFFSET_DELAY_LEN)),
-(i2c_readw(i2c, OFFSET_TIMING)),
-(i2c_readw(i2c, OFFSET_START)),
-(i2c_readw(i2c, OFFSET_FIFO_STAT)),
-(i2c_readw(i2c, OFFSET_IO_CONFIG)),
-(i2c_readw(i2c, OFFSET_HS)),
-(i2c_readw(i2c, OFFSET_DCM_EN)),
-(i2c_readw(i2c, OFFSET_DEBUGSTAT)),
-(i2c_readw(i2c, OFFSET_EXT_CONF)),
-(i2c_readw(i2c, OFFSET_TRANSFER_LEN_AUX)));
-
-	pr_info("DMA register(0x%p):\n"
-	       I2CTAG "INT_FLAG=%x,INT_EN=%x,EN=%x,RST=%x,\n"
-	       I2CTAG "STOP=%x,FLUSH=%x,CON=%x,TX_MEM_ADDR=%x, RX_MEM_ADDR=%x\n"
-	       I2CTAG "TX_LEN=%x,RX_LEN=%x,INT_BUF_SIZE=%x,DEBUG_STATUS=%x\n"
-	       I2CTAG "TX_MEM_ADDR2=%x, RX_MEM_ADDR2=%x\n",
-	       i2c->pdmabase,
-	       (i2c_readl_dma(i2c, OFFSET_INT_FLAG)),
-	       (i2c_readl_dma(i2c, OFFSET_INT_EN)),
-	       (i2c_readl_dma(i2c, OFFSET_EN)),
-	       (i2c_readl_dma(i2c, OFFSET_RST)),
-	       (i2c_readl_dma(i2c, OFFSET_STOP)),
-	       (i2c_readl_dma(i2c, OFFSET_FLUSH)),
-	       (i2c_readl_dma(i2c, OFFSET_CON)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_LEN)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_LEN)),
-	       (i2c_readl_dma(i2c, OFFSET_INT_BUF_SIZE)),
-	       (i2c_readl_dma(i2c, OFFSET_DEBUG_STA)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_MEM_ADDR2)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_MEM_ADDR2)));
-	pr_info("i2c_dump_info ------------------------------------------\n");
-}
diff --git a/drivers/misc/mediatek/ccu/src/2.1/ccu_i2c.c b/drivers/misc/mediatek/ccu/src/2.1/ccu_i2c.c
index e4b5e300e..91dfa96de 100644
--- a/drivers/misc/mediatek/ccu/src/2.1/ccu_i2c.c
+++ b/drivers/misc/mediatek/ccu/src/2.1/ccu_i2c.c
@@ -66,7 +66,6 @@ static int ccu_i2c_remove(struct i2c_client *client);
 /*ccu i2c operation*/
 static struct i2c_client *get_ccu_i2c_client(
 	enum CCU_I2C_CHANNEL i2c_controller_id);
-static void ccu_i2c_dump_info(struct mt_i2c *i2c);
 static int ccu_i2c_controller_en(enum CCU_I2C_CHANNEL i2c_controller_id,
 	int enable);
 static int i2c_query_dma_buffer_addr(struct ccu_device_s *g_ccu_device,
@@ -400,7 +399,6 @@ void ccu_i2c_dump_errr(void)
 		pClient = get_ccu_i2c_client((enum CCU_I2C_CHANNEL)i);
 		if (pClient != NULL) {
 			i2c = i2c_get_adapdata(pClient->adapter);
-			ccu_i2c_dump_info(i2c);
 		} else {
 			LOG_INF_MUST(
 				"I2C controller[%d] CCU client is null\n", i);
@@ -557,62 +555,3 @@ static inline void i2c_writew(u16 value, struct mt_i2c *i2c,
 {
 	writew(value, i2c->base + offset);
 }
-
-static void ccu_i2c_dump_info(struct mt_i2c *i2c)
-{
-	/* I2CFUC(); */
-	/* int val=0; */
-	pr_info("i2c_dump_info ++++++++++++++++++++++++++++++++++++++++++\n");
-	pr_info("I2C structure:\n"
-	       I2CTAG "Clk=%d,Id=%d,Op=%x,Irq_stat=%x,Total_len=%x\n"
-	       I2CTAG "Trans_len=%x,Trans_num=%x,Trans_auxlen=%x,speed=%d\n"
-	       I2CTAG "Trans_stop=%u\n",
-	       15600, i2c->id, i2c->op, i2c->irq_stat, i2c->total_len,
-	       i2c->msg_len, 1, i2c->msg_aux_len,
-	       i2c->speed_hz, i2c->trans_stop);
-
-	pr_info("base address 0x%p\n", i2c->base);
-	pr_info("I2C register:\n"
-I2CTAG "SLAVE_ADDR=%x,INTR_MASK=%x,INTR_STAT=%x,CONTROL=%x,TRANSFER_LEN=%x\n"
-I2CTAG "TRANSAC_LEN=%x,DELAY_LEN=%x,TIMING=%x,START=%x,FIFO_STAT=%x\n"
-I2CTAG "IO_CONFIG=%x,HS=%x,DCM_EN=%x,DEBUGSTAT=%x,EXT_CONF=%x,LEN_AUX=%x\n",
-(i2c_readw(i2c, OFFSET_SLAVE_ADDR)),
-(i2c_readw(i2c, OFFSET_INTR_MASK)),
-(i2c_readw(i2c, OFFSET_INTR_STAT)),
-(i2c_readw(i2c, OFFSET_CONTROL)),
-(i2c_readw(i2c, OFFSET_TRANSFER_LEN)),
-(i2c_readw(i2c, OFFSET_TRANSAC_LEN)),
-(i2c_readw(i2c, OFFSET_DELAY_LEN)),
-(i2c_readw(i2c, OFFSET_TIMING)),
-(i2c_readw(i2c, OFFSET_START)),
-(i2c_readw(i2c, OFFSET_FIFO_STAT)),
-(i2c_readw(i2c, OFFSET_IO_CONFIG)),
-(i2c_readw(i2c, OFFSET_HS)),
-(i2c_readw(i2c, OFFSET_DCM_EN)),
-(i2c_readw(i2c, OFFSET_DEBUGSTAT)),
-(i2c_readw(i2c, OFFSET_EXT_CONF)),
-(i2c_readw(i2c, OFFSET_TRANSFER_LEN_AUX)));
-
-	pr_info("DMA register(0x%p):\n"
-	       I2CTAG "INT_FLAG=%x,INT_EN=%x,EN=%x,RST=%x,\n"
-	       I2CTAG "STOP=%x,FLUSH=%x,CON=%x,TX_MEM_ADDR=%x, RX_MEM_ADDR=%x\n"
-	       I2CTAG "TX_LEN=%x,RX_LEN=%x,INT_BUF_SIZE=%x,DEBUG_STATUS=%x\n"
-	       I2CTAG "TX_MEM_ADDR2=%x, RX_MEM_ADDR2=%x\n",
-	       i2c->pdmabase,
-	       (i2c_readl_dma(i2c, OFFSET_INT_FLAG)),
-	       (i2c_readl_dma(i2c, OFFSET_INT_EN)),
-	       (i2c_readl_dma(i2c, OFFSET_EN)),
-	       (i2c_readl_dma(i2c, OFFSET_RST)),
-	       (i2c_readl_dma(i2c, OFFSET_STOP)),
-	       (i2c_readl_dma(i2c, OFFSET_FLUSH)),
-	       (i2c_readl_dma(i2c, OFFSET_CON)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_LEN)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_LEN)),
-	       (i2c_readl_dma(i2c, OFFSET_INT_BUF_SIZE)),
-	       (i2c_readl_dma(i2c, OFFSET_DEBUG_STA)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_MEM_ADDR2)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_MEM_ADDR2)));
-	pr_info("i2c_dump_info ------------------------------------------\n");
-}
diff --git a/drivers/misc/mediatek/ccu/src/Makefile b/drivers/misc/mediatek/ccu/src/Makefile
index bb11f74ca..345e2c727 100644
--- a/drivers/misc/mediatek/ccu/src/Makefile
+++ b/drivers/misc/mediatek/ccu/src/Makefile
@@ -22,7 +22,7 @@ endif
 
 obj-y += $(subst ",,$(platform))/
 
-$(warning CCU_MAKE_FILE_CALLED)
+#$(warning CCU_MAKE_FILE_CALLED)
 ifneq (,$(filter $(platform),mt6757 mt6799))
     obj-y += 1.0/
 else ifneq (,$(filter $(platform),mt6758 mt6763))
diff --git a/drivers/misc/mediatek/ccu/src/mt6873/ccu_i2c.c b/drivers/misc/mediatek/ccu/src/mt6873/ccu_i2c.c
index 7950b0921..0833d7a04 100644
--- a/drivers/misc/mediatek/ccu/src/mt6873/ccu_i2c.c
+++ b/drivers/misc/mediatek/ccu/src/mt6873/ccu_i2c.c
@@ -66,7 +66,6 @@ static int ccu_i2c_remove(struct i2c_client *client);
 /*ccu i2c operation*/
 static struct i2c_client *get_ccu_i2c_client(
 	enum CCU_I2C_CHANNEL i2c_controller_id);
-static void ccu_i2c_dump_info(struct mt_i2c *i2c);
 static int ccu_i2c_controller_en(enum CCU_I2C_CHANNEL i2c_controller_id,
 	int enable);
 static int i2c_query_dma_buffer_addr(struct ccu_device_s *g_ccu_device,
@@ -400,7 +399,6 @@ void ccu_i2c_dump_errr(void)
 		pClient = get_ccu_i2c_client((enum CCU_I2C_CHANNEL)i);
 		if (pClient != NULL) {
 			i2c = i2c_get_adapdata(pClient->adapter);
-			ccu_i2c_dump_info(i2c);
 		} else {
 			LOG_INF_MUST(
 				"I2C controller[%d] CCU client is null\n", i);
@@ -557,62 +555,3 @@ static inline void i2c_writew(u16 value, struct mt_i2c *i2c,
 {
 	writew(value, i2c->base + offset);
 }
-
-static void ccu_i2c_dump_info(struct mt_i2c *i2c)
-{
-	/* I2CFUC(); */
-	/* int val=0; */
-	pr_info("i2c_dump_info ++++++++++++++++++++++++++++++++++++++++++\n");
-	pr_info("I2C structure:\n"
-	       I2CTAG "Clk=%d,Id=%d,Op=%x,Irq_stat=%x,Total_len=%x\n"
-	       I2CTAG "Trans_len=%x,Trans_num=%x,Trans_auxlen=%x,speed=%d\n"
-	       I2CTAG "Trans_stop=%u\n",
-	       15600, i2c->id, i2c->op, i2c->irq_stat, i2c->total_len,
-	       i2c->msg_len, 1, i2c->msg_aux_len,
-	       i2c->speed_hz, i2c->trans_stop);
-
-	pr_info("base address 0x%p\n", i2c->base);
-	pr_info("I2C register:\n"
-I2CTAG "SLAVE_ADDR=%x,INTR_MASK=%x,INTR_STAT=%x,CONTROL=%x,TRANSFER_LEN=%x\n"
-I2CTAG "TRANSAC_LEN=%x,DELAY_LEN=%x,TIMING=%x,START=%x,FIFO_STAT=%x\n"
-I2CTAG "IO_CONFIG=%x,HS=%x,DCM_EN=%x,DEBUGSTAT=%x,EXT_CONF=%x,LEN_AUX=%x\n",
-(i2c_readw(i2c, OFFSET_SLAVE_ADDR)),
-(i2c_readw(i2c, OFFSET_INTR_MASK)),
-(i2c_readw(i2c, OFFSET_INTR_STAT)),
-(i2c_readw(i2c, OFFSET_CONTROL)),
-(i2c_readw(i2c, OFFSET_TRANSFER_LEN)),
-(i2c_readw(i2c, OFFSET_TRANSAC_LEN)),
-(i2c_readw(i2c, OFFSET_DELAY_LEN)),
-(i2c_readw(i2c, OFFSET_TIMING)),
-(i2c_readw(i2c, OFFSET_START)),
-(i2c_readw(i2c, OFFSET_FIFO_STAT)),
-(i2c_readw(i2c, OFFSET_IO_CONFIG)),
-(i2c_readw(i2c, OFFSET_HS)),
-(i2c_readw(i2c, OFFSET_DCM_EN)),
-(i2c_readw(i2c, OFFSET_DEBUGSTAT)),
-(i2c_readw(i2c, OFFSET_EXT_CONF)),
-(i2c_readw(i2c, OFFSET_TRANSFER_LEN_AUX)));
-
-	pr_info("DMA register(0x%p):\n"
-	       I2CTAG "INT_FLAG=%x,INT_EN=%x,EN=%x,RST=%x,\n"
-	       I2CTAG "STOP=%x,FLUSH=%x,CON=%x,TX_MEM_ADDR=%x, RX_MEM_ADDR=%x\n"
-	       I2CTAG "TX_LEN=%x,RX_LEN=%x,INT_BUF_SIZE=%x,DEBUG_STATUS=%x\n"
-	       I2CTAG "TX_MEM_ADDR2=%x, RX_MEM_ADDR2=%x\n",
-	       i2c->pdmabase,
-	       (i2c_readl_dma(i2c, OFFSET_INT_FLAG)),
-	       (i2c_readl_dma(i2c, OFFSET_INT_EN)),
-	       (i2c_readl_dma(i2c, OFFSET_EN)),
-	       (i2c_readl_dma(i2c, OFFSET_RST)),
-	       (i2c_readl_dma(i2c, OFFSET_STOP)),
-	       (i2c_readl_dma(i2c, OFFSET_FLUSH)),
-	       (i2c_readl_dma(i2c, OFFSET_CON)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_MEM_ADDR)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_LEN)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_LEN)),
-	       (i2c_readl_dma(i2c, OFFSET_INT_BUF_SIZE)),
-	       (i2c_readl_dma(i2c, OFFSET_DEBUG_STA)),
-	       (i2c_readl_dma(i2c, OFFSET_TX_MEM_ADDR2)),
-	       (i2c_readl_dma(i2c, OFFSET_RX_MEM_ADDR2)));
-	pr_info("i2c_dump_info ------------------------------------------\n");
-}
diff --git a/drivers/misc/mediatek/cmdq/v2/cmdq_core.h b/drivers/misc/mediatek/cmdq/v2/cmdq_core.h
index d30bd00c7..8429a1eca 100644
--- a/drivers/misc/mediatek/cmdq/v2/cmdq_core.h
+++ b/drivers/misc/mediatek/cmdq/v2/cmdq_core.h
@@ -139,14 +139,14 @@ struct DumpFirstErrorStruct {
 
 #define CMDQ_LOG(string, args...) \
 do {			\
-	pr_notice("[CMDQ]"string, ##args); \
+	pr_debug("[CMDQ]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ]"string, ##args); \
 } while (0)
 
 #define CMDQ_MSG(string, args...) \
 do {			\
 	if (cmdq_core_should_print_msg()) { \
-		pr_notice("[CMDQ]"string, ##args); \
+		pr_debug("[CMDQ]"string, ##args); \
 }			\
 } while (0)
 
@@ -159,7 +159,7 @@ do {			\
 
 #define CMDQ_ERR(string, args...) \
 do {			\
-	pr_notice("[CMDQ][ERR]"string, ##args); \
+	pr_err("[CMDQ][ERR]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ][ERR]"string, ##args); \
 } while (0)
 
@@ -169,7 +169,7 @@ do {			\
 do {			\
 	char dispatchedTag[50]; \
 	snprintf(dispatchedTag, 50, "CRDISPATCH_KEY:%s", tag); \
-	pr_notice("[CMDQ][AEE]"string, ##args); \
+	pr_warn("[CMDQ][AEE]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ][AEE]"string, ##args); \
 	cmdq_core_turnoff_first_dump(); \
 	aee_kernel_warning_api(__FILE__, __LINE__, \
diff --git a/drivers/misc/mediatek/cmdq/v3/cmdq_helper_ext.h b/drivers/misc/mediatek/cmdq/v3/cmdq_helper_ext.h
index 8684b668d..cc7778150 100644
--- a/drivers/misc/mediatek/cmdq/v3/cmdq_helper_ext.h
+++ b/drivers/misc/mediatek/cmdq/v3/cmdq_helper_ext.h
@@ -72,14 +72,14 @@ struct DumpFirstErrorStruct {
 
 #define CMDQ_LOG(string, args...) \
 do {			\
-	pr_notice("[CMDQ]"string, ##args); \
+	pr_debug("[CMDQ]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ]"string, ##args); \
 } while (0)
 
 #define CMDQ_MSG(string, args...) \
 do {			\
 	if (cmdq_core_should_print_msg()) { \
-		pr_notice("[CMDQ]"string, ##args); \
+		pr_debug("[CMDQ]"string, ##args); \
 	} \
 } while (0)
 
@@ -93,7 +93,7 @@ do { \
 
 #define CMDQ_ERR(string, args...) \
 do {			\
-	pr_notice("[CMDQ][ERR]"string, ##args); \
+	pr_err("[CMDQ][ERR]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ][ERR]"string, ##args); \
 } while (0)
 
@@ -111,7 +111,7 @@ do {			\
 	int len = snprintf(dispatchedTag, 50, "CRDISPATCH_KEY:%s", tag); \
 	if (len >= 50) \
 		pr_debug("%s:%d len:%d over 50\n", __func__, __LINE__, len); \
-	pr_notice("[CMDQ][AEE]"string, ##args); \
+	pr_debug("[CMDQ][AEE]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ][AEE]"string, ##args); \
 	cmdq_core_turnoff_first_dump(); \
 	aee_kernel_warning_api(__FILE__, __LINE__, \
diff --git a/drivers/misc/mediatek/cmdq/v3/cmdq_mdp_common.c b/drivers/misc/mediatek/cmdq/v3/cmdq_mdp_common.c
index 9653d5eaa..1934d9086 100644
--- a/drivers/misc/mediatek/cmdq/v3/cmdq_mdp_common.c
+++ b/drivers/misc/mediatek/cmdq/v3/cmdq_mdp_common.c
@@ -65,7 +65,7 @@ struct plist_head qos_isp_module_request_list[MDP_TOTAL_THREAD];
 #define CMDQ_LOG_PMQOS(string, args...) \
 do {			\
 	if (cmdq_core_should_pmqos_log()) { \
-		pr_notice("[CMDQ][MDP]"string, ##args); \
+		pr_debug("[CMDQ][MDP]"string, ##args); \
 	} \
 } while (0)
 
diff --git a/drivers/misc/mediatek/eccci/hif/ccci_hif_cldma.c b/drivers/misc/mediatek/eccci/hif/ccci_hif_cldma.c
index ee06c2930..b764060c5 100644
--- a/drivers/misc/mediatek/eccci/hif/ccci_hif_cldma.c
+++ b/drivers/misc/mediatek/eccci/hif/ccci_hif_cldma.c
@@ -1858,7 +1858,7 @@ static void cldma_irq_work(struct work_struct *work)
 
 void __weak dump_emi_latency(void)
 {
-	pr_notice("[ccci/dummy] %s is not supported!\n", __func__);
+	pr_err("[ccci/dummy] %s is not supported!\n", __func__);
 }
 
 void __weak cldma_dump_register(struct md_cd_ctrl *md_ctrl)
diff --git a/drivers/misc/mediatek/eccci/hif/ccci_hif_dpmaif.c b/drivers/misc/mediatek/eccci/hif/ccci_hif_dpmaif.c
index 689962e5c..71dba31f8 100644
--- a/drivers/misc/mediatek/eccci/hif/ccci_hif_dpmaif.c
+++ b/drivers/misc/mediatek/eccci/hif/ccci_hif_dpmaif.c
@@ -108,14 +108,14 @@ TRACE_EVENT(ccci_skb_rx,
 #define DPMA_DRB_LOG(fmt, args...) \
 do { \
 	ccci_dump_write(0, CCCI_DUMP_DPMA_DRB, 0, fmt, ##args); \
-	pr_info("[ccci]" fmt, ##args); \
+	pr_debug("[ccci]" fmt, ##args); \
 } while (0)
 
 #define DPMA_DRB_LOG_TIME(fmt, args...) \
 do { \
 	ccci_dump_write(0, CCCI_DUMP_DPMA_DRB|CCCI_DUMP_TIME_FLAG, \
 			0, fmt, ##args); \
-	pr_info("[ccci]" fmt, ##args); \
+	pr_debug("[ccci]" fmt, ##args); \
 } while (0)
 
 
diff --git a/drivers/misc/mediatek/eccci/inc/ccci_debug.h b/drivers/misc/mediatek/eccci/inc/ccci_debug.h
index c841271ba..eebf45c9a 100644
--- a/drivers/misc/mediatek/eccci/inc/ccci_debug.h
+++ b/drivers/misc/mediatek/eccci/inc/ccci_debug.h
@@ -48,7 +48,7 @@ do { \
 	if (ccci_debug_enable == CCCI_LOG_ALL_MOBILE) \
 		pr_debug("[ccci%d/" tag "]" fmt, (idx+1), ##args); \
 	else if (ccci_debug_enable == CCCI_LOG_ALL_UART) \
-		pr_info("[ccci%d/" tag "]" fmt, (idx+1), ##args); \
+		pr_debug("[ccci%d/" tag "]" fmt, (idx+1), ##args); \
 } while (0)
 
 #define CCCI_LEGACY_ALWAYS_LOG(idx, tag, fmt, args...) \
@@ -58,11 +58,11 @@ do { \
 		pr_debug("[ccci%d/" tag "]" fmt, (idx+1), ##args); \
 	else if (ccci_debug_enable == CCCI_LOG_ALL_UART \
 			|| ccci_debug_enable == CCCI_LOG_CRITICAL_UART) \
-		pr_info("[ccci%d/" tag "]" fmt, (idx+1), ##args); \
+		pr_debug("[ccci%d/" tag "]" fmt, (idx+1), ##args); \
 } while (0)
 
 #define CCCI_LEGACY_ERR_LOG(idx, tag, fmt, args...) \
-	pr_notice("[ccci%d/" tag "]" fmt, (idx+1), ##args)
+	pr_err("[ccci%d/" tag "]" fmt, (idx+1), ##args)
 
 /*--------------------------------------------------------------------------*/
 /* This log is used for driver init and part of first boot up log */
diff --git a/drivers/misc/mediatek/eccci/mixdev/mix_event.c b/drivers/misc/mediatek/eccci/mixdev/mix_event.c
index a165029e8..3d62f2611 100644
--- a/drivers/misc/mediatek/eccci/mixdev/mix_event.c
+++ b/drivers/misc/mediatek/eccci/mixdev/mix_event.c
@@ -104,7 +104,7 @@ static int ccci_util_skbtime_getdata(struct input_event *data)
 	if (skb_times_ring.count > 0) {
 		if (skb_times_ring.beg < 0
 			|| skb_times_ring.beg >= SKB_TIME_BUF_LEN) {
-			pr_notice("%s:invalid index = %d\n",
+			pr_err("%s:invalid index = %d\n",
 				__func__, skb_times_ring.beg);
 			spin_unlock_irqrestore(&s_event_update_lock, flag);
 			return 0;
@@ -135,7 +135,7 @@ static void ccci_util_skbtime_adddata(__be16 ipid, int skb_len, __u16 port)
 
 	index = skb_times_ring.end;
 	if (index < 0 || index >= SKB_TIME_BUF_LEN) {
-		pr_notice("%s:invalid index = %d\n", __func__, index);
+		pr_err("%s:invalid index = %d\n", __func__, index);
 		spin_unlock_irqrestore(&s_event_update_lock, flag);
 		return;
 	}
@@ -378,7 +378,7 @@ int mix_event_init(void)
 
 	ret = alloc_chrdev_region(&s_ge_status_dev, 0, 1, "mix_event");
 	if (ret) {
-		pr_notice("[mixdev] alloc chrdev fail (%d)\n", ret);
+		pr_err("[mixdev] alloc chrdev fail (%d)\n", ret);
 		goto _exit_1;
 	}
 
@@ -387,7 +387,7 @@ int mix_event_init(void)
 
 	ret = cdev_add(&s_ge_char_dev, s_ge_status_dev, 1);
 	if (ret) {
-		pr_notice("[mixdev] cdev_add failed\n");
+		pr_err("[mixdev] cdev_add failed\n");
 		goto _exit_2;
 	}
 
diff --git a/drivers/misc/mediatek/eccci/port/port_proxy.c b/drivers/misc/mediatek/eccci/port/port_proxy.c
index 14fd079df..eeaeac4a4 100644
--- a/drivers/misc/mediatek/eccci/port/port_proxy.c
+++ b/drivers/misc/mediatek/eccci/port/port_proxy.c
@@ -99,7 +99,7 @@ int port_dev_kernel_read(struct port_t *port, char *buf, int size)
 	md_state = ccci_fsm_get_md_state(port->md_id);
 	if (md_state != READY && port->tx_ch != CCCI_FS_TX &&
 		port->tx_ch != CCCI_RPC_TX) {
-		pr_info_ratelimited(
+		pr_err(
 			"port %s read data fail when md_state = %d\n",
 			port->name, md_state);
 		return -ENODEV;
diff --git a/drivers/misc/mediatek/eccci/udc/udc.c b/drivers/misc/mediatek/eccci/udc/udc.c
index 394158c8a..328334f5f 100644
--- a/drivers/misc/mediatek/eccci/udc/udc.c
+++ b/drivers/misc/mediatek/eccci/udc/udc.c
@@ -21,9 +21,9 @@ int register_udc_func_deflateInit2(deflateInit2_cb_func_t func)
 
 	if (udc_func_table.deflateInit2 == NULL) {
 		udc_func_table.deflateInit2 = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -44,7 +44,7 @@ int deflateInit2_cb(struct z_stream_s *strm,
 				ZLIB_VERSION, (int)sizeof(struct z_stream_s));
 	} else {
 		ret = -1;/* E_NO_EXIST */
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -56,9 +56,9 @@ int register_udc_func_deflateSetDict(
 
 	if (udc_func_table.deflateSetDict == NULL) {
 		udc_func_table.deflateSetDict = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -76,7 +76,7 @@ int deflateSetDictionary_cb(struct z_stream_s *strm,
 		ret = func(strm, dictionary, dictLength);
 	} else {
 		ret = -1;/* E_NO_EXIST */
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -87,9 +87,9 @@ int register_udc_func_deflate(deflate_cb_func_t func)
 
 	if (udc_func_table.deflate == NULL) {
 		udc_func_table.deflate = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -106,7 +106,7 @@ int deflate_cb(struct z_stream_s *strm, int flush)
 		ret = func(strm, flush);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -117,9 +117,9 @@ int register_udc_func_deflateEnd(deflateEnd_cb_func_t func)
 
 	if (udc_func_table.deflateEnd == NULL) {
 		udc_func_table.deflateEnd = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -136,7 +136,7 @@ int deflateEnd_cb(struct z_stream_s *strm)
 		ret = func(strm);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -147,9 +147,9 @@ int register_udc_func_deflateReset(deflateReset_cb_func_t func)
 
 	if (udc_func_table.deflateReset == NULL) {
 		udc_func_table.deflateReset = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -166,7 +166,7 @@ int deflateReset_cb(struct z_stream_s *strm)
 		ret = func(strm);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -177,9 +177,9 @@ int register_udc_func_deflateBound(deflateBound_cb_func_t func)
 
 	if (udc_func_table.deflateBound == NULL) {
 		udc_func_table.deflateBound = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -196,7 +196,7 @@ int deflateBound_cb(struct z_stream_s *strm, unsigned long sourceLen)
 		ret = func(strm, sourceLen);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -207,9 +207,9 @@ int register_udc_func_udc_chksum(udc_chksum_cb_func_t func)
 
 	if (udc_func_table.udc_chksum == NULL) {
 		udc_func_table.udc_chksum = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -226,7 +226,7 @@ int udc_chksum_cb(struct z_stream_s *strm)
 		ret = func(strm);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -237,9 +237,9 @@ int register_udc_func_udc_QueryPara(udc_QueryPara_cb_func_t func)
 
 	if (udc_func_table.udc_QueryPara == NULL) {
 		udc_func_table.udc_QueryPara = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -256,7 +256,7 @@ int udc_QueryPara_cb(struct z_stream_s *strm, int id, void *param)
 		ret = func(strm, id, param);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -267,9 +267,9 @@ int register_udc_func_udc_GetCmpLen(udc_GetCmpLen_cb_func_t func)
 
 	if (udc_func_table.udc_GetCmpLen == NULL) {
 		udc_func_table.udc_GetCmpLen = func;
-		pr_notice("%s success\n", __func__);
+		pr_debug("%s success\n", __func__);
 	} else {
-		pr_notice("%s fail: registered!\n", __func__);
+		pr_err("%s fail: registered!\n", __func__);
 		ret = -1;
 	}
 
@@ -287,7 +287,7 @@ int udc_GetCmpLen_cb(struct z_stream_s *strm,
 		ret = func(strm, start, end);
 	} else {
 		ret = -1;//E_NO_EXIST
-		pr_notice("exec %s fail: not register!\n", __func__);
+		pr_err("exec %s fail: not register!\n", __func__);
 	}
 	return ret;
 }
@@ -359,7 +359,7 @@ int register_udc_functions(unsigned int id, void *f)
 		return register_udc_func_udc_GetCmpLen(func);
 	}
 	default:
-		pr_notice("udc func id %d not found\n", id);
+		pr_err("udc func id %d not found\n", id);
 		return -1;
 	}
 }
diff --git a/drivers/misc/mediatek/geniezone/mtee-kree/Makefile b/drivers/misc/mediatek/geniezone/mtee-kree/Makefile
index b09cc40ed..74f7aa081 100644
--- a/drivers/misc/mediatek/geniezone/mtee-kree/Makefile
+++ b/drivers/misc/mediatek/geniezone/mtee-kree/Makefile
@@ -3,7 +3,7 @@
 #
 
 #subdir-ccflags-y += -Werror
-$(info ************  drivers/trusty/mtee-kree mk ************)
+#$(info ************  drivers/trusty/mtee-kree mk ************)
 
 ccflags-y := -I$(srctree)/drivers/misc/mediatek/geniezone/public -Werror $(ccflags-y)
 
diff --git a/drivers/misc/mediatek/gpu/Makefile b/drivers/misc/mediatek/gpu/Makefile
index 35752ae0d..2058d92e2 100644
--- a/drivers/misc/mediatek/gpu/Makefile
+++ b/drivers/misc/mediatek/gpu/Makefile
@@ -15,7 +15,7 @@ obj-y += ged/
 obj-y += hal/
 
 MTK_GPU_VERSION = $(subst ",,$(CONFIG_MTK_GPU_VERSION))
-$(info MTK_GPU_VERSION 1 = $(word 1,$(MTK_GPU_VERSION)))
+#$(info MTK_GPU_VERSION 1 = $(word 1,$(MTK_GPU_VERSION)))
 # GPU R5P0
 ifeq ($(CONFIG_MTK_GPU_R5P0),y)
     obj-y += $(subst ",,$(CONFIG_MTK_PLATFORM))/
diff --git a/drivers/misc/mediatek/gpu/ged/Makefile b/drivers/misc/mediatek/gpu/ged/Makefile
index 338d99b4d..212a3fe13 100644
--- a/drivers/misc/mediatek/gpu/ged/Makefile
+++ b/drivers/misc/mediatek/gpu/ged/Makefile
@@ -130,6 +130,9 @@ ifneq (,$(filter $(CONFIG_MTK_PLATFORM), "mt6785"))
 ccflags-y += -DMTK_GED_KPI
 ccflags-y += -DGED_KPI_CPU_BOOST
 
+ccflags-y += -DGED_SKI_SUPPORT
+ged-y += src/ged_ski.o
+
 ifeq ($(CONFIG_MTK_GPU_COMMON_DVFS_SUPPORT),y)
 ccflags-y += -DGED_ENABLE_FB_DVFS
 ccflags-y += -DGED_ENABLE_DYNAMIC_DVFS_MARGIN
diff --git a/drivers/misc/mediatek/gpu/ged/include/ged_ski.h b/drivers/misc/mediatek/gpu/ged/include/ged_ski.h
new file mode 100644
index 000000000..e104fc63b
--- /dev/null
+++ b/drivers/misc/mediatek/gpu/ged/include/ged_ski.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2020 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#ifndef __GED_SKI_H__
+#define __GED_SKI_H__
+
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+
+#include "ged_base.h"
+#include "ged_sysfs.h"
+
+GED_ERROR ged_ski_init(void);
+void ged_ski_exit(void);
+
+extern struct kobject *kernel_kobj;
+
+#endif
diff --git a/drivers/misc/mediatek/gpu/ged/src/ged_main.c b/drivers/misc/mediatek/gpu/ged/src/ged_main.c
index bb143a086..bb9dec29a 100644
--- a/drivers/misc/mediatek/gpu/ged/src/ged_main.c
+++ b/drivers/misc/mediatek/gpu/ged/src/ged_main.c
@@ -46,6 +46,10 @@
 #include "ged_ge.h"
 #include "ged_gpu_tuner.h"
 
+#ifdef GED_SKI_SUPPORT
+#include "ged_ski.h"
+#endif
+
 #define GED_DRIVER_DEVICE_NAME "ged"
 
 static GED_LOG_BUF_HANDLE ghLogBuf_GPU;
@@ -425,6 +429,10 @@ static void ged_exit(void)
 	ghLogBuf_GPU = 0;
 #endif /* GED_BUFFER_LOG_DISABLE */
 
+#ifdef GED_SKI_SUPPORT
+	ged_ski_exit();
+#endif
+
 	ged_gpu_tuner_exit();
 
 	ged_kpi_system_exit();
@@ -517,6 +525,14 @@ static int ged_init(void)
 		goto ERROR;
 	}
 
+#ifdef GED_SKI_SUPPORT
+	err = ged_ski_init();
+	if (unlikely(err != GED_OK)) {
+		GED_LOGE("ged: failed to init ski!\n");
+		goto ERROR;
+	}
+#endif
+
 #ifndef GED_BUFFER_LOG_DISABLE
 	ghLogBuf_GPU = ged_log_buf_alloc(512, 128 * 512,
 		GED_LOG_BUF_TYPE_RINGBUFFER, "GPU_FENCE", NULL);
diff --git a/drivers/misc/mediatek/gpu/ged/src/ged_ski.c b/drivers/misc/mediatek/gpu/ged/src/ged_ski.c
new file mode 100644
index 000000000..8240bcba7
--- /dev/null
+++ b/drivers/misc/mediatek/gpu/ged/src/ged_ski.c
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2020 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#include <mt-plat/mtk_gpu_utility.h>
+#include <mtk_gpufreq.h>
+#include "ged_ski.h"
+
+static struct kobject *gpu_kobj;
+
+ssize_t gpu_available_governor_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "Default\n");
+}
+
+static KOBJ_ATTR_RO(gpu_available_governor);
+
+ssize_t gpu_busy_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	unsigned int gpu_loading = 0;
+
+	mtk_get_gpu_loading(&gpu_loading);
+
+	return scnprintf(buf, PAGE_SIZE, "%u %%\n", gpu_loading);
+}
+
+static KOBJ_ATTR_RO(gpu_busy);
+
+ssize_t gpu_clock_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	unsigned int gpu_freq = 0;
+
+	gpu_freq = mt_gpufreq_get_cur_volt() ? mt_gpufreq_get_cur_freq() : 0;
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n", gpu_freq / 1000);
+}
+
+static KOBJ_ATTR_RO(gpu_clock);
+
+ssize_t gpu_freq_table_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	struct mt_gpufreq_power_table_info *power_table = NULL;
+	unsigned int table_num = 0;
+	unsigned int max_opp_idx = 0;
+	char temp[1024] = {0};
+	int idx;
+	int count = 0;
+	int pos = 0;
+	int length;
+
+	power_table = pass_gpu_table_to_eara();
+	table_num = mt_gpufreq_get_dvfs_table_num();
+	max_opp_idx = mt_gpufreq_get_seg_max_opp_index();
+
+	for (idx = max_opp_idx; count < table_num; count++) {
+		length = scnprintf(temp + pos, 1024 - pos,
+				"%u ", power_table[idx + count].gpufreq_khz / 1000);
+		pos += length;
+	}
+
+	return scnprintf(buf, PAGE_SIZE, "%s\n", temp);
+}
+
+static KOBJ_ATTR_RO(gpu_freq_table);
+
+ssize_t gpu_governor_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "Default\n");
+}
+
+static KOBJ_ATTR_RO(gpu_governor);
+
+static ssize_t gpu_max_clock_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	unsigned int max_clock = 0;
+	unsigned long max_clock_custom = 0;
+
+	max_clock = mt_gpufreq_get_thermal_limit_freq();
+	mtk_get_gpu_custom_upbound_freq(&max_clock_custom);
+	max_clock = (max_clock_custom < max_clock) ?
+			max_clock_custom : max_clock;
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n", max_clock / 1000);
+}
+
+static ssize_t gpu_max_clock_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int max_freq = 0;
+	struct mt_gpufreq_power_table_info *power_table = NULL;
+	unsigned int table_num = 0;
+	unsigned int max_opp_idx = 0;
+	int idx = 0;
+	int index_count = 0;
+
+	char acBuffer[GED_SYSFS_MAX_BUFF_SIZE];
+
+	if ((count > 0) && (count < GED_SYSFS_MAX_BUFF_SIZE)) {
+		if (scnprintf(acBuffer, GED_SYSFS_MAX_BUFF_SIZE, "%s", buf)) {
+			if (kstrtoint(acBuffer, 0, &max_freq) == 0) {
+				if (max_freq <= 0)
+					return -EINVAL;
+
+				power_table = pass_gpu_table_to_eara();
+				table_num = mt_gpufreq_get_dvfs_table_num();
+				max_opp_idx = mt_gpufreq_get_seg_max_opp_index();
+
+				for (idx = max_opp_idx; index_count < table_num; index_count++) {
+					if (max_freq ==
+					    power_table[idx + index_count].gpufreq_khz) {
+						mtk_custom_upbound_gpu_freq(index_count);
+						return count;
+					}
+				}
+
+				GED_LOGE("SKI: set max clock failed (%d not support)!\n", max_freq);
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+static KOBJ_ATTR_RW(gpu_max_clock);
+
+ssize_t gpu_min_clock_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	unsigned long min_clock = 0;
+	unsigned long min_clock_custom = 0;
+
+	mtk_get_gpu_bottom_freq(&min_clock);
+	mtk_get_gpu_custom_boost_freq(&min_clock_custom);
+	min_clock = (min_clock_custom > min_clock) ?
+			min_clock_custom : min_clock;
+
+	return scnprintf(buf, PAGE_SIZE, "%lu\n", min_clock / 1000);
+}
+
+static ssize_t gpu_min_clock_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int min_freq = 0;
+	struct mt_gpufreq_power_table_info *power_table = NULL;
+	unsigned int table_num = 0;
+	unsigned int max_opp_idx = 0;
+	int idx = 0;
+	int index_count = 0;
+
+	char acBuffer[GED_SYSFS_MAX_BUFF_SIZE];
+
+	if ((count > 0) && (count < GED_SYSFS_MAX_BUFF_SIZE)) {
+		if (scnprintf(acBuffer, GED_SYSFS_MAX_BUFF_SIZE, "%s", buf)) {
+			if (kstrtoint(acBuffer, 0, &min_freq) == 0) {
+				if (min_freq <= 0)
+					return -EINVAL;
+
+				power_table = pass_gpu_table_to_eara();
+				table_num = mt_gpufreq_get_dvfs_table_num();
+				max_opp_idx = mt_gpufreq_get_seg_max_opp_index();
+
+				for (idx = max_opp_idx; index_count < table_num; index_count++) {
+					if (min_freq ==
+					    power_table[idx + index_count].gpufreq_khz) {
+						mtk_custom_boost_gpu_freq(index_count);
+						return count;
+					}
+				}
+
+				GED_LOGE("SKI: set min clock failed (%d not support)!\n", min_freq);
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+static KOBJ_ATTR_RW(gpu_min_clock);
+
+ssize_t gpu_model_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+#if defined(CONFIG_MACH_MT6768)
+	return scnprintf(buf, PAGE_SIZE, "Mali-G52 MC2\n"); //MT6768
+#elif defined(CONFIG_MACH_MT6853)
+	return scnprintf(buf, PAGE_SIZE, "Mali-G57 MC3\n"); //MT6853
+#elif defined(CONFIG_MACH_MT6785)
+	return scnprintf(buf, PAGE_SIZE, "Mali-G76 MP4\n"); //MT6785
+#elif
+	GED_LOGE("SKI: gpu model not set!\n");
+	return scnprintf(buf, PAGE_SIZE, "UNKNOWN\n");
+#endif
+}
+
+static KOBJ_ATTR_RO(gpu_model);
+
+ssize_t gpu_tmu_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	int temperature;
+
+	temperature = mt_gpufreq_get_immed_gpu_temp();
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", temperature);
+}
+
+static KOBJ_ATTR_RO(gpu_tmu);
+
+GED_ERROR ged_ski_init(void)
+{
+	int ret = GED_OK;
+
+	gpu_kobj = kobject_create_and_add("gpu", kernel_kobj);
+	if (!gpu_kobj) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_kobj!\n");
+		goto EXIT;
+	}
+
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_available_governor);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_available_governor!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_busy);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_busy!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_clock);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_clock!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_freq_table);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_freq_table!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_governor);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_governor!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_max_clock);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_max_clock!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_min_clock);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_min_clock!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_model);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_model!\n");
+		goto EXIT;
+	}
+	ret = ged_sysfs_create_file(gpu_kobj, &kobj_attr_gpu_tmu);
+	if (ret) {
+		ret = GED_ERROR_OOM;
+		GED_LOGE("ged: failed to create gpu_tmu!\n");
+		goto EXIT;
+	}
+
+	return ret;
+
+EXIT:
+	ged_ski_exit();
+	return ret;
+}
+
+void ged_ski_exit(void)
+{
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_available_governor);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_busy);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_clock);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_freq_table);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_governor);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_max_clock);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_min_clock);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_model);
+	ged_sysfs_remove_file(gpu_kobj, &kobj_attr_gpu_tmu);
+	kobject_put(gpu_kobj);
+	gpu_kobj = NULL;
+}
diff --git a/drivers/misc/mediatek/gpu/gpu_mali/Makefile b/drivers/misc/mediatek/gpu/gpu_mali/Makefile
index 30345a732..8a22f929c 100644
--- a/drivers/misc/mediatek/gpu/gpu_mali/Makefile
+++ b/drivers/misc/mediatek/gpu/gpu_mali/Makefile
@@ -12,6 +12,6 @@
 #
 
 MTK_GPU_VERSION = $(subst ",,$(CONFIG_MTK_GPU_VERSION))
-$(info *MTK_GPU_VERSION 2 = $(word 2,$(MTK_GPU_VERSION)))
+#$(info *MTK_GPU_VERSION 2 = $(word 2,$(MTK_GPU_VERSION)))
 
 obj-y += mali_$(word 2,$(MTK_GPU_VERSION))/
diff --git a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/Makefile b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/Makefile
index cefea836c..b86964217 100644
--- a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/Makefile
+++ b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/Makefile
@@ -12,7 +12,7 @@
 #
 
 MTK_GPU_VERSION = $(subst ",,$(CONFIG_MTK_GPU_VERSION))
-$(info *MTK_GPU_VERSION 3 = $(word 3,$(MTK_GPU_VERSION)))
+#$(info *MTK_GPU_VERSION 3 = $(word 3,$(MTK_GPU_VERSION)))
 
 ifneq ($(word 3,$(MTK_GPU_VERSION)),)
     obj-y += mali-$(word 3,$(MTK_GPU_VERSION))/drivers/gpu/arm/midgard/
diff --git a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r20p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r20p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env
index 01a3315c0..823a6cadd 100644
--- a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r20p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env
+++ b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r20p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env
@@ -1,4 +1,4 @@
-$(info mali MTK evironment, building r19p0 DDK)
+#$(info mali MTK evironment, building r20p0 DDK)
 
 MTK_TOP = $(srctree)/drivers/misc/mediatek/
 
@@ -9,8 +9,8 @@ CONFIG_MALI_MIDGARD := y
 CONFIG_MALI_PLATFORM_THIRDPARTY := y
 CONFIG_MALI_PLATFORM_THIRDPARTY_NAME := $(CONFIG_MTK_PLATFORM)
 
-$(info mtk-Kbuild CONFIG_MALI_PLATFORM_THIRDPARTY := $(CONFIG_MALI_PLATFORM_THIRDPARTY))
-$(info mtk-Kbuild CONFIG_MALI_PLATFORM_THIRDPARTY_NAME := $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
+#$(info mtk-Kbuild CONFIG_MALI_PLATFORM_THIRDPARTY := $(CONFIG_MALI_PLATFORM_THIRDPARTY))
+#$(info mtk-Kbuild CONFIG_MALI_PLATFORM_THIRDPARTY_NAME := $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
 
 CONFIG_MALI_DEBUG := y
 
@@ -32,7 +32,7 @@ ccflags-$(CONFIG_MTK_GPU_COMMON_DVFS_SUPPORT) += -DENABLE_COMMON_DVFS
 
 ifneq (, $(findstring $(CONFIG_MTK_PLATFORM), "mt6785"))
 ccflags-y += -DMTK_GPU_BM_2
-$(info *GPU defined GPU BM QoS 2.0)
+#$(info *GPU defined GPU BM QoS 2.0)
 endif
 
 ifneq (, $(findstring $(CONFIG_MTK_PLATFORM), "mt6771"))
diff --git a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env
index 01a3315c0..62b633634 100644
--- a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env
+++ b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/Kbuild-mtk-custom-env
@@ -1,4 +1,4 @@
-$(info mali MTK evironment, building r19p0 DDK)
+$(info mali MTK evironment, building r25p0 DDK)
 
 MTK_TOP = $(srctree)/drivers/misc/mediatek/
 
@@ -12,7 +12,7 @@ CONFIG_MALI_PLATFORM_THIRDPARTY_NAME := $(CONFIG_MTK_PLATFORM)
 $(info mtk-Kbuild CONFIG_MALI_PLATFORM_THIRDPARTY := $(CONFIG_MALI_PLATFORM_THIRDPARTY))
 $(info mtk-Kbuild CONFIG_MALI_PLATFORM_THIRDPARTY_NAME := $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
 
-CONFIG_MALI_DEBUG := y
+CONFIG_MALI_DEBUG := n
 
 ccflags-y += -I-I$(srctree)/include
 ccflags-y += -I$(srctree)/drivers/staging/android
diff --git a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/mali_kbase_core_linux.c b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
index 422f8d181..95998068e 100644
--- a/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
+++ b/drivers/misc/mediatek/gpu/gpu_mali/mali_bifrost/mali-r25p0/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
@@ -97,7 +97,7 @@
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/log2.h>
-
+#include <linux/pm_qos.h>
 #include <mali_kbase_config.h>
 
 
@@ -555,7 +555,7 @@ int assign_irqs(struct kbase_device *kbdev)
 		irqtag = i;
 #endif /* CONFIG_OF */
 		kbdev->irqs[irqtag].irq = irq_res->start;
-		kbdev->irqs[irqtag].flags = irq_res->flags & IRQF_TRIGGER_MASK;
+		kbdev->irqs[irqtag].flags = irq_res->flags & (IRQF_TRIGGER_MASK | IRQF_PERF_AFFINE);
 	}
 
 	return 0;
@@ -1504,7 +1504,7 @@ static int kbase_api_tlstream_stats(struct kbase_context *kctx,
 		return ret;                                            \
 	} while (0)
 
-static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+static long __kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct kbase_file *const kfile = filp->private_data;
 	struct kbase_context *kctx = NULL;
@@ -1785,6 +1785,21 @@ static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	return -ENOIOCTLCMD;
 }
 
+long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct pm_qos_request req = {
+		.type = PM_QOS_REQ_AFFINE_CORES,
+		.cpus_affine = ATOMIC_INIT(BIT(raw_smp_processor_id()))
+	};
+	long ret;
+
+	pm_qos_add_request(&req, PM_QOS_CPU_DMA_LATENCY, 100);
+	ret = __kbase_ioctl(filp, cmd, arg);
+	pm_qos_remove_request(&req);
+
+	return ret;
+}
+
 static ssize_t kbase_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 {
 	struct kbase_file *const kfile = filp->private_data;
diff --git a/drivers/misc/mediatek/imgsensor/src/common/v1_1/s5k3t2_mipi_raw/s5k3t2mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/common/v1_1/s5k3t2_mipi_raw/s5k3t2mipiraw_Sensor.c
index ba9fc09e4..af6047ef3 100644
--- a/drivers/misc/mediatek/imgsensor/src/common/v1_1/s5k3t2_mipi_raw/s5k3t2mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/common/v1_1/s5k3t2_mipi_raw/s5k3t2mipiraw_Sensor.c
@@ -199,7 +199,7 @@ static struct imgsensor_info_struct imgsensor_info = {
 
 	/* 0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL */
 	.mipi_settle_delay_mode = 1,
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_4CELL_BAYER_Gr,
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,
 	.mclk = 24,	/* mclk value, suggest 24 or 26 for 24Mhz or 26Mhz */
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,
 	//.i2c_speed = 1000, /*support 1MHz write*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6785/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6785/Makefile
index 73998cb7d..942ff44d5 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6785/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6785/Makefile
@@ -45,14 +45,14 @@ endif
 endef
 $(foreach drv,$(subst $\",,$(CONFIG_CUSTOM_KERNEL_IMGSENSOR)),$(eval $(call FILTER_DRV,$(drv))))
 ifneq ($(common_drv),)
-$(info imgsensor drv by common $(common_drv))
+#$(info imgsensor drv by common $(common_drv))
 endif
 obj-y				+= $(common_drv)
 ifneq ($(platform_drv),)
-$(info imgsensor drv by platform $(platform_drv))
+#$(info imgsensor drv by platform $(platform_drv))
 endif
 
-$(info imgsensor drv by platform $(project_drv))
+#$(info imgsensor drv by platform $(project_drv))
 
 obj-y				+= $(platform_drv)
 ifeq (,$(wildcard $(IMGSENSOR_DRIVER_PATH)/$(MTK_PLATFORM)/camera_project/$(ARCH_MTK_PROJECT)/camera_hw))
diff --git a/drivers/misc/mediatek/io_boost/mtk_io_boost.c b/drivers/misc/mediatek/io_boost/mtk_io_boost.c
index 12d6f9b53..8faa6e7d7 100644
--- a/drivers/misc/mediatek/io_boost/mtk_io_boost.c
+++ b/drivers/misc/mediatek/io_boost/mtk_io_boost.c
@@ -127,7 +127,7 @@ static int mtk_iobst_add_task_internal(int tid)
 
 	/* ignore "no such process" error since process may be deleted */
 	if (ret < 0 && (int)ret != -ESRCH)
-		pr_info("failed to write task, ret:%d\n", (int)ret);
+		pr_err("failed to write task, ret:%d\n", (int)ret);
 
 	return 0;
 }
@@ -140,14 +140,14 @@ static int mtk_iobst_add_task(void)
 	ret = mtk_iobst_open_task_file();
 
 	if (ret < 0) {
-		pr_info("failed to open task file, ret=%d\n", ret);
+		pr_err("failed to open task file, ret=%d\n", ret);
 		return ret;
 	}
 
 	while ((tid = mtk_iobst_get_next_tid()) != -1) {
 		ret = mtk_iobst_add_task_internal(tid);
 		if (ret)
-			pr_info("failed to add tid=%d, ret=%d\n", tid, ret);
+			pr_err("failed to add tid=%d, ret=%d\n", tid, ret);
 	}
 
 	mtk_iobst_close_task_file();
@@ -171,7 +171,7 @@ int mtk_iobst_register_tid(int tid)
 	spin_unlock_irq(&bst_lock);
 
 	if (ret)
-		pr_info("failed to register tid=%d\n", tid);
+		pr_err("failed to register tid=%d\n", tid);
 	else if (bst_init_done)
 		wake_up_interruptible(&bst_wq);
 
diff --git a/drivers/misc/mediatek/m4u/mt6785/m4u_priv.h b/drivers/misc/mediatek/m4u/mt6785/m4u_priv.h
index 32b4d3e8a..eb9e901ea 100644
--- a/drivers/misc/mediatek/m4u/mt6785/m4u_priv.h
+++ b/drivers/misc/mediatek/m4u/mt6785/m4u_priv.h
@@ -290,7 +290,7 @@ extern int gM4U_log_to_uart;
 	do {\
 		if (level > gM4U_log_level) {\
 			if (level > gM4U_log_to_uart)\
-				pr_info("[M4U] "string, ##args);\
+				pr_debug("[M4U] "string, ##args);\
 			else\
 				pr_debug("[M4U] "string, ##args);\
 		} \
@@ -302,7 +302,7 @@ extern int gM4U_log_to_uart;
 
 #ifdef CONFIG_MTK_AEE_FEATURE
 #define M4UERR(string, args...) do {\
-	pr_info("[M4U] error:"string, ##args);  \
+	pr_err("[M4U] error:"string, ##args);  \
 		aee_kernel_exception("M4U", "[M4U] error:"string, ##args);  \
 	} while (0)
 
@@ -314,7 +314,7 @@ extern int gM4U_log_to_uart;
 					DB_OPT_DUMP_DISPLAY,            \
 					m4u_name,                       \
 					"[M4U] error"string, ##args);   \
-		pr_info("[M4U] error:"string, ##args);                  \
+		pr_err("[M4U] error:"string, ##args);                  \
 	} while (0)
 /*aee_kernel_warning(m4u_name, "[M4U] error:"string,##args); */
 #else
diff --git a/drivers/misc/mediatek/mdp/mdp_common.c b/drivers/misc/mediatek/mdp/mdp_common.c
index 52bfca3fb..46f58807a 100644
--- a/drivers/misc/mediatek/mdp/mdp_common.c
+++ b/drivers/misc/mediatek/mdp/mdp_common.c
@@ -86,7 +86,7 @@ u32 dre30_hist_sram_start;
 #define CMDQ_LOG_PMQOS(string, args...) \
 do {			\
 	if (cmdq_core_should_pmqos_log()) { \
-		pr_notice("[CMDQ][MDP]"string, ##args); \
+		pr_debug("[CMDQ][MDP]"string, ##args); \
 	} \
 } while (0)
 
@@ -1080,6 +1080,7 @@ static s32 cmdq_mdp_copy_cmd_to_task(struct cmdqRecStruct *handle,
 	return cmdq_pkt_copy_cmd(handle, src, size, user_space);
 }
 
+#ifdef CONFIG_MTK_ENG_BUILD
 static void cmdq_mdp_store_debug(struct cmdqCommandStruct *desc,
 	struct cmdqRecStruct *handle)
 {
@@ -1106,6 +1107,7 @@ static void cmdq_mdp_store_debug(struct cmdqCommandStruct *desc,
 
 	CMDQ_MSG("user debug string:%s\n", handle->user_debug_str);
 }
+#endif
 
 #ifdef CMDQ_SECURE_PATH_SUPPORT
 #define CMDQ_ISP_MSG2(name) \
@@ -1525,8 +1527,9 @@ s32 cmdq_mdp_flush_async(struct cmdqCommandStruct *desc, bool user_space,
 
 	handle->engineFlag = desc->engineFlag & ~inorder_mask;
 	handle->pkt->priority = desc->priority;
+#ifdef CONFIG_MTK_ENG_BUILD
 	cmdq_mdp_store_debug(desc, handle);
-
+#endif
 	if (desc->engineFlag & inorder_mask)
 		handle->force_inorder = true;
 
diff --git a/drivers/misc/mediatek/mlog/Kconfig b/drivers/misc/mediatek/mlog/Kconfig
index 8a2bfeee4..1fbe055de 100644
--- a/drivers/misc/mediatek/mlog/Kconfig
+++ b/drivers/misc/mediatek/mlog/Kconfig
@@ -1,6 +1,6 @@
 config MTK_MLOG
 	bool "Support memory log"
-	default y
+	default n
 	help
           Periodic memory log module.
 
diff --git a/drivers/misc/mediatek/mlog/Makefile b/drivers/misc/mediatek/mlog/Makefile
index ade1236d1..1025d5fc1 100644
--- a/drivers/misc/mediatek/mlog/Makefile
+++ b/drivers/misc/mediatek/mlog/Makefile
@@ -15,4 +15,4 @@ ccflags-$(CONFIG_ZRAM) += -I$(srctree)/drivers/block/zram
 ccflags-$(CONFIG_ZSMALLOC) += -I$(srctree)/drivers/staging/zsmalloc
 ccflags-y += -I$(srctree)/drivers/staging/android/ion
 
-obj-y += mlog_logger.o
+obj-$(CONFIG_MTK_MLOG) += mlog_logger.o
diff --git a/drivers/misc/mediatek/mmdvfs/Makefile b/drivers/misc/mediatek/mmdvfs/Makefile
index aa9abef7c..4ca392550 100644
--- a/drivers/misc/mediatek/mmdvfs/Makefile
+++ b/drivers/misc/mediatek/mmdvfs/Makefile
@@ -132,9 +132,6 @@ obj-y += $(subst ",,$(MTK_PLATFORM))/
 else
 obj-y += mmdvfs_plat_default.o
 endif
-ifeq (true, $(APPLY_CLK_LOG))
-ccflags-y += -DAPPLY_CLK_LOG
-endif
 
 ifeq ($(CONFIG_MTK_QOS_V2),y)
 ifeq (true, $(QOS_BOUND_DETECT))
diff --git a/drivers/misc/mediatek/mmdvfs/mmdvfs_pmqos.c b/drivers/misc/mediatek/mmdvfs/mmdvfs_pmqos.c
index bf063bd04..f23395088 100644
--- a/drivers/misc/mediatek/mmdvfs/mmdvfs_pmqos.c
+++ b/drivers/misc/mediatek/mmdvfs/mmdvfs_pmqos.c
@@ -281,7 +281,7 @@ static void mm_apply_vcore(s32 vopp)
 			v_real = regulator_get_voltage(vcore_reg_id);
 			v_target = get_vcore_uv_table(vopp);
 			if (v_real < v_target) {
-				pr_info("err vcore %d < %d\n",
+				pr_err("err vcore %d < %d\n",
 					v_real, v_target);
 				if (!is_dvfsrc_opp_fixed())
 					aee_kernel_warning("mmdvfs",
@@ -300,14 +300,14 @@ static s32 mm_set_mux_clk(s32 src_mux_id, const char *name,
 
 	if (step_config->clk_mux == NULL ||
 		step_config->clk_source == NULL) {
-		pr_notice("CCF handle can't be NULL during MMDVFS\n");
+		pr_debug("CCF handle can't be NULL during MMDVFS\n");
 		return -EINVAL;
 	}
 
 	ret = clk_prepare_enable(step_config->clk_mux);
 
 	if (ret) {
-		pr_notice("prepare clk(%d): %s-%u\n",
+		pr_debug("prepare clk(%d): %s-%u\n",
 			ret, name, step);
 		return -EFAULT;
 	}
@@ -316,7 +316,7 @@ static s32 mm_set_mux_clk(s32 src_mux_id, const char *name,
 		step_config->clk_mux, step_config->clk_source);
 
 	if (ret)
-		pr_notice(
+		pr_debug(
 			"set parent(%d): %s-%u\n",
 			ret, name, step);
 #ifdef APPLY_CLK_LOG
@@ -327,7 +327,7 @@ static s32 mm_set_mux_clk(s32 src_mux_id, const char *name,
 
 	clk_disable_unprepare(step_config->clk_mux);
 	if (ret)
-		pr_notice(
+		pr_debug(
 			"unprepare clk(%d): %s-%u\n",
 			ret, name, step);
 	return ret;
@@ -344,7 +344,7 @@ static s32 mm_set_freq_hopping_clk(const char *name,
 #endif
 
 	if (ret)
-		pr_notice("hopping rate(%d):(%u)-0x%08x, %s-%u\n",
+		pr_debug("hopping rate(%d):(%u)-0x%08x, %s-%u\n",
 			ret, step_config->pll_id, step_config->pll_value,
 			name, step);
 	return ret;
@@ -373,7 +373,7 @@ static void mm_check_limit(struct mm_freq_config *config,
 		limit_step = &config->limit_config.limit_steps[level-1][step];
 		*step_config = limit_step;
 		if (log_level & 1 << log_limit)
-			pr_notice(
+			pr_debug(
 				"limit %s: freq %llu -> %llu in step %u\n",
 				config->prop_name, normal_step->freq_step,
 				limit_step->freq_step, step);
@@ -397,7 +397,7 @@ static s32 mm_apply_clk(s32 src_mux_id,
 	u32 i;
 
 	if (step >= MAX_FREQ_STEP) {
-		pr_notice(
+		pr_debug(
 			"Invalid clk apply step %d in %s\n",
 			step, config->prop_name);
 		return -EINVAL;
@@ -406,7 +406,7 @@ static s32 mm_apply_clk(s32 src_mux_id,
 	mm_check_limit(config, &step_config, step);
 
 	if (step_config->clk_type == CLK_TYPE_NONE) {
-		pr_notice("No need to change clk of %s\n", config->prop_name);
+		pr_debug("No need to change clk of %s\n", config->prop_name);
 		return 0;
 	}
 
@@ -473,7 +473,7 @@ static void mm_apply_clk_for_all(u32 pm_qos_class, s32 src_mux_id,
 		MMPROFILE_FLAG_PULSE, *((u32 *)&freq[0]), *((u32 *)&freq[4]));
 #endif
 	if (log_level & 1 << log_freq)
-		pr_notice(
+		pr_debug(
 			"freq change:%u class:%u step:%u f0:%x f1:%x\n",
 			real_freq, pm_qos_class, step,
 			*((u32 *)&freq[0]), *((u32 *)&freq[4]));
@@ -531,13 +531,13 @@ void mm_qos_update_larb_bwl(u32 larb_update, bool bw_change)
 		if (force_comm_bwl[comm][comm_port] != 0) {
 			larb_bw = force_comm_bwl[comm][comm_port];
 			if (log_level & 1 << log_bw)
-				pr_notice("force comm:%d port:%d bwl:%#x\n",
+				pr_debug("force comm:%d port:%d bwl:%#x\n",
 				comm, comm_port, larb_bw);
 		} else if (comm_port_limit[comm][comm_port]) {
 			larb_bw = (comm_port_limit[comm][comm_port] << 8)
 					/ freq[comm];
 			if (log_level & 1 << log_bw)
-				pr_notice("comm:%d port:%d bwl:%#x bw:%u\n",
+				pr_debug("comm:%d port:%d bwl:%#x bw:%u\n",
 				comm, comm_port, larb_bw,
 				comm_port_limit[comm][comm_port]);
 		}
@@ -580,7 +580,7 @@ static u32 mmdvfs_get_limit_status(u32 pm_qos_class)
 	u32 i = pm_qos_class - PM_QOS_DISP_FREQ;
 
 	if (i >= ARRAY_SIZE(all_freqs)) {
-		pr_notice("[GET]Invalid class: %u\n", pm_qos_class);
+		pr_debug("[GET]Invalid class: %u\n", pm_qos_class);
 		return false;
 	}
 
@@ -593,12 +593,12 @@ static void update_step(u32 pm_qos_class, s32 src_mux_id)
 	s32 old_max_step;
 
 	if (!mmdvfs_enable || !mmdvfs_autok_enable) {
-		pr_notice("mmdvfs qos is disabled(%d)\n", pm_qos_class);
+		pr_debug("mmdvfs qos is disabled(%d)\n", pm_qos_class);
 		return;
 	}
 
 	if (!step_size) {
-		pr_notice("no step available skip\n");
+		pr_debug("no step available skip\n");
 		return;
 	}
 
@@ -660,7 +660,7 @@ static int mm_freq_notify(struct notifier_block *nb,
 
 	mm_freq = container_of(nb, struct mm_freq_config, nb);
 	if (!step_size) {
-		pr_notice(
+		pr_debug(
 			"no step available in %s, skip\n", mm_freq->prop_name);
 		return NOTIFY_OK;
 	}
@@ -862,7 +862,7 @@ static void simulate_dvfsrc(s32 next_hrt_bw)
 		(!is_up && next_opp > current_opp)) {
 		pm_qos_update_request(&ddr_request, next_opp);
 		if (log_level & 1 << log_bw)
-			pr_notice("up=%d copp=%d nopp=%d cbw=%d nbw=%d\n",
+			pr_debug("up=%d copp=%d nopp=%d cbw=%d nbw=%d\n",
 				is_up, current_opp, next_opp,
 				current_hrt_bw, next_hrt_bw);
 	}
@@ -895,7 +895,7 @@ static void log_hrt_bw_info(u32 master_id)
 #endif
 
 	if (log_level & 1 << log_bw)
-		pr_notice("%s larb=%d p1=%d ccu=%d disp=%d ddr_opp=%d\n",
+		pr_debug("%s larb=%d p1=%d ccu=%d disp=%d ddr_opp=%d\n",
 			__func__, SMI_PMQOS_LARB_DEC(master_id), p1_hrt_bw,
 			ccu_hrt_bw, disp_hrt_bw, ddr_opp);
 }
@@ -911,7 +911,7 @@ static void update_hrt_bw_to_dvfsrc(s32 next_hrt_bw)
 
 	pm_qos_update_request(&dvfsrc_isp_hrt_req, mm_used_hrt_bw);
 	if (log_level & 1 << log_bw)
-		pr_notice("%s report dvfsrc mm_hrt_bw=%d\n",
+		pr_debug("%s report dvfsrc mm_hrt_bw=%d\n",
 			__func__, mm_used_hrt_bw);
 #endif
 }
@@ -928,11 +928,11 @@ static void blocking_camera(void)
 {
 	u32 wait_result;
 
-	pr_notice("begin to blocking for camera_max_bw=%d\n", camera_max_bw);
+	pr_debug("begin to blocking for camera_max_bw=%d\n", camera_max_bw);
 	wait_result = wait_event_timeout(
 		hrt_wait, atomic_read(&lock_cam_count) == 0,
 		msecs_to_jiffies(WAIT_TIMEOUT_MS));
-	pr_notice("blocking wait_result=%d\n", wait_result);
+	pr_debug("blocking wait_result=%d\n", wait_result);
 }
 #endif
 
@@ -981,15 +981,15 @@ s32 mm_qos_add_request(struct plist_head *owner_list,
 	larb_id = SMI_PMQOS_LARB_DEC(smi_master_id);
 	port_id = SMI_PMQOS_PORT_MASK(smi_master_id);
 	if (!req) {
-		pr_notice("mm_add: Invalid req pointer\n");
+		pr_debug("mm_add: Invalid req pointer\n");
 		return -EINVAL;
 	}
 	if (larb_id >= MAX_LARB_COUNT || port_id >= MAX_PORT_COUNT) {
-		pr_notice("mm_add(0x%08x) Invalid master_id\n", smi_master_id);
+		pr_debug("mm_add(0x%08x) Invalid master_id\n", smi_master_id);
 		return -EINVAL;
 	}
 	if (req->init) {
-		pr_notice("mm_add(0x%08x) req is init\n", req->master_id);
+		pr_debug("mm_add(0x%08x) req is init\n", req->master_id);
 		return -EINVAL;
 	}
 
@@ -1016,8 +1016,8 @@ s32 mm_qos_add_request(struct plist_head *owner_list,
 	mutex_unlock(&bw_mutex);
 
 	if (log_level & 1 << log_bw) {
-		pr_notice("mm_add larb=%u port=%d\n", larb_id, port_id);
-		pr_notice("req=%p\n", req);
+		pr_debug("mm_add larb=%u port=%d\n", larb_id, port_id);
+		pr_debug("req=%p\n", req);
 	}
 	return 0;
 }
@@ -1040,20 +1040,20 @@ s32 mm_qos_set_request(struct mm_qos_request *req, u32 bw_value,
 	port = SMI_PMQOS_PORT_MASK(req->master_id);
 	if (!req->init || larb >= MAX_LARB_COUNT ||
 		port >= MAX_PORT_COUNT || comp_type >= BW_COMP_END) {
-		pr_notice("mm_set(0x%08x) init=%d larb=%d port=%d comp=%d\n",
+		pr_debug("mm_set(0x%08x) init=%d larb=%d port=%d comp=%d\n",
 			req->master_id, req->init, larb, port, comp_type);
 		dump_stack();
 		return -EINVAL;
 	}
 	if (!larb_req[larb].port_count || !larb_req[larb].ratio[port]) {
-		pr_notice("mm_set(0x%08x) invalid port_cnt=%d ratio=%d\n",
+		pr_debug("mm_set(0x%08x) invalid port_cnt=%d ratio=%d\n",
 			req->master_id, larb_req[larb].port_count,
 			larb_req[larb].ratio[port]);
 		return -EINVAL;
 	}
 
 	if (bw_value > max_bw_bound || hrt_value > max_bw_bound) {
-		pr_notice("mm_set(0x%08x) invalid bw=%d hrt=%d bw_bound=%d\n",
+		pr_debug("mm_set(0x%08x) invalid bw=%d hrt=%d bw_bound=%d\n",
 			req->master_id, bw_value,
 			hrt_value, max_bw_bound);
 		return -EINVAL;
@@ -1063,7 +1063,7 @@ s32 mm_qos_set_request(struct mm_qos_request *req, u32 bw_value,
 		req->bw_value == bw_value &&
 		req->comp_type == comp_type) {
 		if (log_level & 1 << log_bw)
-			pr_notice("mm_set(0x%08x) no change\n", req->master_id);
+			pr_debug("mm_set(0x%08x) no change\n", req->master_id);
 		return 0;
 	}
 
@@ -1130,13 +1130,13 @@ s32 mm_qos_set_request(struct mm_qos_request *req, u32 bw_value,
 	}
 
 	if (log_level & 1 << log_bw) {
-		pr_notice("set=0x%08x comp=%u,%u\n", req->master_id,
+		pr_debug("set=0x%08x comp=%u,%u\n", req->master_id,
 		comp_type, req->comp_type);
-		pr_notice("set=0x%08x bw=%u,%u total_bw=%d\n", req->master_id,
+		pr_debug("set=0x%08x bw=%u,%u total_bw=%d\n", req->master_id,
 		bw_value, req->bw_value, larb_req[larb].total_bw_data);
-		pr_notice("set=0x%08x hrt=%u,%u total_hrt=%d\n", req->master_id,
+		pr_debug("set=0x%08x hrt=%u,%u total_hrt=%d\n", req->master_id,
 		hrt_value, req->hrt_value, larb_req[larb].total_hrt_data);
-		pr_notice("set=0x%08x o_mix=%u total_mix=%d\n", req->master_id,
+		pr_debug("set=0x%08x o_mix=%u total_mix=%d\n", req->master_id,
 		old_larb_mix_value, larb_req[larb].total_mix_limit);
 	}
 
@@ -1166,7 +1166,7 @@ s32 mm_qos_set_request(struct mm_qos_request *req, u32 bw_value,
 		enum_req->ostd = req->ostd;
 
 	if (log_level & 1 << log_bw)
-		pr_notice("mm_set=0x%08x bw=%u ostd=%u hrt=%u comp=%u\n",
+		pr_debug("mm_set=0x%08x bw=%u ostd=%u hrt=%u comp=%u\n",
 			req->master_id, req->bw_value, req->ostd,
 			req->hrt_value, req->comp_type);
 
@@ -1211,7 +1211,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 #endif
 
 	if (!owner_list || plist_head_empty(owner_list)) {
-		pr_notice("%s: owner_list is invalid\n", __func__);
+		pr_debug("%s: owner_list is invalid\n", __func__);
 		return;
 	}
 
@@ -1220,7 +1220,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 	if (is_camera_larb(req->master_id)) {
 		cam_bw = dram_write_weight(get_cam_hrt_bw());
 		if (cam_bw > camera_max_bw) {
-			pr_notice("cam_bw(%d) > camera_max_bw(%d)\n",
+			pr_debug("cam_bw(%d) > camera_max_bw(%d)\n",
 				cam_bw, camera_max_bw);
 #ifdef MMDVFS_MMP
 			mmprofile_log_ex(
@@ -1235,7 +1235,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 #endif
 		}
 		if (cam_scen_change) {
-			pr_notice("scenario change time=%u cam_bw=%d\n",
+			pr_debug("scenario change time=%u cam_bw=%d\n",
 				jiffies_to_msecs(jiffies-cam_scen_start_time),
 				cam_bw);
 			cam_scen_change = false;
@@ -1246,7 +1246,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 #endif
 		if (total_hrt_bw != UNINITIALIZED_VALUE &&
 			get_total_used_hrt_bw() > total_hrt_bw)
-			pr_notice("hrt bw overflow used=%d avail=%d\n",
+			pr_debug("hrt bw overflow used=%d avail=%d\n",
 				get_total_used_hrt_bw(), total_hrt_bw);
 	}
 
@@ -1274,7 +1274,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 			&comm, &comm_port);
 		larb_update |= 1 << (comm * SMI_COMM_MASTER_NUM + comm_port);
 		if (log_level & 1 << log_bw)
-			pr_notice("update(0x%08x) ostd=%d value=%d hrt=%d\n",
+			pr_debug("update(0x%08x) ostd=%d value=%d hrt=%d\n",
 				req->master_id, req->ostd,
 				req->bw_value, req->hrt_value);
 		trace_mmqos__update_port(larb_id, port_id,
@@ -1319,7 +1319,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 		profile = sched_clock();
 		smi_ostd_update(owner_list, "MMDVFS");
 		if (log_level & 1 << log_bw)
-			pr_notice("config SMI (%d) cost: %llu us\n",
+			pr_debug("config SMI (%d) cost: %llu us\n",
 				i, div_u64(sched_clock() - profile, 1000));
 	}
 
@@ -1344,7 +1344,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 			max_ch_hrt_bw = max_t(s32,
 				final_chn_hrt_bw[comm][i], max_ch_hrt_bw);
 			if (log_level & 1 << log_smi_freq)
-				pr_notice("comm:%d chn:%d s_bw:%d h_bw:%d\n",
+				pr_debug("comm:%d chn:%d s_bw:%d h_bw:%d\n",
 					comm, i, channel_srt_bw[comm][i],
 					final_chn_hrt_bw[comm][i]);
 #ifdef MMDVFS_MMP
@@ -1364,7 +1364,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 		pm_qos_update_request(&smi_freq_request[comm],
 			max_t(s32, smi_srt_clk, smi_hrt_clk));
 		if (log_level & 1 << log_smi_freq)
-			pr_notice("comm:%d smi_srt_clk:%d smi_hrt_clk:%d\n",
+			pr_debug("comm:%d smi_srt_clk:%d smi_hrt_clk:%d\n",
 				comm, smi_srt_clk, smi_hrt_clk);
 #ifdef MMDVFS_MMP
 		mmprofile_log_ex(
@@ -1394,7 +1394,7 @@ void mm_qos_update_all_request(struct plist_head *owner_list)
 	}
 	pm_qos_update_request(&mm_bw_request, mm_bw);
 	if (log_level & 1 << log_bw)
-		pr_notice("config mm_bw=%d\n", mm_bw);
+		pr_debug("config mm_bw=%d\n", mm_bw);
 	mutex_unlock(&bw_mutex);
 }
 EXPORT_SYMBOL_GPL(mm_qos_update_all_request);
@@ -1416,7 +1416,7 @@ void mm_qos_remove_all_request(struct plist_head *owner_list)
 
 	mutex_lock(&bw_mutex);
 	plist_for_each_entry_safe(req, temp, owner_list, owner_node) {
-		pr_notice("mm_del(0x%08x)\n", req->master_id);
+		pr_debug("mm_del(0x%08x)\n", req->master_id);
 		plist_del(&(req->owner_node), owner_list);
 		list_del(&(req->larb_node));
 		list_del(&(req->port_node));
@@ -1483,7 +1483,7 @@ static int notify_bw_throttle(void *data)
 	blocking_notifier_call_chain(&hrt_bw_throttle_notifier,
 		(camera_max_bw > 0)?BW_THROTTLE_START:BW_THROTTLE_END, NULL);
 
-	pr_notice("notify_time=%u\n",
+	pr_debug("notify_time=%u\n",
 		jiffies_to_msecs(jiffies-start_jiffies));
 	return 0;
 }
@@ -1495,7 +1495,7 @@ static int notify_bw_throttle_blocking(void *data)
 
 	atomic_dec(&lock_cam_count);
 	wake_up(&hrt_wait);
-	pr_notice("decrease lock_cam_count=%d\n",
+	pr_debug("decrease lock_cam_count=%d\n",
 		atomic_read(&lock_cam_count));
 	return 0;
 }
@@ -1508,12 +1508,12 @@ static void set_camera_max_bw(u32 occ_bw)
 
 	camera_max_bw = occ_bw;
 	wait_next_max_cam_bw_set = false;
-	pr_notice("set cam max occupy_bw=%d\n", occ_bw);
+	pr_debug("set cam max occupy_bw=%d\n", occ_bw);
 #ifdef BLOCKING_MECHANISM
 	/* No need to blocking if cam bw is decreasing */
 	if (camera_overlap_bw == 0) {
 		atomic_inc(&lock_cam_count);
-		pr_notice("increase lock_cam_count=%d\n",
+		pr_debug("increase lock_cam_count=%d\n",
 			atomic_read(&lock_cam_count));
 		pKThread = kthread_run(notify_bw_throttle_blocking,
 			NULL, "notify bw throttle blocking");
@@ -1550,7 +1550,7 @@ void mmdvfs_set_max_camera_hrt_bw(u32 bw)
 		set_camera_max_bw(mw_hrt_bw);
 	}
 
-	pr_notice("middleware set max camera hrt bw:%d\n", bw);
+	pr_debug("middleware set max camera hrt bw:%d\n", bw);
 #endif
 }
 EXPORT_SYMBOL_GPL(mmdvfs_set_max_camera_hrt_bw);
@@ -1585,7 +1585,7 @@ static void get_module_clock_by_index(struct device *dev,
 	result = of_property_read_string_index(dev->of_node, "clock-names",
 		index, &clk_name);
 	if (unlikely(result)) {
-		pr_notice("Cannot get module name of index (%u), result (%d)\n",
+		pr_debug("Cannot get module name of index (%u), result (%d)\n",
 			index, result);
 		return;
 	}
@@ -1593,11 +1593,11 @@ static void get_module_clock_by_index(struct device *dev,
 	*clk_module = devm_clk_get(dev, clk_name);
 	if (IS_ERR(*clk_module)) {
 		/* error status print */
-		pr_notice("Cannot get module clock: %s\n", clk_name);
+		pr_debug("Cannot get module clock: %s\n", clk_name);
 		*clk_module = NULL;
 	} else {
 		/* message print */
-		pr_notice("Get module clock: %s\n", clk_name);
+		pr_debug("Get module clock: %s\n", clk_name);
 	}
 }
 
@@ -1629,12 +1629,12 @@ static void mmdvfs_get_step_node(struct device *dev,
 			step_config->pll_value =
 				step[mm_dp_pll_value];
 		}
-		pr_notice("%s: %lluMHz, clk:%u/%u/%u\n",
+		pr_debug("%s: %lluMHz, clk:%u/%u/%u\n",
 			name, step_config->freq_step,
 			step_config->clk_type,
 			step[mm_dp_clk_param1], step[mm_dp_clk_param2]);
 	} else {
-		pr_notice("read freq steps %s failed (%d)\n", name, result);
+		pr_debug("read freq steps %s failed (%d)\n", name, result);
 	}
 }
 
@@ -1647,17 +1647,17 @@ static void mmdvfs_get_larb_node(struct device *dev, u32 larb_id)
 	s32 result;
 
 	if (larb_id >= MAX_LARB_COUNT) {
-		pr_notice("larb_id:%d is over MAX_LARB_COUNT:%d\n",
+		pr_debug("larb_id:%d is over MAX_LARB_COUNT:%d\n",
 			larb_id, MAX_LARB_COUNT);
 		return;
 	}
 
 	result = snprintf(larb_name, MAX_LARB_NAME, "larb%d", larb_id);
 	if (result < 0)
-		pr_notice("snprintf fail(%d) larb_id=%d\n", result, larb_id);
+		pr_debug("snprintf fail(%d) larb_id=%d\n", result, larb_id);
 	of_property_for_each_u32(dev->of_node, larb_name, prop, p, value) {
 		if (count >= MAX_PORT_COUNT) {
-			pr_notice("port size is over (%d)\n", MAX_PORT_COUNT);
+			pr_debug("port size is over (%d)\n", MAX_PORT_COUNT);
 			break;
 		}
 
@@ -1667,7 +1667,7 @@ static void mmdvfs_get_larb_node(struct device *dev, u32 larb_id)
 
 	larb_req[larb_id].port_count = count;
 	if (!count)
-		pr_notice("no data in larb (%s)\n", larb_name);
+		pr_debug("no data in larb (%s)\n", larb_name);
 	else
 		init_larb_list(larb_id);
 }
@@ -1719,14 +1719,14 @@ static void mmdvfs_get_step_array_node(struct device *dev,
 	const char *name;
 	char ext_name[32] = {0};
 
-	pr_notice("start get step node of %s\n", freq_name);
+	pr_debug("start get step node of %s\n", freq_name);
 	of_property_for_each_string(dev->of_node, freq_name, prop, name) {
 		if (count >= MAX_FREQ_STEP) {
-			pr_notice("freq setting %s is over the MAX_STEP (%d)\n",
+			pr_debug("freq setting %s is over the MAX_STEP (%d)\n",
 				freq_name, MAX_FREQ_STEP);
 			break;
 		}
-		pr_notice(" node name %s\n", name);
+		pr_debug(" node name %s\n", name);
 		mmdvfs_get_step_node(dev, name, &step_configs[count]);
 		strncpy(ext_name, name, sizeof(ext_name)-1);
 		strncat(ext_name, "_ext",
@@ -1736,9 +1736,9 @@ static void mmdvfs_get_step_array_node(struct device *dev,
 		count++;
 	}
 	if (count != step_size)
-		pr_notice("freq setting %s is not same as vcore_steps (%d)\n",
+		pr_debug("freq setting %s is not same as vcore_steps (%d)\n",
 			freq_name, step_size);
-	pr_notice("%s: step size:%u\n", freq_name, step_size);
+	pr_debug("%s: step size:%u\n", freq_name, step_size);
 }
 
 static void mmdvfs_get_limit_step_node(struct device *dev,
@@ -1757,7 +1757,7 @@ static void mmdvfs_get_limit_step_node(struct device *dev,
 	if (result < 0 || !limit_size)
 		return;
 
-	pr_notice("[limit]%s size: %u\n", freq_name, limit_size);
+	pr_debug("[limit]%s size: %u\n", freq_name, limit_size);
 	limit_config->limit_size = limit_size;
 	limit_config->limit_steps = kcalloc(limit_size,
 		sizeof(*limit_config->limit_steps), GFP_KERNEL);
@@ -1767,16 +1767,16 @@ static void mmdvfs_get_limit_step_node(struct device *dev,
 		result = snprintf(ext_name, sizeof(ext_name) - 1,
 			"%s_limit_%d", freq_name, i);
 		if (result < 0) {
-			pr_notice("snprint fail(%d) freq=%s id=%d\n",
+			pr_debug("snprint fail(%d) freq=%s id=%d\n",
 				result, freq_name, i);
 			continue;
 		}
-		pr_notice("[limit]%s-%d: %s\n", freq_name, i, ext_name);
+		pr_debug("[limit]%s-%d: %s\n", freq_name, i, ext_name);
 		mmdvfs_get_step_array_node(dev, ext_name,
 			limit_config->limit_steps[i]);
 	}
 #else
-	pr_notice("MMDVFS limit is off\n");
+	pr_debug("MMDVFS limit is off\n");
 #endif
 }
 
@@ -1827,7 +1827,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 	step_size = 0;
 	of_property_for_each_u32(node, VCORE_NODE_NAME, prop, p, value) {
 		if (step_size >= MAX_FREQ_STEP) {
-			pr_notice(
+			pr_debug(
 				"vcore_steps is over the MAX_STEP (%d)\n",
 				MAX_FREQ_STEP);
 			break;
@@ -1839,7 +1839,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 	mux_size = 0;
 	of_property_for_each_u32(node, FMETER_MUX_NODE_NAME, prop, p, value) {
 		if (mux_size >= MAX_MUX_SIZE) {
-			pr_notice(
+			pr_debug(
 				"fmeter_mux_ids is over the MAX_MUX_SIZE (%d)\n",
 				MAX_MUX_SIZE);
 			break;
@@ -1848,7 +1848,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 		mux_size++;
 	}
 
-	pr_notice("vcore_steps: [%u, %u, %u, %u, %u, %u], count:%u\n",
+	pr_debug("vcore_steps: [%u, %u, %u, %u, %u, %u], count:%u\n",
 		vopp_steps[0], vopp_steps[1], vopp_steps[2],
 		vopp_steps[3], vopp_steps[4], vopp_steps[5], step_size);
 
@@ -1860,7 +1860,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 		if (likely(mm_freq->pm_qos_class >= PM_QOS_DISP_FREQ)) {
 			pm_qos_add_notifier(mm_freq->pm_qos_class,
 				&mm_freq->nb);
-			pr_notice("%s: add notifier\n", mm_freq->prop_name);
+			pr_debug("%s: add notifier\n", mm_freq->prop_name);
 		}
 
 		mmdvfs_get_limit_step_node(&pdev->dev, mm_freq->prop_name,
@@ -1869,7 +1869,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 
 	of_property_for_each_string(node, "comm_freq", prop, mux_name) {
 		if (comm_count >= MAX_COMM_NUM) {
-			pr_notice("comm_count > MAX_COMM_NUM (%d)\n",
+			pr_debug("comm_count > MAX_COMM_NUM (%d)\n",
 				MAX_COMM_NUM);
 			break;
 		}
@@ -1881,7 +1881,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 			}
 		}
 		if (i == ARRAY_SIZE(all_freqs)) {
-			pr_notice("wrong comm_freq name:%s\n", mux_name);
+			pr_debug("wrong comm_freq name:%s\n", mux_name);
 			break;
 		}
 		pm_qos_add_request(&smi_freq_request[comm_count],
@@ -1893,7 +1893,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 	cam_larb_size = 0;
 	of_property_for_each_u32(node, CAM_LARB_NODE_NAME, prop, p, value) {
 		if (cam_larb_size >= MAX_LARB_COUNT) {
-			pr_notice(
+			pr_debug(
 				"cam_larb is over the MAX_LARB_COUNT (%d)\n",
 				MAX_LARB_COUNT);
 			break;
@@ -1905,7 +1905,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 	of_property_for_each_u32(
 		node, MAX_OSTD_LARB_NODE_NAME, prop, p, value) {
 		if (value >= MAX_LARB_COUNT) {
-			pr_notice(
+			pr_debug(
 				"max_ostd_larb (%d) is over the MAX_LARB_COUNT (%d)\n",
 				value, MAX_LARB_COUNT);
 			continue;
@@ -1937,14 +1937,14 @@ static int mmdvfs_probe(struct platform_device *pdev)
 		if (value != SMI_COMM_MASTER_NUM)
 			larb_req[i].channel =
 				SMI_COMM_BUS_SEL[value & 0xffff];
-		pr_notice("larb[%d].comm_port=%d channel=%d\n",
+		pr_debug("larb[%d].comm_port=%d channel=%d\n",
 				i, value, larb_req[i].channel);
 	}
 
 	mmdvfs_qos_get_freq_steps(PM_QOS_DISP_FREQ, freq_steps, &value);
-	pr_notice("disp step size:%u\n", value);
+	pr_debug("disp step size:%u\n", value);
 	for (i = 0; i < value && i < MAX_FREQ_STEP; i++)
-		pr_notice(" - step[%d]: %llu\n", i, freq_steps[i]);
+		pr_debug(" - step[%d]: %llu\n", i, freq_steps[i]);
 
 #ifdef BLOCKING_MECHANISM
 	init_waitqueue_head(&hrt_wait);
@@ -1952,7 +1952,7 @@ static int mmdvfs_probe(struct platform_device *pdev)
 
 	vcore_reg_id = regulator_get(&pdev->dev, "vcore");
 	if (!vcore_reg_id)
-		pr_info("regulator_get vcore_reg_id failed\n");
+		pr_err("regulator_get vcore_reg_id failed\n");
 	return 0;
 
 }
@@ -2007,12 +2007,12 @@ static int __init mmdvfs_pmqos_init(void)
 
 	status = platform_driver_register(&mmdvfs_pmqos_driver);
 	if (status != 0) {
-		pr_notice(
+		pr_debug(
 			"Failed to register MMDVFS-PMQOS driver(%d)\n", status);
 		return -ENODEV;
 	}
 
-	pr_notice("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	return 0;
 #endif /* CONFIG_FPGA_EARLY_PORTING */
 }
@@ -2061,11 +2061,11 @@ static int __init mmdvfs_pmqos_late_init(void)
 #ifdef MMDVFS_FORCE_STEP0
 	mmdvfs_qos_force_step(0);
 	mmdvfs_enable = false;
-	pr_notice("force set step0 when late_init\n");
+	pr_debug("force set step0 when late_init\n");
 #else
 	mmdvfs_qos_force_step(0);
 	mmdvfs_qos_force_step(-1);
-	pr_notice("force flip step0 when late_init\n");
+	pr_debug("force flip step0 when late_init\n");
 #endif
 	total_hrt_bw = get_total_hrt_bw();
 	init_me_swpm();
@@ -2099,18 +2099,18 @@ void mmdvfs_qos_limit_config(u32 pm_qos_class, u32 limit_value,
 	s32 old_level = 0;
 
 	if (unlikely(i >= ARRAY_SIZE(all_freqs))) {
-		pr_notice("[%d]Invalid class=%u %d\n",
+		pr_debug("[%d]Invalid class=%u %d\n",
 			source, pm_qos_class, old_level);
 		return;
 	}
 
 	if (!all_freqs[i]->limit_config.limit_size) {
-		pr_notice("[%d]Not support limit: %u\n", source, pm_qos_class);
+		pr_debug("[%d]Not support limit: %u\n", source, pm_qos_class);
 		return;
 	}
 
 	if (log_level & log_limit)
-		pr_notice("[%d][%d]limit score update=(%d, %u, %u)\n",
+		pr_debug("[%d][%d]limit score update=(%d, %u, %u)\n",
 			source, pm_qos_class, limit_value,
 			all_freqs[i]->limit_config.limit_value,
 			all_freqs[i]->limit_config.limit_level);
@@ -2123,7 +2123,7 @@ void mmdvfs_qos_limit_config(u32 pm_qos_class, u32 limit_value,
 		&all_freqs[i]->limit_config.limit_level);
 
 	if (old_level != all_freqs[i]->limit_config.limit_level) {
-		pr_notice("MMDVFS limit level changed for %s %d->%d\n",
+		pr_debug("MMDVFS limit level changed for %s %d->%d\n",
 			all_freqs[i]->prop_name, old_level,
 			all_freqs[i]->limit_config.limit_level);
 		mm_apply_clk(-1, all_freqs[i], current_max_step,
@@ -2205,7 +2205,7 @@ MODULE_PARM_DESC(dump_setting, "dump mmdvfs current setting");
 int mmdvfs_qos_force_step(int step)
 {
 	if (step >= (s32)step_size || step < STEP_UNREQUEST) {
-		pr_notice("force set step invalid: %d\n", step);
+		pr_debug("force set step invalid: %d\n", step);
 		return -EINVAL;
 	}
 	force_step = step;
@@ -2221,7 +2221,7 @@ int set_force_step(const char *val, const struct kernel_param *kp)
 
 	result = kstrtoint(val, 0, &new_force_step);
 	if (result) {
-		pr_notice("force set step failed: %d\n", result);
+		pr_debug("force set step failed: %d\n", result);
 		return result;
 	}
 	return mmdvfs_qos_force_step(new_force_step);
@@ -2236,7 +2236,7 @@ MODULE_PARM_DESC(force_step, "force mmdvfs to specified step, -1 for unset");
 
 void mmdvfs_autok_qos_enable(bool enable)
 {
-	pr_notice("%s: step_size=%d current_max_step=%d\n",
+	pr_debug("%s: step_size=%d current_max_step=%d\n",
 		__func__, step_size, current_max_step);
 	if (!enable && step_size > 0 && current_max_step == STEP_UNREQUEST)
 		mmdvfs_qos_force_step(step_size - 1);
@@ -2244,14 +2244,14 @@ void mmdvfs_autok_qos_enable(bool enable)
 	mmdvfs_autok_enable = enable;
 	if (enable && step_size > 0)
 		mmdvfs_qos_force_step(-1);
-	pr_notice("mmdvfs_autok enabled? %d\n", enable);
+	pr_debug("mmdvfs_autok enabled? %d\n", enable);
 }
 EXPORT_SYMBOL_GPL(mmdvfs_autok_qos_enable);
 
 void mmdvfs_qos_enable(bool enable)
 {
 	mmdvfs_enable = enable;
-	pr_notice("mmdvfs enabled? %d\n", enable);
+	pr_debug("mmdvfs enabled? %d\n", enable);
 }
 EXPORT_SYMBOL_GPL(mmdvfs_qos_enable);
 
@@ -2262,7 +2262,7 @@ int set_enable(const char *val, const struct kernel_param *kp)
 
 	result = kstrtobool(val, &enable);
 	if (result) {
-		pr_notice("force set enable: %d\n", result);
+		pr_debug("force set enable: %d\n", result);
 		return result;
 	}
 	mmdvfs_qos_enable(enable);
@@ -2281,12 +2281,12 @@ void mmdvfs_prepare_action(enum mmdvfs_prepare_event event)
 {
 	if (event == MMDVFS_PREPARE_CALIBRATION_START) {
 		mmdvfs_autok_qos_enable(false);
-		pr_notice("mmdvfs service is disabled for calibration\n");
+		pr_debug("mmdvfs service is disabled for calibration\n");
 	} else if (event == MMDVFS_PREPARE_CALIBRATION_END) {
 		mmdvfs_autok_qos_enable(true);
-		pr_notice("mmdvfs service is enabled after calibration\n");
+		pr_debug("mmdvfs service is enabled after calibration\n");
 	} else {
-		pr_notice("%s: unknown event code:%d\n", __func__, event);
+		pr_debug("%s: unknown event code:%d\n", __func__, event);
 	}
 }
 
@@ -2302,7 +2302,7 @@ s32 get_virtual_port(enum virtual_source_id id)
 	case VIRTUAL_CCU_COMMON2:
 		return PORT_VIRTUAL_CCU_COMMON2;
 	default:
-		pr_notice("invalid source id:%u\n", id);
+		pr_debug("invalid source id:%u\n", id);
 		return -1;
 	}
 }
@@ -2369,12 +2369,12 @@ void mmdvfs_print_larbs_info(void)
 		tmp_str = log_str;
 		if (len > 0) {
 			while ((ptr = strsep(&tmp_str, "\n")) != NULL)
-				pr_notice("%s\n", ptr);
+				pr_debug("%s\n", ptr);
 		} else
-			pr_notice("no larbs info to print\n");
+			pr_debug("no larbs info to print\n");
 		kfree(log_str);
 	} else
-		pr_notice("kmalloc fails!\n");
+		pr_debug("kmalloc fails!\n");
 }
 
 int get_dump_larbs(char *buf, const struct kernel_param *kp)
@@ -2422,7 +2422,7 @@ int set_vote_freq(const char *val, const struct kernel_param *kp)
 
 	result = kstrtoint(val, 0, &new_vote_freq);
 	if (result) {
-		pr_notice("force set step failed: %d\n", result);
+		pr_debug("force set step failed: %d\n", result);
 		return result;
 	}
 
@@ -2454,7 +2454,7 @@ static DECLARE_COMPLETION(comp);
 static int test_event(struct notifier_block *nb,
 		unsigned long value, void *v)
 {
-	pr_notice("ut test notifier: value=%lu\n", value);
+	pr_debug("ut test notifier: value=%lu\n", value);
 	/*msleep(50);*/ /* Use it when disp's notifier callback not ready*/
 	complete(&comp);
 	return 0;
@@ -2489,15 +2489,15 @@ int mmdvfs_qos_ut_set(const char *val, const struct kernel_param *kp)
 	result = sscanf(val, "%d %d %i %d", &qos_ut_case,
 		&req_id, &master, &value);
 	if (result != 4) {
-		pr_notice("invalid input: %s, result(%d)\n", val, result);
+		pr_debug("invalid input: %s, result(%d)\n", val, result);
 		return -EINVAL;
 	}
 	if (req_id >= UT_MAX_REQUEST) {
-		pr_notice("invalid req_id: %u\n", req_id);
+		pr_debug("invalid req_id: %u\n", req_id);
 		return -EINVAL;
 	}
 
-	pr_notice("ut with (case_id,req_id,master,value)=(%d,%u,%#x,%d)\n",
+	pr_debug("ut with (case_id,req_id,master,value)=(%d,%u,%#x,%d)\n",
 		qos_ut_case, req_id, master, value);
 	log_level = 1 << log_bw | 1 << log_freq | 1 << log_smi_freq;
 	if (!ut_req_init) {
@@ -2545,14 +2545,14 @@ int mmdvfs_qos_ut_set(const char *val, const struct kernel_param *kp)
 		pKThread = kthread_run(make_cam_hrt_bw,
 			NULL, "make_cam_hrt_bw");
 		if (IS_ERR(pKThread))
-			pr_notice("create cam hrt bw thread failed\n");
+			pr_debug("create cam hrt bw thread failed\n");
 		/* Notifier will call complete */
 		wait_for_completion(&comp);
 		reinit_completion(&comp);
 		start_jiffies = jiffies;
 		mmdvfs_set_max_camera_hrt_bw(0);
 		wait_for_completion(&comp);
-		pr_notice("wait time should > 2000 msecs:%u\n",
+		pr_debug("wait time should > 2000 msecs:%u\n",
 			jiffies_to_msecs(jiffies-start_jiffies));
 		mm_hrt_remove_bw_throttle_notifier(&test_notifier);
 		break;
@@ -2568,13 +2568,13 @@ int mmdvfs_qos_ut_set(const char *val, const struct kernel_param *kp)
 		mm_qos_update_all_request_zero(&ut_req_list);
 		break;
 	default:
-		pr_notice("invalid case_id: %d\n", qos_ut_case);
+		pr_debug("invalid case_id: %d\n", qos_ut_case);
 		break;
 	}
 
-	pr_notice("Call SMI Dump API Begin\n");
+	pr_debug("Call SMI Dump API Begin\n");
 	/* smi_debug_bus_hang_detect(false, "MMDVFS"); */
-	pr_notice("Call SMI Dump API END\n");
+	pr_debug("Call SMI Dump API END\n");
 	log_level = old_log_level;
 	return 0;
 }
@@ -2596,10 +2596,10 @@ int mmdvfs_ut_set(const char *val, const struct kernel_param *kp)
 
 	result = sscanf(val, "%d %d", &mmdvfs_ut_case, &value1);
 	if (result != 2) {
-		pr_notice("invalid input: %s, result(%d)\n", val, result);
+		pr_debug("invalid input: %s, result(%d)\n", val, result);
 		return -EINVAL;
 	}
-	pr_notice("%s (case_id, value): (%d,%d)\n",
+	pr_debug("%s (case_id, value): (%d,%d)\n",
 		__func__, mmdvfs_ut_case, value1);
 
 	log_level = 1 << log_freq |
@@ -2612,45 +2612,45 @@ int mmdvfs_ut_set(const char *val, const struct kernel_param *kp)
 		result = sscanf(val, "%d %d %d", &mmdvfs_ut_case,
 			&value1, &value2);
 		if (result != 3) {
-			pr_notice("invalid arguments: %s\n", val);
+			pr_debug("invalid arguments: %s\n", val);
 			break;
 		}
-		pr_notice("limit test score: %d\n", value2);
-		pr_notice("limit initial: %d\n",
+		pr_debug("limit test score: %d\n", value2);
+		pr_debug("limit initial: %d\n",
 			mmdvfs_get_limit_status(value1));
 		/* limit enable then opp1 -> opp0 */
 		mmdvfs_qos_limit_config(value1, 1, MMDVFS_LIMIT_THERMAL);
 		mmdvfs_qos_limit_config(value1, value2, MMDVFS_LIMIT_CAM);
 		pm_qos_update_request(&disp_req, 1000);
-		pr_notice("limit enable then opp up: %d freq=%llu MHz\n",
+		pr_debug("limit enable then opp up: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 		/* limit disable when opp0 */
 		mmdvfs_qos_limit_config(value1, 0, MMDVFS_LIMIT_THERMAL);
-		pr_notice("limit disable when opp up: %d freq=%llu MHz\n",
+		pr_debug("limit disable when opp up: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 		/* limit enable when opp0 */
 		mmdvfs_qos_limit_config(value1, 1, MMDVFS_LIMIT_THERMAL);
-		pr_notice("limit enable when opp up: %d freq=%llu MHz\n",
+		pr_debug("limit enable when opp up: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 		/* limit disable then opp0 -> opp1 */
 		mmdvfs_qos_limit_config(value1, 0, MMDVFS_LIMIT_THERMAL);
 		pm_qos_update_request(&disp_req, 0);
-		pr_notice("limit disable then opp down: %d freq=%llu MHz\n",
+		pr_debug("limit disable then opp down: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 		/* limit enable when opp1 */
 		mmdvfs_qos_limit_config(value1, 1, MMDVFS_LIMIT_THERMAL);
 		pm_qos_update_request(&disp_req, 0);
-		pr_notice("limit enable when opp down: %d freq=%llu MHz\n",
+		pr_debug("limit enable when opp down: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 		/* limit disable when opp1 */
 		mmdvfs_qos_limit_config(value1, 0, MMDVFS_LIMIT_THERMAL);
 		pm_qos_update_request(&disp_req, 0);
-		pr_notice("limit disable when opp down: %d freq=%llu MHz\n",
+		pr_debug("limit disable when opp down: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 
@@ -2659,30 +2659,30 @@ int mmdvfs_ut_set(const char *val, const struct kernel_param *kp)
 		result = sscanf(val, "%d %d %d", &mmdvfs_ut_case,
 			&value1, &value2);
 		if (result != 3) {
-			pr_notice("invalid arguments: %s\n", val);
+			pr_debug("invalid arguments: %s\n", val);
 			mmdvfs_qos_limit_config(value1, 0,
 				MMDVFS_LIMIT_THERMAL);
 			break;
 		}
-		pr_notice("limit test score: %d\n", value2);
-		pr_notice("limit initial: %d freq=%llu MHz\n",
+		pr_debug("limit test score: %d\n", value2);
+		pr_debug("limit initial: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 		mmdvfs_qos_limit_config(value1, 1, MMDVFS_LIMIT_THERMAL);
 		mmdvfs_qos_limit_config(value1, value2, MMDVFS_LIMIT_CAM);
-		pr_notice("limit now: %d freq=%llu MHz\n",
+		pr_debug("limit now: %d freq=%llu MHz\n",
 			mmdvfs_get_limit_status(value1),
 			mmdvfs_qos_get_freq(value1));
 
 		break;
 	default:
-		pr_notice("invalid case_id: %d\n", mmdvfs_ut_case);
+		pr_debug("invalid case_id: %d\n", mmdvfs_ut_case);
 		break;
 	}
 
 	pm_qos_remove_request(&disp_req);
 
-	pr_notice("%s END\n", __func__);
+	pr_debug("%s END\n", __func__);
 	log_level = old_log_level;
 	return 0;
 }
@@ -2703,17 +2703,17 @@ int set_disp_bw_ceiling(const char *val, const struct kernel_param *kp)
 
 	result = sscanf(val, "%d %d", &disp_bw, &wait);
 	if (result != 2) {
-		pr_notice("invalid input: %s, result(%d)\n", val, result);
+		pr_debug("invalid input: %s, result(%d)\n", val, result);
 		return -EINVAL;
 	}
-	pr_notice("%s (disp_bw, wait): (%d,%d)\n",
+	pr_debug("%s (disp_bw, wait): (%d,%d)\n",
 		__func__, disp_bw, wait);
 
 	disp_bw_ceiling = (disp_bw < 0)?0:disp_bw;
 	wait_next_max_cam_bw_set = wait;
 
 	disp_avail_hrt_bw = mm_hrt_get_available_hrt_bw(PORT_VIRTUAL_DISP);
-	pr_notice("disp_bw_ceiling=%d total_hrt_bw=%d disp_avail_hrt_bw=%d\n",
+	pr_debug("disp_bw_ceiling=%d total_hrt_bw=%d disp_avail_hrt_bw=%d\n",
 		disp_bw_ceiling, total_hrt_bw, disp_avail_hrt_bw);
 
 	if (!wait_next_max_cam_bw_set)
@@ -2740,7 +2740,7 @@ int set_force_bwl(const char *val, const struct kernel_param *kp)
 
 	result = sscanf(val, "%d %d %d", &comm, &port, &bwl);
 	if (result != 3) {
-		pr_notice("invalid input: %s, result(%d)\n", val, result);
+		pr_debug("invalid input: %s, result(%d)\n", val, result);
 		return -EINVAL;
 	}
 
diff --git a/drivers/misc/mediatek/mmdvfs/swpm_me.c b/drivers/misc/mediatek/mmdvfs/swpm_me.c
index 6b0c2951c..3126d3e5f 100644
--- a/drivers/misc/mediatek/mmdvfs/swpm_me.c
+++ b/drivers/misc/mediatek/mmdvfs/swpm_me.c
@@ -59,7 +59,7 @@ void set_swpm_me_freq(unsigned int venc_freq,
 		return;
 
 	if (!me_swpm) {
-		pr_notice("%s: re-init me_swpm\n", __func__);
+		pr_debug("%s: re-init me_swpm\n", __func__);
 		init_me_swpm();
 	}
 
@@ -114,7 +114,7 @@ void set_swpm_disp_active(bool is_on)
 		return;
 
 	if (!me_swpm) {
-		pr_notice("%s: re-init me_swpm\n", __func__);
+		pr_debug("%s: re-init me_swpm\n", __func__);
 		init_me_swpm();
 	}
 
@@ -136,7 +136,7 @@ void set_swpm_disp_work(void)
 		return;
 
 	if (!me_swpm) {
-		pr_notice("%s: re-init me_swpm\n", __func__);
+		pr_debug("%s: re-init me_swpm\n", __func__);
 		init_me_swpm();
 	}
 
@@ -160,7 +160,7 @@ void set_swpm_venc_active(bool is_on)
 		return;
 
 	if (!me_swpm) {
-		pr_notice("%s: re-init me_swpm\n", __func__);
+		pr_debug("%s: re-init me_swpm\n", __func__);
 		init_me_swpm();
 	}
 
@@ -187,7 +187,7 @@ void set_swpm_vdec_active(bool is_on)
 		return;
 
 	if (!me_swpm) {
-		pr_notice("%s: re-init me_swpm\n", __func__);
+		pr_debug("%s: re-init me_swpm\n", __func__);
 		init_me_swpm();
 	}
 
@@ -210,7 +210,7 @@ void set_swpm_mdp_active(bool is_on)
 		return;
 
 	if (!me_swpm) {
-		pr_notice("%s: re-init me_swpm\n", __func__);
+		pr_debug("%s: re-init me_swpm\n", __func__);
 		init_me_swpm();
 	}
 
diff --git a/drivers/misc/mediatek/pmic/mt6359/v1/mt6359_gauge.c b/drivers/misc/mediatek/pmic/mt6359/v1/mt6359_gauge.c
index da59be193..eb48e50e3 100644
--- a/drivers/misc/mediatek/pmic/mt6359/v1/mt6359_gauge.c
+++ b/drivers/misc/mediatek/pmic/mt6359/v1/mt6359_gauge.c
@@ -90,7 +90,7 @@ int MV_to_REG_12_value(signed int _reg)
 {
 	int ret = (_reg * 4096) / (VOLTAGE_FULL_RANGES * R_VAL_TEMP_3);
 
-	bm_trace("[%s] %d => %d\n", __func__, _reg, ret);
+	bm_debug("[%s] %d => %d\n", __func__, _reg, ret);
 	return ret;
 }
 
@@ -98,7 +98,7 @@ static int MV_to_REG_12_temp_value(signed int _reg)
 {
 	int ret = (_reg * 4096) / (VOLTAGE_FULL_RANGES * R_VAL_TEMP_2);
 
-	bm_trace("[%s] %d => %d\n", __func__, _reg, ret);
+	bm_debug("[%s] %d => %d\n", __func__, _reg, ret);
 	return ret;
 }
 
@@ -116,7 +116,7 @@ static signed int REG_to_MV_value(signed int _reg)
 #endif
 	ret = _reg64;
 
-	bm_trace("[%s] %lld => %d\n",
+	bm_debug("[%s] %lld => %d\n",
 		__func__, _reg64, ret);
 	return ret;
 }
@@ -141,7 +141,7 @@ static signed int MV_to_REG_value(signed int _mv)
 		return ret;
 	}
 
-	bm_trace("[%s] mv=%d,%lld => %d,\n", __func__, _mv, _reg64, ret);
+	bm_debug("[%s] mv=%d,%lld => %d,\n", __func__, _mv, _reg64, ret);
 	return ret;
 }
 
@@ -467,7 +467,7 @@ static signed int fg_get_current_iavg(
 		fg_iavg_ma = fg_iavg_reg * UNIT_FG_IAVG *
 			gauge_dev->fg_cust_data->car_tune_value;
 
-		bm_trace(
+		bm_debug(
 			"[%s] fg_iavg_ma %lld fg_iavg_reg %lld fg_iavg_reg_tmp %lld\n",
 			__func__, fg_iavg_ma, fg_iavg_reg, fg_iavg_reg_tmp);
 
@@ -478,7 +478,7 @@ static signed int fg_get_current_iavg(
 		fg_iavg_ma = div_s64(fg_iavg_ma, 1000000);
 #endif
 
-		bm_trace("[%s] fg_iavg_ma3 %lld\n",
+		bm_debug("[%s] fg_iavg_ma3 %lld\n",
 			__func__, fg_iavg_ma);
 
 		if (gauge_dev->fg_cust_data->r_fg_value != DEFAULT_R_FG) {
@@ -500,20 +500,20 @@ static signed int fg_get_current_iavg(
 		fg_iavg_ma = div_s64(fg_iavg_ma, 100);
 #endif
 
-		bm_trace("[%s] fg_iavg_ma4 %lld\n",
+		bm_debug("[%s] fg_iavg_ma4 %lld\n",
 			__func__, fg_iavg_ma);
 
 		if (sign_bit == 1)
 			fg_iavg_ma = 0 - fg_iavg_ma;
 
-		bm_trace(
+		bm_debug(
 			"[%s] fg_iavg_ma %lld fg_iavg_reg %lld r_fg_value %d 27_16 0x%x 15_00 0x%x\n",
 			__func__, fg_iavg_ma, fg_iavg_reg,
 			gauge_dev->fg_cust_data->r_fg_value,
 			fg_iavg_reg_27_16, fg_iavg_reg_15_00);
 		gauge_dev->fg_hw_info.current_avg = fg_iavg_ma;
 		gauge_dev->fg_hw_info.current_avg_sign = sign_bit;
-		bm_trace("[%s] PMIC_FG_IAVG_VLD == 1\n", __func__);
+		bm_debug("[%s] PMIC_FG_IAVG_VLD == 1\n", __func__);
 	} else {
 		read_fg_hw_info_current_1(gauge_dev);
 		gauge_dev->fg_hw_info.current_avg =
@@ -835,7 +835,7 @@ static int fgauge_read_current(
 		}
 
 	uvalue16 = pmic_get_register_value(PMIC_FG_CURRENT_OUT);
-	bm_trace("[%s] : FG_CURRENT = %x\r\n", __func__, uvalue16);
+	bm_debug("[%s] : FG_CURRENT = %x\r\n", __func__, uvalue16);
 
 	pmic_set_register_value(PMIC_FG_SW_CLEAR, 1);
 	pmic_set_register_value(PMIC_FG_SW_READ_PRE, 0);
@@ -878,26 +878,26 @@ static int fgauge_read_current(
 	dvalue = (unsigned int) Temp_Value;
 
 	if (*fg_is_charging == true)
-		bm_trace("[%s]curr(charging) = %d mA\r\n",
+		bm_debug("[%s]curr(charging) = %d mA\r\n",
 			 __func__, dvalue);
 	else
-		bm_trace("[%s]curr(discharging) = %d mA\r\n",
+		bm_debug("[%s]curr(discharging) = %d mA\r\n",
 			 __func__, dvalue);
 
 		/* Auto adjust value */
 		if (gauge_dev->fg_cust_data->r_fg_value != DEFAULT_R_FG) {
-			bm_trace(
+			bm_debug(
 			"[%s] Auto adjust value due to the Rfg is %d Ori curr=%d\n",
 			__func__, gauge_dev->fg_cust_data->r_fg_value, dvalue);
 
 			dvalue = (dvalue * DEFAULT_R_FG) /
 				gauge_dev->fg_cust_data->r_fg_value;
 
-			bm_trace("[%s] new current=%d\n",
+			bm_debug("[%s] new current=%d\n",
 				__func__, dvalue);
 		}
 
-		bm_trace("[%s] ori current=%d\n", __func__, dvalue);
+		bm_debug("[%s] ori current=%d\n", __func__, dvalue);
 
 		dvalue =
 		((dvalue * gauge_dev->fg_cust_data->car_tune_value) / 1000);
@@ -965,7 +965,7 @@ static int fgauge_get_average_current(
 		fg_iavg_ma = fg_iavg_reg * UNIT_FG_IAVG *
 			gauge_dev->fg_cust_data->car_tune_value;
 
-		bm_trace(
+		bm_debug(
 			"[fg_get_current_iavg] fg_iavg_ma %lld fg_iavg_reg %lld fg_iavg_reg_tmp %lld\n",
 			fg_iavg_ma, fg_iavg_reg, fg_iavg_reg_tmp);
 
@@ -992,14 +992,14 @@ static int fgauge_get_average_current(
 		fg_iavg_ma = div_s64(fg_iavg_ma, 100);
 #endif
 
-		bm_trace("[fg_get_current_iavg] fg_iavg_ma %lld\n",
+		bm_debug("[fg_get_current_iavg] fg_iavg_ma %lld\n",
 			fg_iavg_ma);
 
 
 		if (sign_bit == 1)
 			fg_iavg_ma = 0 - fg_iavg_ma;
 
-		bm_trace(
+		bm_debug(
 			"[fg_get_current_iavg] fg_iavg_ma %lld fg_iavg_reg %lld r_fg_value %d 27_16 0x%x 15_00 0x%x\n",
 			fg_iavg_ma, fg_iavg_reg,
 			gauge_dev->fg_cust_data->r_fg_value,
@@ -1007,7 +1007,7 @@ static int fgauge_get_average_current(
 
 		gauge_dev->fg_hw_info.current_avg = fg_iavg_ma;
 		gauge_dev->fg_hw_info.current_avg_sign = sign_bit;
-		bm_trace("[fg_get_current_iavg] PMIC_FG_IAVG_VLD == 1\n");
+		bm_debug("[fg_get_current_iavg] PMIC_FG_IAVG_VLD == 1\n");
 	} else {
 		read_fg_hw_info_current_1(gauge_dev);
 		gauge_dev->fg_hw_info.current_avg =
@@ -1079,13 +1079,13 @@ static int fgauge_get_coulomb(struct gauge_device *gauge_dev, int *data)
 
 	uvalue32_CAR_MSB = (temp_CAR_31_16 & 0x8000) >> 15;
 
-	bm_trace(
+	bm_debug(
 		"[fgauge_read_columb_internal] temp_CAR_15_0 = 0x%x temp_CAR_31_16 = 0x%x\n",
 		 temp_CAR_15_0, temp_CAR_31_16);
 
-	bm_trace("[fgauge_read_columb_internal] FG_CAR = 0x%x\r\n",
+	bm_debug("[fgauge_read_columb_internal] FG_CAR = 0x%x\r\n",
 		 uvalue32_CAR);
-	bm_trace(
+	bm_debug(
 		 "[fgauge_read_columb_internal] uvalue32_CAR_MSB = 0x%x\r\n",
 		 uvalue32_CAR_MSB);
 
@@ -1146,19 +1146,19 @@ static int fgauge_get_coulomb(struct gauge_device *gauge_dev, int *data)
 	else
 		dvalue_CAR = (signed int) Temp_Value;
 
-	bm_trace("[fgauge_read_columb_internal] dvalue_CAR = %d\r\n",
+	bm_debug("[fgauge_read_columb_internal] dvalue_CAR = %d\r\n",
 		 dvalue_CAR);
 
 /*Auto adjust value*/
 	if (gauge_dev->fg_cust_data->r_fg_value != DEFAULT_R_FG) {
-		bm_trace(
+		bm_debug(
 			 "[fgauge_read_columb_internal] Auto adjust value deu to the Rfg is %d\n Ori CAR=%d",
 			 gauge_dev->fg_cust_data->r_fg_value, dvalue_CAR);
 
 		dvalue_CAR = (dvalue_CAR * DEFAULT_R_FG) /
 			gauge_dev->fg_cust_data->r_fg_value;
 
-		bm_trace("[fgauge_read_columb_internal] new CAR=%d\n",
+		bm_debug("[fgauge_read_columb_internal] new CAR=%d\n",
 			 dvalue_CAR);
 	}
 
@@ -1179,7 +1179,7 @@ static int fgauge_reset_hw(struct gauge_device *gauge_dev)
 {
 	unsigned int ret = 0, check_car = 0;
 
-	bm_trace("[fgauge_hw_reset] : Start, only reset time and car\n");
+	bm_debug("[fgauge_hw_reset] : Start, only reset time and car\n");
 
 	ret = pmic_config_interface(
 		MT6359_FGADC_CON1, 0x0630, 0x0F00, 0x0);
@@ -1192,7 +1192,7 @@ static int fgauge_reset_hw(struct gauge_device *gauge_dev)
 
 	fgauge_get_coulomb(gauge_dev, &check_car);
 
-	bm_trace("[fgauge_hw_reset]:End car=%d,ret=%d\n", check_car, ret);
+	bm_debug("[fgauge_hw_reset]:End car=%d,ret=%d\n", check_car, ret);
 
 	return 0;
 }
@@ -1441,7 +1441,7 @@ int fgauge_set_coulomb_interrupt1_ht(
 	signed int value32_CAR;
 	long long car = car_value;
 
-	bm_trace("%s car=%d\n", __func__, car_value);
+	bm_debug("%s car=%d\n", __func__, car_value);
 	if (car == 0) {
 		gauge_enable_interrupt(FG_BAT1_INT_H_NO, 0);
 		return 0;
@@ -1468,7 +1468,7 @@ int fgauge_set_coulomb_interrupt1_ht(
 	uvalue32_CAR_MSB =
 		(pmic_get_register_value(PMIC_FG_CAR_31_16) & 0x8000) >> 15;
 
-	bm_trace(
+	bm_debug(
 		"[%s] FG_CAR = 0x%x:%d uvalue32_CAR_MSB:0x%x 0x%x 0x%x\r\n",
 		__func__, value32_CAR, value32_CAR, uvalue32_CAR_MSB,
 		temp_CAR_15_0,
@@ -1512,7 +1512,7 @@ int fgauge_set_coulomb_interrupt1_ht(
 
 	upperbound = value32_CAR;
 
-	bm_trace(
+	bm_debug(
 		"[%s] upper = 0x%x:%d diff_car=0x%llx:%lld\r\n",
 		 __func__, upperbound, upperbound, car, car);
 
@@ -1522,11 +1522,11 @@ int fgauge_set_coulomb_interrupt1_ht(
 	upperbound_15_00 = (upperbound & 0xffff);
 
 
-	bm_trace(
+	bm_debug(
 		"[%s] final upper = 0x%x:%d car=0x%llx:%lld\r\n",
 		 __func__, upperbound, upperbound, car, car);
 
-	bm_trace(
+	bm_debug(
 		"[%s] final upper 0x%x 0x%x 0x%x car=0x%llx\n",
 		 __func__,
 		upperbound, upperbound_31_16, upperbound_15_00, car);
@@ -1563,7 +1563,7 @@ int fgauge_set_coulomb_interrupt1_lt(
 	signed int value32_CAR;
 	long long car = car_value;
 
-	bm_trace("%s car=%d\n", __func__, car_value);
+	bm_debug("%s car=%d\n", __func__, car_value);
 	if (car == 0) {
 		pmic_enable_interrupt(FG_BAT1_INT_L_NO, 0, "GM30");
 		return 0;
@@ -1590,7 +1590,7 @@ int fgauge_set_coulomb_interrupt1_lt(
 	uvalue32_CAR_MSB =
 		(pmic_get_register_value(PMIC_FG_CAR_31_16) & 0x8000) >> 15;
 
-	bm_trace(
+	bm_debug(
 		"[%s] FG_CAR = 0x%x:%d uvalue32_CAR_MSB:0x%x 0x%x 0x%x\r\n",
 		__func__,
 		value32_CAR, value32_CAR, uvalue32_CAR_MSB,
@@ -1638,7 +1638,7 @@ int fgauge_set_coulomb_interrupt1_lt(
 
 	lowbound = value32_CAR;
 
-	bm_trace(
+	bm_debug(
 		"[%s]low=0x%x:%d diff_car=0x%llx:%lld\r\n",
 		 __func__, lowbound, lowbound, car, car);
 
@@ -1647,11 +1647,11 @@ int fgauge_set_coulomb_interrupt1_lt(
 	lowbound_31_16 = (lowbound & 0xffff0000) >> 16;
 	lowbound_15_00 = (lowbound & 0xffff);
 
-	bm_trace(
+	bm_debug(
 		"[%s]final low=0x%x:%d car=0x%llx:%lld\r\n",
 		 __func__, lowbound, lowbound, car, car);
 
-	bm_trace(
+	bm_debug(
 		"[%s] final low 0x%x 0x%x 0x%x car=0x%llx\n",
 		 __func__, lowbound, lowbound_31_16, lowbound_15_00, car);
 
@@ -1698,7 +1698,7 @@ static int fgauge_get_ptim_current(
 		/*unsigned int ret = 0;*/
 
 		uvalue16 = pmic_get_register_value(PMIC_FG_R_CURR);
-		bm_trace("[%s] : FG_CURRENT = %x\r\n",
+		bm_debug("[%s] : FG_CURRENT = %x\r\n",
 			 __func__, uvalue16);
 
 		/*calculate the real world data    */
@@ -1726,28 +1726,28 @@ static int fgauge_get_ptim_current(
 		dvalue = (unsigned int) Temp_Value;
 
 		if (*is_charging == true)
-			bm_trace(
+			bm_debug(
 			"[fgauge_read_IM_current]curr(charging)=%dmA\r\n",
 			dvalue);
 		else
-			bm_trace(
+			bm_debug(
 			"[fgauge_read_IM_current]curr(discharging)=%dmA\r\n",
 			dvalue);
 
 		/* Auto adjust value */
 		if (gauge_dev->fg_cust_data->r_fg_value != DEFAULT_R_FG) {
-			bm_trace(
+			bm_debug(
 			"[fgauge_read_IM_current] Auto adjust value due to the Rfg is %d\n Ori curr=%d, ",
 			gauge_dev->fg_cust_data->r_fg_value, dvalue);
 
 			dvalue = (dvalue * DEFAULT_R_FG) /
 				gauge_dev->fg_cust_data->r_fg_value;
 
-			bm_trace("[fgauge_read_IM_current] new current=%d\n",
+			bm_debug("[fgauge_read_IM_current] new current=%d\n",
 			dvalue);
 		}
 
-		bm_trace("[fgauge_read_IM_current] ori current=%d\n", dvalue);
+		bm_debug("[fgauge_read_IM_current] ori current=%d\n", dvalue);
 
 		dvalue = ((dvalue *
 			gauge_dev->fg_cust_data->car_tune_value) / 1000);
@@ -1791,17 +1791,17 @@ static int fgauge_get_zcv_current(
 
 	/* Auto adjust value */
 	if (gauge_dev->fg_cust_data->r_fg_value != DEFAULT_R_FG) {
-		bm_trace(
+		bm_debug(
 		"[fgauge_read_current] Auto adjust value due to the Rfg is %d\n Ori curr=%d",
 		gauge_dev->fg_cust_data->r_fg_value, dvalue);
 
 		dvalue = (dvalue * DEFAULT_R_FG) /
 		gauge_dev->fg_cust_data->r_fg_value;
 
-		bm_trace("[fgauge_read_current] new current=%d\n", dvalue);
+		bm_debug("[fgauge_read_current] new current=%d\n", dvalue);
 	}
 
-	bm_trace("[fgauge_read_current] ori current=%d\n", dvalue);
+	bm_debug("[fgauge_read_current] ori current=%d\n", dvalue);
 
 	dvalue = ((dvalue * gauge_dev->fg_cust_data->car_tune_value) / 1000);
 
@@ -2308,7 +2308,7 @@ int fgauge_get_time(struct gauge_device *gauge_dev, unsigned int *ptime)
 #endif
 	ret_time = time;
 
-	bm_trace(
+	bm_debug(
 		 "[%s] low:0x%x high:0x%x rtime:0x%llx 0x%x!\r\n",
 		 __func__, time_15_00, time_29_16, time, ret_time);
 
@@ -2529,7 +2529,7 @@ int fgauge_get_hw_status(
 	/* Iavg */
 	read_fg_hw_info_Iavg(gauge_dev, &is_iavg_valid);
 	if ((is_iavg_valid == 1) && (gauge_status->iavg_intr_flag == 0)) {
-		bm_trace("[read_fg_hw_info]set first fg_set_iavg_intr %d %d\n",
+		bm_debug("[read_fg_hw_info]set first fg_set_iavg_intr %d %d\n",
 			is_iavg_valid, gauge_status->iavg_intr_flag);
 		gauge_status->iavg_intr_flag = 1;
 		iavg_th = gauge_dev->fg_cust_data->diff_iavg_th;
@@ -2538,11 +2538,11 @@ int fgauge_get_hw_status(
 		gauge_status->iavg_intr_flag = 0;
 		gauge_enable_interrupt(FG_IAVG_H_NO, 0);
 		gauge_enable_interrupt(FG_IAVG_L_NO, 0);
-		bm_trace(
+		bm_debug(
 			"[read_fg_hw_info] doublecheck first fg_set_iavg_intr %d %d\n",
 			is_iavg_valid, gauge_status->iavg_intr_flag);
 	}
-	bm_trace("[read_fg_hw_info] thirdcheck first fg_set_iavg_intr %d %d\n",
+	bm_debug("[read_fg_hw_info] thirdcheck first fg_set_iavg_intr %d %d\n",
 		is_iavg_valid, gauge_status->iavg_intr_flag);
 
 	/* Ncar */
@@ -2939,7 +2939,7 @@ static int fgauge_set_rtc_ui_soc(
 	/* set spare3 0x7f */
 	set_rtc_spare_fg_value(new_spare3_reg);
 
-	bm_notice("[fg_set_rtc_ui_soc] rtc_ui_soc %d spare3_reg 0x%x new_spare3_reg 0x%x\n",
+	bm_debug("[fg_set_rtc_ui_soc] rtc_ui_soc %d spare3_reg 0x%x new_spare3_reg 0x%x\n",
 		rtc_ui_soc, spare3_reg, new_spare3_reg);
 
 	return 0;
@@ -2953,7 +2953,7 @@ static int fgauge_get_rtc_ui_soc(struct gauge_device *gauge_dev, int *ui_soc)
 	rtc_ui_soc = (spare3_reg & 0x7f);
 
 	*ui_soc = rtc_ui_soc;
-	bm_notice("[%s] rtc_ui_soc %d spare3_reg 0x%x\n",
+	bm_debug("[%s] rtc_ui_soc %d spare3_reg 0x%x\n",
 		__func__, rtc_ui_soc, spare3_reg);
 
 	return 0;
@@ -2965,7 +2965,7 @@ int fgauge_is_rtc_invalid(struct gauge_device *gauge_dev, int *invalid)
 	/* because it has been reset by fg_set_fg_reset_rtc_status() */
 
 	*invalid = rtc_invalid;
-	bm_notice("[fg_get_rtc_invalid] rtc_invalid %d\n", rtc_invalid);
+	bm_err("[fg_get_rtc_invalid] rtc_invalid %d\n", rtc_invalid);
 
 	return 0;
 }
diff --git a/drivers/misc/mediatek/pmic/mt6359/v1/pmic_auxadc.c b/drivers/misc/mediatek/pmic/mt6359/v1/pmic_auxadc.c
index 1d5151eda..f027791da 100644
--- a/drivers/misc/mediatek/pmic/mt6359/v1/pmic_auxadc.c
+++ b/drivers/misc/mediatek/pmic/mt6359/v1/pmic_auxadc.c
@@ -219,7 +219,7 @@ static int wk_bat_temp_dbg(int bat_temp_prev, int bat_temp)
 			arr_bat_temp[i] =
 				auxadc_priv_read_channel(pmic_auxadc_dev,
 							 AUXADC_BAT_TEMP);
-			pr_notice("[CH3_DBG] %d,%d\n",
+			pr_debug("[CH3_DBG] %d,%d\n",
 				  vbat, arr_bat_temp[i]);
 		}
 		bat_temp_new = bat_temp_filter(arr_bat_temp, 5);
@@ -491,7 +491,7 @@ int pmic_get_auxadc_value(int list)
 #endif
 		if (is_charging == 0)
 			bat_cur = 0 - bat_cur;
-		pr_notice("[CH3_DBG] bat_cur = %d\n", bat_cur);
+		pr_debug("[CH3_DBG] bat_cur = %d\n", bat_cur);
 	}
 	if (list == AUXADC_LIST_HPOFS_CAL) {
 		ret = iio_read_channel_raw(
diff --git a/drivers/misc/mediatek/pmic/mt6359/v1/pmic_irq.c b/drivers/misc/mediatek/pmic/mt6359/v1/pmic_irq.c
index 7510a1378..6ff6d0683 100644
--- a/drivers/misc/mediatek/pmic/mt6359/v1/pmic_irq.c
+++ b/drivers/misc/mediatek/pmic/mt6359/v1/pmic_irq.c
@@ -349,8 +349,8 @@ void register_all_oc_interrupts(void)
 static void vio18_oc_int_handler(void)
 {
 	static unsigned int times;
-	int len = 0;
 #if defined(CONFIG_MTK_AEE_FEATURE)
+	int len = 0;
 	char oc_str[30] = "";
 #endif
 	pr_info("[%s]\n", __func__);
diff --git a/drivers/misc/mediatek/pmic/mt6360/pmu/mt6360_pmu_chg_begonia.c b/drivers/misc/mediatek/pmic/mt6360/pmu/mt6360_pmu_chg_begonia.c
index 9e4babcc4..0ef33a602 100644
--- a/drivers/misc/mediatek/pmic/mt6360/pmu/mt6360_pmu_chg_begonia.c
+++ b/drivers/misc/mediatek/pmic/mt6360/pmu/mt6360_pmu_chg_begonia.c
@@ -385,7 +385,7 @@ static int mt6360_psy_online_changed(struct mt6360_pmu_chg_info *mpci)
 	if (ret < 0)
 		dev_err(mpci->dev, "%s: psy online fail(%d)\n", __func__, ret);
 	else
-		dev_info(mpci->dev,
+		dev_dbg(mpci->dev,
 			 "%s: pwr_rdy = %d\n",  __func__, propval.intval);
 #endif
 	return ret;
@@ -405,7 +405,7 @@ static int mt6360_psy_chg_type_changed(struct mt6360_pmu_chg_info *mpci)
 		dev_err(mpci->dev,
 			"%s: psy type failed, ret = %d\n", __func__, ret);
 	else
-		dev_info(mpci->dev,
+		dev_dbg(mpci->dev,
 			 "%s: chg_type = %d\n", __func__, mpci->chg_type);
 #endif
 	return ret;
@@ -414,7 +414,7 @@ static int mt6360_psy_chg_type_changed(struct mt6360_pmu_chg_info *mpci)
 
 static int mt6360_set_usbsw_state(struct mt6360_pmu_chg_info *mpci, int state)
 {
-	dev_info(mpci->dev, "%s: state = %d\n", __func__, state);
+	dev_dbg(mpci->dev, "%s: state = %d\n", __func__, state);
 
 	/* Switch D+D- to AP/MT6360 */
 	if (state == MT6360_USBSW_CHG)
@@ -429,7 +429,7 @@ static int mt6360_set_usbsw_state(struct mt6360_pmu_chg_info *mpci, int state)
 static int __maybe_unused mt6360_enable_dcd_tout(
 				      struct mt6360_pmu_chg_info *mpci, bool en)
 {
-	dev_info(mpci->dev, "%s en = %d\n", __func__, en);
+	dev_dbg(mpci->dev, "%s en = %d\n", __func__, en);
 	return (en ? mt6360_pmu_reg_set_bits : mt6360_pmu_reg_clr_bits)
 		(mpci->mpi, MT6360_PMU_DEVICE_TYPE, MT6360_MASK_DCDTOUTEN);
 }
@@ -462,7 +462,7 @@ static int __mt6360_enable_usbchgen(struct mt6360_pmu_chg_info *mpci, bool en)
 	bool dcd_en = false;
 #endif /* CONFIG_MT6360_DCDTOUT_SUPPORT */
 
-	dev_info(mpci->dev, "%s: en = %d\n", __func__, en);
+	dev_dbg(mpci->dev, "%s: en = %d\n", __func__, en);
 	if (en) {
 #ifndef CONFIG_MT6360_DCDTOUT_SUPPORT
 		ret = mt6360_is_dcd_tout_enable(mpci, &dcd_en);
@@ -473,7 +473,7 @@ static int __mt6360_enable_usbchgen(struct mt6360_pmu_chg_info *mpci, bool en)
 		for (i = 0; i < max_wait_cnt; i++) {
 			if (is_usb_rdy())
 				break;
-			dev_info(mpci->dev, "%s: CDP block\n", __func__);
+			dev_dbg(mpci->dev, "%s: CDP block\n", __func__);
 #ifndef CONFIG_TCPC_CLASS
 			/* Check vbus */
 			ret = mt6360_get_chrdet_ext_stat(mpci, &pwr_rdy);
@@ -482,15 +482,15 @@ static int __mt6360_enable_usbchgen(struct mt6360_pmu_chg_info *mpci, bool en)
 					 __func__, ret);
 				return ret;
 			}
-			dev_info(mpci->dev, "%s: pwr_rdy = %d\n", __func__,
+			dev_dbg(mpci->dev, "%s: pwr_rdy = %d\n", __func__,
 				 pwr_rdy);
 			if (!pwr_rdy) {
-				dev_info(mpci->dev, "%s: plug out\n", __func__);
+				dev_dbg(mpci->dev, "%s: plug out\n", __func__);
 				return ret;
 			}
 #else
 			if (!(mpci->tcpc_attach)) {
-				dev_info(mpci->dev,
+				dev_dbg(mpci->dev,
 					 "%s: plug out\n", __func__);
 				return 0;
 			}
@@ -500,7 +500,7 @@ static int __mt6360_enable_usbchgen(struct mt6360_pmu_chg_info *mpci, bool en)
 		if (i == max_wait_cnt)
 			dev_err(mpci->dev, "%s: CDP timeout\n", __func__);
 		else
-			dev_info(mpci->dev, "%s: CDP free\n", __func__);
+			dev_dbg(mpci->dev, "%s: CDP free\n", __func__);
 	}
 	mt6360_set_usbsw_state(mpci, usbsw);
 	ret = mt6360_pmu_reg_update_bits(mpci->mpi, MT6360_PMU_DEVICE_TYPE,
@@ -533,13 +533,13 @@ static int mt6360_chgdet_pre_process(struct mt6360_pmu_chg_info *mpci,
 	}
 	if (attach && is_meta_mode()) {
 		/* Skip charger type detection to speed up meta boot.*/
-		dev_notice(mpci->dev, "%s: force Standard USB Host in meta\n",
+		dev_dbg(mpci->dev, "%s: force Standard USB Host in meta\n",
 			   __func__);
 		mpci->pwr_rdy = true;
 		mpci->chg_type = STANDARD_HOST;
 		ret = mt6360_psy_online_changed(mpci);
 		if (ret < 0)
-			dev_notice(mpci->dev,
+			dev_err(mpci->dev,
 				   "%s: set psy online fail\n", __func__);
 		return mt6360_psy_chg_type_changed(mpci);
 	}
@@ -557,7 +557,7 @@ static int mt6360_chgdet_post_process(struct mt6360_pmu_chg_info *mpci)
 #else
 	attach = mpci->pwr_rdy;
 #endif /* CONFIG_TCPC_CLASS */
-	dev_info(mpci->dev, "%s: attach = %d\n", __func__, attach);
+	dev_dbg(mpci->dev, "%s: attach = %d\n", __func__, attach);
 	/* Plug out during BC12 */
 	if (!attach) {
 		mpci->chg_type = CHARGER_UNKNOWN;
@@ -570,7 +570,7 @@ static int mt6360_chgdet_post_process(struct mt6360_pmu_chg_info *mpci)
 	usb_status = (ret & MT6360_MASK_USB_STATUS) >> MT6360_SHFT_USB_STATUS;
 	switch (usb_status) {
 	case MT6360_CHG_TYPE_UNDER_GOING:
-		dev_info(mpci->dev, "%s: under going...\n", __func__);
+		dev_dbg(mpci->dev, "%s: under going...\n", __func__);
 		return ret;
 	case MT6360_CHG_TYPE_SDP:
 		mpci->chg_type = STANDARD_HOST;
@@ -589,7 +589,7 @@ out:
 	if (!attach) {
 		ret = __mt6360_enable_usbchgen(mpci, false);
 		if (ret < 0)
-			dev_notice(mpci->dev, "%s: disable chgdet fail\n",
+			dev_err(mpci->dev, "%s: disable chgdet fail\n",
 				   __func__);
 	} else if (mpci->chg_type != STANDARD_CHARGER)
 		mt6360_set_usbsw_state(mpci, MT6360_USBSW_USB);
@@ -636,7 +636,7 @@ static inline int mt6360_read_zcv(struct mt6360_pmu_chg_info *mpci)
 		return ret;
 	}
 	mpci->zcv = 1250 * (zcv_data[0] * 256 + zcv_data[1]);
-	dev_info(mpci->dev, "%s: zcv = (0x%02X, 0x%02X, %dmV)\n",
+	dev_dbg(mpci->dev, "%s: zcv = (0x%02X, 0x%02X, %dmV)\n",
 		 __func__, zcv_data[0], zcv_data[1], mpci->zcv/1000);
 	/* Disable ZCV */
 	ret = mt6360_pmu_reg_clr_bits(mpci->mpi, MT6360_PMU_ADC_CONFIG,
@@ -661,7 +661,7 @@ static int __mt6360_set_ichg(struct mt6360_pmu_chg_info *mpci, u32 uA)
 					 MT6360_MASK_ICHG,
 					 data << MT6360_SHFT_ICHG);
 	if (ret < 0)
-		dev_notice(mpci->dev, "%s: fail\n", __func__);
+		dev_err(mpci->dev, "%s: fail\n", __func__);
 	else
 		mpci->ichg = uA;
 	return ret;
@@ -734,7 +734,7 @@ static int mt6360_enable(struct charger_device *chg_dev, bool en)
 	/* Workaround for vsys overshoot */
 	mutex_lock(&mpci->ichg_lock);
 	if (mpci->ichg < 500) {
-		dev_info(mpci->dev,
+		dev_dbg(mpci->dev,
 			 "%s: ichg < 500mA, bypass vsys wkard\n", __func__);
 		goto out;
 	}
@@ -747,7 +747,7 @@ static int mt6360_enable(struct charger_device *chg_dev, bool en)
 						 MT6360_MASK_ICHG,
 						 0x04 << MT6360_SHFT_ICHG);
 		if (ret < 0) {
-			dev_notice(mpci->dev,
+			dev_err(mpci->dev,
 				   "%s: set ichg fail\n", __func__);
 			goto vsys_wkard_fail;
 		}
@@ -756,7 +756,7 @@ static int mt6360_enable(struct charger_device *chg_dev, bool en)
 		if (mpci->ichg == mpci->ichg_dis_chg) {
 			ret = __mt6360_set_ichg(mpci, mpci->ichg);
 			if (ret < 0) {
-				dev_notice(mpci->dev,
+				dev_err(mpci->dev,
 					   "%s: set ichg fail\n", __func__);
 				goto out;
 			}
@@ -768,7 +768,7 @@ out:
 					 MT6360_PMU_CHG_CTRL2,
 					 MT6360_MASK_CHG_EN, en ? 0xff : 0);
 	if (ret < 0)
-		dev_notice(mpci->dev, "%s: fail, en = %d\n", __func__, en);
+		dev_err(mpci->dev, "%s: fail, en = %d\n", __func__, en);
 vsys_wkard_fail:
 	mutex_unlock(&mpci->ichg_lock);
 	return ret;
@@ -966,7 +966,7 @@ static int mt6360_enable_te(struct charger_device *chg_dev, bool en)
 	struct mt6360_pmu_chg_info *mpci = charger_get_data(chg_dev);
 	struct mt6360_chg_platform_data *pdata = dev_get_platdata(mpci->dev);
 
-	dev_info(mpci->dev, "%s: en = %d\n", __func__, en);
+	dev_dbg(mpci->dev, "%s: en = %d\n", __func__, en);
 	if (!pdata->en_te)
 		return 0;
 	return mt6360_pmu_reg_update_bits(mpci->mpi, MT6360_PMU_CHG_CTRL2,
@@ -979,7 +979,7 @@ static int mt6360_enable_pump_express(struct mt6360_pmu_chg_info *mpci,
 	long timeout, pe_timeout = pe20 ? 1400 : 2800;
 	int ret = 0;
 
-	dev_info(mpci->dev, "%s\n", __func__);
+	dev_dbg(mpci->dev, "%s\n", __func__);
 	ret = mt6360_set_aicr(mpci->chg_dev, 800000);
 	if (ret < 0)
 		return ret;
@@ -1127,7 +1127,7 @@ static int mt6360_enable_cable_drop_comp(struct charger_device *chg_dev,
 	struct mt6360_pmu_chg_info *mpci = charger_get_data(chg_dev);
 	int ret = 0;
 
-	dev_info(mpci->dev, "%s: en = %d\n", __func__, en);
+	dev_dbg(mpci->dev, "%s: en = %d\n", __func__, en);
 	if (en)
 		return ret;
 
@@ -1222,7 +1222,7 @@ static int mt6360_run_aicc(struct charger_device *chg_dev, u32 *uA)
 	/* Auto run aicc */
 	if (!pdata->aicc_once) {
 		if (!try_wait_for_completion(&mpci->aicc_done)) {
-			dev_info(mpci->dev, "%s: aicc is not act\n", __func__);
+			dev_dbg(mpci->dev, "%s: aicc is not act\n", __func__);
 			return 0;
 		}
 
@@ -1270,7 +1270,7 @@ static int mt6360_run_aicc(struct charger_device *chg_dev, u32 *uA)
 	if (!pdata->post_aicc)
 		goto skip_post_aicc;
 
-	dev_info(mpci->dev, "%s: aicc pre val = %d\n", __func__, aicc_val);
+	dev_dbg(mpci->dev, "%s: aicc pre val = %d\n", __func__, aicc_val);
 	ret = mt6360_get_aicr(chg_dev, &aicr_val);
 	if (ret < 0) {
 		dev_err(mpci->dev, "%s: get aicr fail\n", __func__);
@@ -1295,7 +1295,7 @@ static int mt6360_run_aicc(struct charger_device *chg_dev, u32 *uA)
 		dev_err(mpci->dev, "%s: set aicr fail\n", __func__);
 		goto out;
 	}
-	dev_info(mpci->dev, "%s: aicc post val = %d\n", __func__, aicc_val);
+	dev_dbg(mpci->dev, "%s: aicc post val = %d\n", __func__, aicc_val);
 skip_post_aicc:
 	*uA = aicc_val;
 out:
@@ -1446,10 +1446,10 @@ static int mt6360_enable_chg_type_det(struct charger_device *chg_dev, bool en)
 #if defined(CONFIG_MT6360_PMU_CHARGER_TYPE_DETECT) && defined(CONFIG_TCPC_CLASS)
 	struct mt6360_pmu_chg_info *mpci = charger_get_data(chg_dev);
 
-	dev_info(mpci->dev, "%s\n", __func__);
+	dev_dbg(mpci->dev, "%s\n", __func__);
 	mutex_lock(&mpci->chgdet_lock);
 	if (mpci->tcpc_attach == en) {
-		dev_info(mpci->dev, "%s attach(%d) is the same\n",
+		dev_dbg(mpci->dev, "%s attach(%d) is the same\n",
 			 __func__, mpci->tcpc_attach);
 		goto out;
 	}
@@ -1498,7 +1498,7 @@ static int mt6360_get_adc(struct charger_device *chg_dev, u32 chan,
 	}
 	ret = iio_read_channel_processed(mpci->channels[channel], min);
 	if (ret < 0) {
-		dev_info(mpci->dev, "%s: fail(%d)\n", __func__, ret);
+		dev_dbg(mpci->dev, "%s: fail(%d)\n", __func__, ret);
 		return ret;
 	}
 	*max = *min;
@@ -1553,7 +1553,7 @@ static int mt6360_get_tchg(struct charger_device *chg_dev,
 		mpci->tchg = temp_jc;
 	mutex_unlock(&mpci->tchg_lock);
 	*tchg_min = *tchg_max = temp_jc;
-	dev_info(mpci->dev, "%s: tchg = %d\n", __func__, temp_jc);
+	dev_dbg(mpci->dev, "%s: tchg = %d\n", __func__, temp_jc);
 	return 0;
 }
 
@@ -1583,7 +1583,7 @@ static int mt6360_safety_check(struct charger_device *chg_dev, u32 polling_ieoc)
 		eoc_cnt = 0;
 	/* If ibat is less than polling_ieoc for 3 times, trigger EOC event */
 	if (eoc_cnt == 3) {
-		dev_info(mpci->dev, "%s: polling_ieoc = %d, ibat = %d\n",
+		dev_dbg(mpci->dev, "%s: polling_ieoc = %d, ibat = %d\n",
 			 __func__, polling_ieoc, ibat);
 		charger_dev_notify(mpci->chg_dev, CHARGER_DEV_NOTIFY_EOC);
 		eoc_cnt = 0;
@@ -1639,7 +1639,7 @@ static int mt6360_get_zcv(struct charger_device *chg_dev, u32 *uV)
 {
 	struct mt6360_pmu_chg_info *mpci = charger_get_data(chg_dev);
 
-	dev_info(mpci->dev, "%s: zcv = %dmV\n", __func__, mpci->zcv / 1000);
+	dev_dbg(mpci->dev, "%s: zcv = %dmV\n", __func__, mpci->zcv / 1000);
 	*uV = mpci->zcv;
 	return 0;
 }
@@ -1663,7 +1663,7 @@ static int mt6360_dump_registers(struct charger_device *chg_dev)
 	ret |= mt6360_get_charging_status(mpci, &chg_stat);
 	ret |= mt6360_is_charger_enabled(mpci, &chg_en);
 	if (ret < 0) {
-		dev_notice(mpci->dev, "%s: parse chg setting fail\n", __func__);
+		dev_err(mpci->dev, "%s: parse chg setting fail\n", __func__);
 		return ret;
 	}
 	for (i = 0; i < MT6360_ADC_MAX; i++) {
@@ -1688,11 +1688,11 @@ static int mt6360_dump_registers(struct charger_device *chg_dev)
 					2, chg_ctrl);
 	if (ret < 0)
 		return ret;
-	dev_info(mpci->dev,
+	dev_dbg(mpci->dev,
 		 "%s: ICHG = %dmA, AICR = %dmA, MIVR = %dmV, IEOC = %dmA, CV = %dmV\n",
 		 __func__, ichg / 1000, aicr / 1000, mivr / 1000, ieoc / 1000,
 		 cv / 1000);
-	dev_info(mpci->dev,
+	dev_dbg(mpci->dev,
 		 "%s: VBUS = %dmV, IBUS = %dmA, VSYS = %dmV, VBAT = %dmV, IBAT = %dmA\n",
 		 __func__,
 		 adc_vals[MT6360_ADC_VBUSDIV5] / 1000,
@@ -1700,9 +1700,9 @@ static int mt6360_dump_registers(struct charger_device *chg_dev)
 		 adc_vals[MT6360_ADC_VSYS] / 1000,
 		 adc_vals[MT6360_ADC_VBAT] / 1000,
 		 adc_vals[MT6360_ADC_IBAT] / 1000);
-	dev_info(mpci->dev, "%s: CHG_EN = %d, CHG_STATUS = %s, CHG_STAT1 = 0x%02X\n",
+	dev_dbg(mpci->dev, "%s: CHG_EN = %d, CHG_STATUS = %s, CHG_STAT1 = 0x%02X\n",
 		 __func__, chg_en, mt6360_chg_status_name[chg_stat], chg_stat1);
-	dev_info(mpci->dev, "%s: CHG_CTRL1 = 0x%02X, CHG_CTRL2 = 0x%02X\n",
+	dev_dbg(mpci->dev, "%s: CHG_CTRL1 = 0x%02X, CHG_CTRL2 = 0x%02X\n",
 		 __func__, chg_ctrl[0], chg_ctrl[1]);
 	return 0;
 }
@@ -1950,7 +1950,7 @@ static irqreturn_t mt6360_pmu_pwr_rdy_evt_handler(int irq, void *data)
 	if (ret < 0)
 		return ret;
 	pwr_rdy = (ret & MT6360_MASK_PWR_RDY_EVT);
-	dev_info(mpci->dev, "%s: pwr_rdy = %d\n", __func__, pwr_rdy);
+	dev_dbg(mpci->dev, "%s: pwr_rdy = %d\n", __func__, pwr_rdy);
 #endif
 	return IRQ_HANDLED;
 }
@@ -2000,7 +2000,7 @@ static irqreturn_t mt6360_pmu_chg_vbusov_evt_handler(int irq, void *data)
 		goto out;
 	vbusov_stat = (ret & BIT(7));
 	noti->vbusov_stat = vbusov_stat;
-	dev_info(mpci->dev, "%s: stat = %d\n", __func__, vbusov_stat);
+	dev_dbg(mpci->dev, "%s: stat = %d\n", __func__, vbusov_stat);
 out:
 	return IRQ_HANDLED;
 }
@@ -2009,7 +2009,7 @@ static irqreturn_t mt6360_pmu_wd_pmu_det_handler(int irq, void *data)
 {
 	struct mt6360_pmu_chg_info *mpci = data;
 
-	dev_info(mpci->dev, "%s\n", __func__);
+	dev_dbg(mpci->dev, "%s\n", __func__);
 	return IRQ_HANDLED;
 }
 
@@ -2017,7 +2017,7 @@ static irqreturn_t mt6360_pmu_wd_pmu_done_handler(int irq, void *data)
 {
 	struct mt6360_pmu_chg_info *mpci = data;
 
-	dev_info(mpci->dev, "%s\n", __func__);
+	dev_dbg(mpci->dev, "%s\n", __func__);
 	return IRQ_HANDLED;
 }
 
@@ -2030,7 +2030,7 @@ static irqreturn_t mt6360_pmu_chg_tmri_handler(int irq, void *data)
 	ret = mt6360_pmu_reg_read(mpci->mpi, MT6360_PMU_CHG_STAT4);
 	if (ret < 0)
 		return IRQ_HANDLED;
-	dev_info(mpci->dev, "%s: chg_stat4 = 0x%02x\n", __func__, ret);
+	dev_dbg(mpci->dev, "%s: chg_stat4 = 0x%02x\n", __func__, ret);
 	if (!(ret & MT6360_MASK_CHG_TMRI))
 		return IRQ_HANDLED;
 	charger_dev_notify(mpci->chg_dev, CHARGER_DEV_NOTIFY_SAFETY_TIMEOUT);
@@ -2139,7 +2139,7 @@ static irqreturn_t mt6360_pmu_pumpx_donei_handler(int irq, void *data)
 {
 	struct mt6360_pmu_chg_info *mpci = data;
 
-	dev_info(mpci->dev, "%s\n", __func__);
+	dev_dbg(mpci->dev, "%s\n", __func__);
 	atomic_set(&mpci->pe_complete, 0);
 	complete(&mpci->pumpx_done);
 	return IRQ_HANDLED;
@@ -2227,7 +2227,7 @@ static irqreturn_t mt6360_pmu_chrdet_ext_evt_handler(int irq, void *data)
 	bool pwr_rdy = false;
 
 	ret = mt6360_get_chrdet_ext_stat(mpci, &pwr_rdy);
-	dev_info(mpci->dev, "%s: pwr_rdy = %d\n", __func__, pwr_rdy);
+	dev_dbg(mpci->dev, "%s: pwr_rdy = %d\n", __func__, pwr_rdy);
 	if (ret < 0)
 		goto out;
 	if (mpci->pwr_rdy == pwr_rdy)
@@ -2242,7 +2242,7 @@ static irqreturn_t mt6360_pmu_chrdet_ext_evt_handler(int irq, void *data)
 #endif /* CONFIG_MT6360_PMU_CHARGER_TYPE_DETECT */
 	if (atomic_read(&mpci->pe_complete) && pwr_rdy == true &&
 	    mpci->mpi->chip_rev <= 0x02) {
-		dev_info(mpci->dev, "%s: re-trigger pe20 pattern\n", __func__);
+		dev_dbg(mpci->dev, "%s: re-trigger pe20 pattern\n", __func__);
 		queue_work(mpci->pe_wq, &mpci->pe_work);
 	}
 out:
@@ -2378,7 +2378,7 @@ static int mt6360_chg_mivr_task_threadfn(void *data)
 	u32 ibus;
 	int ret;
 
-	dev_info(mpci->dev, "%s ++\n", __func__);
+	dev_dbg(mpci->dev, "%s ++\n", __func__);
 	while (!kthread_should_stop()) {
 		atomic_set(&mpci->mivr_cnt, 0);
 		mt6360_pmu_chg_irq_enable("chg_mivr_evt", 1);
@@ -2413,7 +2413,7 @@ static int mt6360_chg_mivr_task_threadfn(void *data)
 loop_cont:
 		pm_relax(mpci->dev);
 	}
-	dev_info(mpci->dev, "%s --\n", __func__);
+	dev_dbg(mpci->dev, "%s --\n", __func__);
 	return 0;
 }
 
@@ -2548,7 +2548,7 @@ static int mt6360_chg_init_setting(struct mt6360_pmu_chg_info *mpci)
 	int ret = 0;
 	u32 boot_mode = get_boot_mode();
 
-	dev_info(mpci->dev, "%s\n", __func__);
+	dev_dbg(mpci->dev, "%s\n", __func__);
 
 	ret = mt6360_pmu_reg_read(mpci->mpi, MT6360_PMU_CHRDET_STAT);
 	if (ret >= 0)
@@ -2573,7 +2573,7 @@ static int mt6360_chg_init_setting(struct mt6360_pmu_chg_info *mpci)
 						 MT6360_PMU_CHG_CTRL3,
 						 MT6360_MASK_AICR,
 						 0x02 << MT6360_SHFT_AICR);
-		dev_info(mpci->dev, "%s: set aicr to 200mA in meta mode\n",
+		dev_dbg(mpci->dev, "%s: set aicr to 200mA in meta mode\n",
 			__func__);
 	}
 	/* disable wdt reduce 1mA power consumption */
@@ -2623,7 +2623,7 @@ static int mt6360_chg_init_setting(struct mt6360_pmu_chg_info *mpci)
 	/* Disable DCD */
 	ret = mt6360_enable_dcd_tout(mpci, false);
 	if (ret < 0)
-		dev_notice(mpci->dev, "%s disable dcd fail\n", __func__);
+		dev_err(mpci->dev, "%s disable dcd fail\n", __func__);
 #endif
 	/* Check BATSYSUV occurred last time boot-on */
 	ret = mt6360_pmu_reg_read(mpci->mpi, MT6360_PMU_CHG_STAT);
@@ -2662,7 +2662,7 @@ static ssize_t shipping_mode_store(struct device *dev,
 	int ret = 0;
 
 	if (kstrtoint(buf, 10, &tmp) < 0) {
-		dev_notice(dev, "parsing number fail\n");
+		dev_err(dev, "parsing number fail\n");
 		return -EINVAL;
 	}
 	if (tmp != 5526789)
@@ -2688,14 +2688,14 @@ void mt6360_recv_batoc_callback(BATTERY_OC_LEVEL tag)
 					"%s: set shipping mode fail\n",
 					__func__);
 			else
-				dev_info(g_mpci->dev,
+				dev_dbg(g_mpci->dev,
 					 "%s: set shipping mode done\n",
 					 __func__);
 		}
 		mdelay(8);
 		cnt++;
 	}
-	dev_info(g_mpci->dev, "%s exit, cnt = %d, FG_CUR_H = %d\n",
+	dev_dbg(g_mpci->dev, "%s exit, cnt = %d, FG_CUR_H = %d\n",
 		 __func__, cnt,
 		 pmic_get_register_value(PMIC_RG_INT_STATUS_FG_CUR_H));
 }
@@ -2708,7 +2708,7 @@ static int mt6360_pmu_chg_probe(struct platform_device *pdev)
 	bool use_dt = pdev->dev.of_node;
 	int i, ret = 0;
 
-	dev_info(&pdev->dev, "%s\n", __func__);
+	dev_dbg(&pdev->dev, "%s\n", __func__);
 	if (use_dt) {
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 		if (!pdata)
@@ -2806,7 +2806,7 @@ static int mt6360_pmu_chg_probe(struct platform_device *pdev)
 	}
 	ret = device_create_file(mpci->dev, &dev_attr_shipping_mode);
 	if (ret < 0) {
-		dev_notice(&pdev->dev, "create shipping attr fail\n");
+		dev_err(&pdev->dev, "create shipping attr fail\n");
 		goto err_register_chg_dev;
 	}
 	/* for trigger unfinish pe pattern */
@@ -2826,7 +2826,7 @@ static int mt6360_pmu_chg_probe(struct platform_device *pdev)
 && !defined(CONFIG_TCPC_CLASS)
 	schedule_work(&mpci->chgdet_work);
 #endif /* CONFIG_MT6360_PMU_CHARGER_TYPE_DETECT && !CONFIG_TCPC_CLASS */
-	dev_info(&pdev->dev, "%s: successfully probed\n", __func__);
+	dev_dbg(&pdev->dev, "%s: successfully probed\n", __func__);
 	return 0;
 err_shipping_mode_attr:
 	device_remove_file(mpci->dev, &dev_attr_shipping_mode);
diff --git a/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_log.h b/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_log.h
index f7d3fb966..341449a2d 100644
--- a/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_log.h
+++ b/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_log.h
@@ -25,7 +25,7 @@ extern int m4u_log_to_uart;
 do { \
 	if (level > m4u_log_level) { \
 		if (level > m4u_log_to_uart) \
-			pr_info("[PSEUDO][%s #%d]: "string,	 \
+			pr_debug("[PSEUDO][%s #%d]: "string,	 \
 				__func__, __LINE__, ##args); \
 		else\
 			pr_debug("[PSEUDO][%s #%d]: "string,		\
@@ -45,7 +45,7 @@ do { \
 #define M4UTRACE() \
 do { \
 	if (!m4u_log_to_uart) \
-		pr_info("[PSEUDO] %s, %d\n", __func__, __LINE__); \
+		pr_debug("[PSEUDO] %s, %d\n", __func__, __LINE__); \
 } while (0)
 
 #define M4U_PRINT_SEQ(seq_file, fmt, args...) \
diff --git a/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_ut.c b/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_ut.c
index 6aed67c9c..0d9ff7103 100644
--- a/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_ut.c
+++ b/drivers/misc/mediatek/pseudo_m4u/pseudo_m4u_ut.c
@@ -107,7 +107,7 @@ struct test_buffer_info *m4u_test_start(size_t size, int port)
 	buf_info->mva = (dma_addr_t)buffer_mva;
 	buf_info->size = mva_size;
 
-	pr_info("%s done mva:%pa, size:0x%zx, port:%s\n",
+	pr_debug("%s done mva:%pa, size:0x%zx, port:%s\n",
 		__func__, &buf_info->mva, buf_info->size,
 		iommu_get_port_name(port));
 	return buf_info;
@@ -124,7 +124,7 @@ int m4u_test_end(struct test_buffer_info *buf_info)
 	ion_free(buf_info->client, buf_info->handle);
 	ion_client_destroy(buf_info->client);
 	kfree(buf_info);
-	pr_info("%s done\n", __func__);
+	pr_debug("%s done\n", __func__);
 
 	return 0;
 }
@@ -168,7 +168,7 @@ static int m4u_test_probe(struct platform_device *pdev)
 	ret = m4u_test(12345, M4U_PORT_L21_APU_FAKE_DATA); //apu_data
 	ret = m4u_test(12345, M4U_PORT_L21_APU_FAKE_VLM); //apu_vlm
 #endif
-	pr_info("probe dev:0x%lx, name:%s\n",
+	pr_debug("probe dev:0x%lx, name:%s\n",
 		(unsigned long)&pdev->dev, dev_name(&pdev->dev));
 
 	return 0;
@@ -236,7 +236,7 @@ static struct platform_driver m4u_test_driver = {
 
 static int __init m4u_test_init(void)
 {
-	pr_info("%s()\n", __func__);
+	pr_debug("%s()\n", __func__);
 	if (platform_driver_register(&m4u_test_driver)) {
 		pr_notice("%s platform driver register failed.\n", __func__);
 		return -ENODEV;
diff --git a/drivers/misc/mediatek/selinux_warning/Makefile b/drivers/misc/mediatek/selinux_warning/Makefile
index 4952fc7ba..44c741b3b 100644
--- a/drivers/misc/mediatek/selinux_warning/Makefile
+++ b/drivers/misc/mediatek/selinux_warning/Makefile
@@ -10,4 +10,4 @@
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU General Public License for more details.
 #
-obj-y += mtk_selinux_warning.o
+obj-$(CONFIG_MTK_SELINUX_AEE_WARNING) += mtk_selinux_warning.o
diff --git a/drivers/misc/mediatek/smi/smi_drv.c b/drivers/misc/mediatek/smi/smi_drv.c
index 65ec4e6c2..496aa2286 100644
--- a/drivers/misc/mediatek/smi/smi_drv.c
+++ b/drivers/misc/mediatek/smi/smi_drv.c
@@ -70,7 +70,7 @@ static bool smi_sspm_ipi_register;
 		if (cmdq != 0) \
 			cmdq_util_msg(string, ##args); \
 		else \
-			pr_info(string, ##args); \
+			pr_warn(string, ##args); \
 	} while (0)
 #elif IS_ENABLED(CONFIG_MTK_CMDQ)
 #include <cmdq_helper_ext.h>
@@ -78,15 +78,15 @@ static bool smi_sspm_ipi_register;
 	do { \
 		if (cmdq != 0) \
 			cmdq_core_save_first_dump(string, ##args); \
-		pr_info(string, ##args); \
+		pr_warn(string, ##args); \
 	} while (0)
 #else
-#define SMIWRN(cmdq, string, args...) pr_info(string, ##args)
+#define SMIWRN(cmdq, string, args...) pr_warn(string, ##args)
 #endif
 
 #define SMIERR(string, args...) \
 	do { \
-		pr_notice(string, ##args); \
+		pr_err(string, ##args); \
 		aee_kernel_warning(DEV_NAME, string, ##args); \
 	} while (0)
 
diff --git a/drivers/misc/mediatek/systracker/Kconfig b/drivers/misc/mediatek/systracker/Kconfig
index 3911a92ba..a9866518b 100644
--- a/drivers/misc/mediatek/systracker/Kconfig
+++ b/drivers/misc/mediatek/systracker/Kconfig
@@ -1,3 +1,9 @@
+config MTK_SYSTRACKER_DISABLE
+	bool "Disable all systracker services"
+	default y
+	help
+	  Disable the Mediatek systracker debugging feature
+
 config MTK_SYSTRACKER_V2
 	bool "Enable MTK System Tracker Debugger V2"
 	select MTK_SYSTRACKER
diff --git a/drivers/misc/mediatek/systracker/Makefile b/drivers/misc/mediatek/systracker/Makefile
index 4a5fbb8dc..6357afaab 100644
--- a/drivers/misc/mediatek/systracker/Makefile
+++ b/drivers/misc/mediatek/systracker/Makefile
@@ -10,7 +10,7 @@
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU General Public License for more details.
 #
-
+ifneq ($(CONFIG_MTK_SYSTRACKER_DISABLE),y)
 ifeq ($(CONFIG_MTK_SYSTRACKER_V2),y)
     obj-y += systracker_interface_v2.o
 endif
@@ -21,3 +21,4 @@ else
   obj-y += backtrace32.o
   obj-y += backtrace32_asm.o
 endif
+endif
\ No newline at end of file
diff --git a/drivers/misc/mediatek/teei/300/Makefile b/drivers/misc/mediatek/teei/300/Makefile
index 9ef45659b..7b3923810 100644
--- a/drivers/misc/mediatek/teei/300/Makefile
+++ b/drivers/misc/mediatek/teei/300/Makefile
@@ -10,12 +10,12 @@
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 # GNU General Public License for more details.
 
-$(info "CONFIG_MICROTRUST_TEE_SUPPORT=$(CONFIG_MICROTRUST_TEE_SUPPORT)")
-$(info "CONFIG_MICROTRUST_TZ_DRIVER=$(CONFIG_MICROTRUST_TZ_DRIVER)")
-$(info "CONFIG_MICROTRUST_VFS_DRIVER=$(CONFIG_MICROTRUST_VFS_DRIVER)")
-$(info "CONFIG_MICROTRUST_FP_DRIVER=$(CONFIG_MICROTRUST_FP_DRIVER)")
-$(info "CONFIG_MICROTRUST_DEBUG=$(CONFIG_MICROTRUST_DEBUG)")
-$(info "CONFIG_MICROTRUST_TEST_DRIVERS=$(CONFIG_MICROTRUST_TEST_DRIVERS)")
+#$(info "CONFIG_MICROTRUST_TEE_SUPPORT=$(CONFIG_MICROTRUST_TEE_SUPPORT)")
+#$(info "CONFIG_MICROTRUST_TZ_DRIVER=$(CONFIG_MICROTRUST_TZ_DRIVER)")
+#$(info "CONFIG_MICROTRUST_VFS_DRIVER=$(CONFIG_MICROTRUST_VFS_DRIVER)")
+#$(info "CONFIG_MICROTRUST_FP_DRIVER=$(CONFIG_MICROTRUST_FP_DRIVER)")
+#$(info "CONFIG_MICROTRUST_DEBUG=$(CONFIG_MICROTRUST_DEBUG)")
+#$(info "CONFIG_MICROTRUST_TEST_DRIVERS=$(CONFIG_MICROTRUST_TEST_DRIVERS)")
 
 subdir-ccflags-y  += -I$(src)/common/include
 subdir-ccflags-$(CONFIG_MTK_TEE_SANITY) += \
diff --git a/drivers/misc/mediatek/teei/300/tz_driver/Makefile b/drivers/misc/mediatek/teei/300/tz_driver/Makefile
index cfd096734..c114ce06c 100644
--- a/drivers/misc/mediatek/teei/300/tz_driver/Makefile
+++ b/drivers/misc/mediatek/teei/300/tz_driver/Makefile
@@ -23,6 +23,5 @@ obj-$(CONFIG_MICROTRUST_TZ_DRIVER) += teei.o
 
 ccflags-$(CONFIG_MTK_ENG_BUILD) += -DENABLED_TEEI_BOOT_LOG
 
-ccflags-y += -D DEBUG_DO
 ccflags-y += -Wno-error
 ccflags-y += -D UT_DMA_ZONE
diff --git a/drivers/misc/mediatek/teei/Kconfig b/drivers/misc/mediatek/teei/Kconfig
index 2c4b0f52a..ad571d8b3 100644
--- a/drivers/misc/mediatek/teei/Kconfig
+++ b/drivers/misc/mediatek/teei/Kconfig
@@ -58,7 +58,7 @@ config MICROTRUST_TZ_DRIVER_MTK_BOOTPROF
 	bool "Enable MTK bootprof to track boot progress of TEEI"
 	depends on MICROTRUST_TZ_DRIVER
 	depends on MTPROF
-	default y
+	default n
 	---help---
 	  Enables the support of Mediatek bootprof feature in Microtrust
 	  tz_driver. This feature is for tracking boot progress by
@@ -134,7 +134,7 @@ config MICROTRUST_UNITTEST_SUPPORT
 config MICROTRUST_TZ_LOG
 	bool "Enable Microtrust TrustZone logger"
 	depends on MICROTRUST_TEE_SUPPORT
-	default y
+	default n
 	---help---
 	  Enable Microtrust TrustZone logger to dump TEE logs in kernel log buffer.
 	  This driver will read out log buffer and direct to console each
diff --git a/drivers/misc/mediatek/teei/Makefile b/drivers/misc/mediatek/teei/Makefile
index b586f441f..00e12c55c 100644
--- a/drivers/misc/mediatek/teei/Makefile
+++ b/drivers/misc/mediatek/teei/Makefile
@@ -11,6 +11,6 @@
 # GNU General Public License for more details.
 
 ifeq ($(CONFIG_MICROTRUST_TEE_SUPPORT), y)
-$(info "CONFIG_MICROTRUST_TEE_VERSION=$(CONFIG_MICROTRUST_TEE_VERSION)")
+#$(info "CONFIG_MICROTRUST_TEE_VERSION=$(CONFIG_MICROTRUST_TEE_VERSION)")
 obj-y += $(subst ",,$(CONFIG_MICROTRUST_TEE_VERSION))/
 endif
diff --git a/drivers/misc/mediatek/thermal/common/ap_thermal_limit.c b/drivers/misc/mediatek/thermal/common/ap_thermal_limit.c
index ce0a81ad5..00f7d0acc 100644
--- a/drivers/misc/mediatek/thermal/common/ap_thermal_limit.c
+++ b/drivers/misc/mediatek/thermal/common/ap_thermal_limit.c
@@ -112,13 +112,13 @@ static DEFINE_MUTEX(apthermolmt_cpu_mutex);
 void __attribute__ ((weak))
 mt_ppm_cpu_thermal_protect(unsigned int limited_power)
 {
-	pr_notice(TSCPU_LOG_TAG "E_WF: %s doesn't exist\n", __func__);
+	pr_err(TSCPU_LOG_TAG "E_WF: %s doesn't exist\n", __func__);
 }
 #else
 void __attribute__ ((weak))
 mt_cpufreq_thermal_protect(unsigned int limited_power)
 {
-	pr_notice(TSCPU_LOG_TAG "E_WF: %s doesn't exist\n", __func__);
+	pr_err(TSCPU_LOG_TAG "E_WF: %s doesn't exist\n", __func__);
 }
 #endif
 
@@ -126,7 +126,7 @@ mt_cpufreq_thermal_protect(unsigned int limited_power)
 void __attribute__ ((weak))
 mt_gpufreq_thermal_protect(unsigned int limited_power)
 {
-	pr_notice(TSCPU_LOG_TAG "E_WF: %s doesn't exist\n", __func__);
+	pr_err(TSCPU_LOG_TAG "E_WF: %s doesn't exist\n", __func__);
 }
 
 
@@ -372,7 +372,7 @@ void apthermolmt_set_general_cpu_power_limit(unsigned int limit)
 	gp_curr_cpu_pwr_limit = (limit != 0) ? limit : 0x7FFFFFFF;
 
 	if (gp_prev_cpu_pwr_limit != gp_curr_cpu_pwr_limit) {
-		tscpu_warn("%s %d\n", __func__, gp_curr_cpu_pwr_limit);
+		pr_debug("%s %d\n", __func__, gp_curr_cpu_pwr_limit);
 
 		apthermolmt_set_cpu_power_limit(&_gp, gp_curr_cpu_pwr_limit);
 	}
@@ -385,7 +385,7 @@ void apthermolmt_set_general_gpu_power_limit(unsigned int limit)
 	gp_curr_gpu_pwr_limit = (limit != 0) ? limit : 0x7FFFFFFF;
 
 	if (gp_prev_gpu_pwr_limit != gp_curr_gpu_pwr_limit) {
-		tscpu_warn("%s %d\n", __func__, gp_curr_gpu_pwr_limit);
+		pr_debug("%s %d\n", __func__, gp_curr_gpu_pwr_limit);
 
 		apthermolmt_set_gpu_power_limit(&_gp, gp_curr_gpu_pwr_limit);
 	}
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_3Gmutt.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_3Gmutt.c
index 271350102..c8240d3c7 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_3Gmutt.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_3Gmutt.c
@@ -25,7 +25,7 @@
 static int cl_debug_flag;
 
 #define mtk_cooler_3Gmutt_dprintk_always(fmt, args...)	\
-	pr_notice("[Thermal/TC/3Gmutt]" fmt, ##args)
+	pr_debug("[Thermal/TC/3Gmutt]" fmt, ##args)
 
 
 #define mtk_cooler_3Gmutt_dprintk(fmt, args...) \
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_NR.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_NR.c
index 2addb3162..10abde15e 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_NR.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_NR.c
@@ -41,11 +41,11 @@
 #define clNR_dprintk(fmt, args...)   \
 	do {                                    \
 		if (clNR_debug_log == 1) {                \
-			pr_notice(CLNR_LOG_TAG fmt, ##args); \
+			pr_debug(CLNR_LOG_TAG fmt, ##args); \
 		}                                   \
 	} while (0)
 
-#define clNR_printk(fmt, args...) pr_notice(CLNR_LOG_TAG fmt, ##args)
+#define clNR_printk(fmt, args...) pr_debug(CLNR_LOG_TAG fmt, ##args)
 /*=============================================================
  *Local variable definition
  *=============================================================
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_VR_FPS.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_VR_FPS.c
index 818c8e9d8..1397d8f96 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_VR_FPS.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_VR_FPS.c
@@ -40,11 +40,11 @@
 #define clVR_FPS_dprintk(fmt, args...)   \
 	do {                                    \
 		if (clVR_FPS_debug_log == 1) {                \
-			pr_notice(CLVR_FPS_LOG_TAG fmt, ##args); \
+			pr_debug(CLVR_FPS_LOG_TAG fmt, ##args); \
 		}                                   \
 	} while (0)
 
-#define clVR_FPS_printk(fmt, args...) pr_notice(CLVR_FPS_LOG_TAG fmt, ##args)
+#define clVR_FPS_printk(fmt, args...) pr_debug(CLVR_FPS_LOG_TAG fmt, ##args)
 /*=============================================================
  *Local variable definition
  *=============================================================
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_amutt.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_amutt.c
index 29aa79836..6023a0250 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_amutt.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_amutt.c
@@ -29,7 +29,7 @@ int __attribute__ ((weak))
 exec_ccci_kern_func_by_md_id(
 int md_id, unsigned int id, char *buf, unsigned int len)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -316;
 }
 
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_atm.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_atm.c
index 0430509fb..6c1b9a8c2 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_atm.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_atm.c
@@ -441,13 +441,13 @@ static void set_adaptive_gpu_power_limit(unsigned int limit);
 void __attribute__ ((weak))
 mt_ppm_cpu_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #else
 void __attribute__ ((weak))
 mt_cpufreq_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #endif
 #endif
@@ -457,7 +457,7 @@ mtk_eara_thermal_pb_handle(int total_pwr_budget,
 			   int max_cpu_power, int max_gpu_power,
 			   int max_vpu_power,  int max_mdla_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -465,20 +465,20 @@ bool __attribute__((weak))
 mtk_get_gpu_loading(unsigned int *pLoading)
 {
 #ifdef CONFIG_MTK_GPU_SUPPORT
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 #endif
 	return 0;
 }
 unsigned int  __attribute__((weak))
 mt_gpufreq_get_min_power(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 unsigned int  __attribute__((weak))
 mt_gpufreq_get_max_power(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 void __attribute__ ((weak))
@@ -727,7 +727,7 @@ static void atm_profile_atm_period(s64 latest_latency)
 			(latest_latency + (atm_period_avg_delay<<14) -
 						atm_period_avg_delay)>>14;
 	}
-	tscpu_warn("atm period M %lld m %lld a %lld l %lld\n"
+	pr_debug("atm period M %lld m %lld a %lld l %lld\n"
 		, atm_period_max_delay
 		, atm_period_min_delay
 		, atm_period_avg_delay
@@ -749,7 +749,7 @@ static void atm_profile_atm_exec(s64 latest_latency)
 			(latest_latency + (atm_exec_avg_delay<<14) -
 						atm_exec_avg_delay)>>14;
 	}
-	tscpu_warn("atm exec delay M %lld m %lld a %lld l %lld\n"
+	pr_debug("atm exec delay M %lld m %lld a %lld l %lld\n"
 		, atm_exec_max_delay
 		, atm_exec_min_delay
 		, atm_exec_avg_delay
@@ -771,7 +771,7 @@ static void atm_profile_cpu_power_limit(s64 latest_latency)
 			(latest_latency + (cpu_pwr_lmt_avg_delay<<14) -
 						cpu_pwr_lmt_avg_delay)>>14;
 	}
-	tscpu_warn("cpu lmt delay M %lld m %lld a %lld l %lld\n"
+	pr_debug("cpu lmt delay M %lld m %lld a %lld l %lld\n"
 		, cpu_pwr_lmt_max_delay
 		, cpu_pwr_lmt_min_delay
 		, cpu_pwr_lmt_avg_delay
@@ -793,7 +793,7 @@ static void atm_profile_gpu_power_limit(s64 latest_latency)
 			(latest_latency + (gpu_pwr_lmt_avg_delay<<14) -
 						gpu_pwr_lmt_avg_delay)/1024;
 	}
-	tscpu_warn("gpu lmt delay M %lld m %lld a %lld l %lld\n"
+	pr_debug("gpu lmt delay M %lld m %lld a %lld l %lld\n"
 		, gpu_pwr_lmt_max_delay
 		, gpu_pwr_lmt_min_delay
 		, gpu_pwr_lmt_avg_delay
@@ -837,7 +837,7 @@ static void set_adaptive_cpu_power_limit(unsigned int limit)
 #endif
 		print_cunt++;
 		if (print_cunt == 5) {
-			tscpu_warn(
+			pr_debug(
 				"%s (0x%x) %d T=%d, %d T=%d, %d T=%d, %d T=%d, %d T=%d\n",
 				__func__,
 				tscpu_get_temperature_range(),
@@ -853,7 +853,7 @@ static void set_adaptive_cpu_power_limit(unsigned int limit)
 			if ((prv_adp_cpu_pwr_lim != 0x7FFFFFFF) &&
 				((adaptive_cpu_power_limit + 1000)
 				< prv_adp_cpu_pwr_lim))
-				tscpu_warn(
+				pr_debug(
 					"%s Big delta power %u curr_T=%d, %u prev_T=%d\n",
 					__func__, adaptive_cpu_power_limit,
 					krtatm_curr_maxtj, prv_adp_cpu_pwr_lim,
@@ -1119,7 +1119,7 @@ static void catmplus_update_params(void)
 						STEADY_TARGET_TPCB;
 
 	ret = wakeup_ta_algo(TA_CATMPLUS);
-	/*tscpu_warn("catmplus_update_params : ret %d\n" , ret);*/
+	/*pr_debug("catmplus_update_params : ret %d\n" , ret);*/
 }
 
 #endif
@@ -3616,7 +3616,7 @@ exit:
 		polling_time_s = polling_time / 1000000000;
 		polling_time_ns = polling_time % 1000000000;
 		ktime = ktime_set(polling_time_s, polling_time_ns);
-		/* tscpu_warn("%s polling_time_s=%ld  "
+		/* pr_debug("%s polling_time_s=%ld  "
 		 *	"polling_time_ns=%ld\n", __func__,
 		 *	polling_time_s,polling_time_ns);
 		 */
@@ -3747,7 +3747,7 @@ static int krtatm_thread(void *arg)
 			/* To confirm if krtatm kthread is really running. */
 			if (krtatm_curr_maxtj >= 100000 ||
 			(krtatm_curr_maxtj - krtatm_prev_maxtj >= 20000)) {
-				tscpu_warn("%s c %d p %d cl %d gl %d s %d\n",
+				pr_debug("%s c %d p %d cl %d gl %d s %d\n",
 				__func__, krtatm_curr_maxtj,
 				krtatm_prev_maxtj,
 				adaptive_cpu_power_limit,
@@ -3756,7 +3756,7 @@ static int krtatm_thread(void *arg)
 				/* dump more info when atm is deactivated */
 				if (!cl_dev_adp_cpu_state_active) {
 #ifdef CONFIG_MTK_TINYSYS_SSPM_SUPPORT
-					pr_info_ratelimited(TSCPU_LOG_TAG
+					pr_debug(TSCPU_LOG_TAG
 					"tjs %d ttj %d %d on %d sspm %d %d\n",
 					TARGET_TJS[0], TARGET_TJ,
 					current_ETJ, ctm_on,
@@ -3772,7 +3772,7 @@ static int krtatm_thread(void *arg)
 					0);
 #endif
 #else /* !CONFIG_MTK_TINYSYS_SSPM_SUPPORT */
-					pr_info_ratelimited(TSCPU_LOG_TAG
+					pr_debug(TSCPU_LOG_TAG
 					"tjs %d ttj %d %d on %d\n",
 					TARGET_TJS[0], TARGET_TJ,
 					current_ETJ, ctm_on);
@@ -3793,7 +3793,7 @@ static int krtatm_thread(void *arg)
 		schedule();
 	}
 
-	tscpu_warn("%s stopped\n", __func__);
+	pr_debug("%s stopped\n", __func__);
 	return 0;
 }
 #endif	/* FAST_RESPONSE_ATM */
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct.c
index 0c0b58b4a..df3abba8c 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct.c
@@ -44,82 +44,82 @@
 	int __attribute__ ((weak))
 get_bat_charging_current_level(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 500;
 }
 
 	enum charger_type __attribute__ ((weak))
 mt_get_charger_type(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return STANDARD_HOST;
 }
 
 	int __attribute__ ((weak))
 set_bat_charging_current_limit(int current_limit)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	unsigned int __attribute__ ((weak))
 set_chr_input_current_limit(int current_limit)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_soc(unsigned int *soc)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_ui_soc(unsigned int *ui_soc)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_vbat(unsigned int *vbat)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_ibat(unsigned int *ibat)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_vbus(unsigned int *vbus)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_aicr(unsigned int *aicr)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_tchr(int *min_temp, int *max_temp)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 /* ************************************ */
 
 #define mtk_cooler_bcct_dprintk_always(fmt, args...) \
-	pr_notice("[Thermal/TC/bcct]" fmt, ##args)
+	pr_debug("[Thermal/TC/bcct]" fmt, ##args)
 
 #define mtk_cooler_bcct_dprintk(fmt, args...) \
 	do { \
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_2nd.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_2nd.c
index 76c3356dc..90dc9cd97 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_2nd.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_2nd.c
@@ -41,14 +41,14 @@
 	int __attribute__ ((weak))
 get_bat_charging_current_level(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 500;
 }
 
 	enum charger_type __attribute__ ((weak))
 mt_get_charger_type(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return STANDARD_HOST;
 }
 
@@ -57,21 +57,21 @@ mt_get_charger_type(void)
 charger_manager_set_charging_current_limit(
 struct charger_consumer *consumer, int idx, int charging_current_uA)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	int __attribute__ ((weak))
 charger_manager_set_input_current_limit(
 struct charger_consumer *consumer, int idx, int input_current_uA)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_tchr_x(int *min_temp, int *max_temp)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 /* mtk_chr_get_tchr() */
@@ -79,14 +79,14 @@ mtk_chr_get_tchr_x(int *min_temp, int *max_temp)
 	int __attribute__ ((weak))
 charger_manager_get_current_charging_type(struct charger_consumer *consumer)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 #endif
 /* ************************************ */
 
 #define mtk_cooler_bcct_2nd_dprintk_always(fmt, args...) \
-	pr_notice("[Thermal/TC/bcct_2nd]" fmt, ##args)
+	pr_debug("[Thermal/TC/bcct_2nd]" fmt, ##args)
 
 #define mtk_cooler_bcct_2nd_dprintk(fmt, args...) \
 	do { \
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_v1.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_v1.c
index 4859b0ae1..acd992cbb 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_v1.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_bcct_v1.c
@@ -41,14 +41,14 @@
 	int __attribute__ ((weak))
 get_bat_charging_current_level(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 500;
 }
 
 	enum charger_type __attribute__ ((weak))
 mt_get_charger_type(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return STANDARD_HOST;
 }
 
@@ -57,14 +57,14 @@ mt_get_charger_type(void)
 charger_manager_set_charging_current_limit(
 struct charger_consumer *consumer, int idx, int charging_current_uA)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	int __attribute__ ((weak))
 charger_manager_set_input_current_limit(
 struct charger_consumer *consumer, int idx, int input_current_uA)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -72,38 +72,38 @@ struct charger_consumer *consumer, int idx, int input_current_uA)
 charger_manager_enable_high_voltage_charging(
 struct charger_consumer *consumer, bool en)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	signed int __attribute__ ((weak))
 battery_get_soc(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	signed int __attribute__ ((weak))
 battery_get_uisoc(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	signed int __attribute__ ((weak))
 battery_get_bat_voltage(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	signed int __attribute__ ((weak))
 battery_get_bat_current(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	signed int __attribute__ ((weak))
 battery_get_vbus(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -111,14 +111,14 @@ battery_get_vbus(void)
 	int __attribute__ ((weak))
 mtk_chr_get_aicr(unsigned int *aicr)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_tchr(int *min_temp, int *max_temp)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 /* mtk_chr_get_tchr() */
@@ -126,7 +126,7 @@ mtk_chr_get_tchr(int *min_temp, int *max_temp)
 	int __attribute__ ((weak))
 charger_manager_get_current_charging_type(struct charger_consumer *consumer)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 #ifdef CONFIG_MTK_PUMP_EXPRESS_PLUS_30_SUPPORT
@@ -135,7 +135,7 @@ charger_manager_get_pe30_input_current_limit(
 struct charger_consumer *consumer, int idx, int *input_current_uA,
 		int *min_current_uA, int *max_current_uA)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 
@@ -143,7 +143,7 @@ struct charger_consumer *consumer, int idx, int *input_current_uA,
 charger_manager_set_pe30_input_current_limit(
 struct charger_consumer *consumer, int idx, int input_current_uA)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 #endif /* CONFIG_MTK_PUMP_EXPRESS_PLUS_30_SUPPORT */
@@ -152,89 +152,89 @@ struct charger_consumer *consumer, int idx, int input_current_uA)
 	int __attribute__ ((weak))
 set_bat_charging_current_limit(int current_limit)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 	unsigned int __attribute__ ((weak))
 set_chr_input_current_limit(int current_limit)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_soc(unsigned int *soc)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_ui_soc(unsigned int *ui_soc)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_vbat(unsigned int *vbat)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_ibat(unsigned int *ibat)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_vbus(unsigned int *vbus)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_aicr(unsigned int *aicr)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_tchr(int *min_temp, int *max_temp)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 mtk_chr_get_current_charging_type(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 
 	int __attribute__ ((weak))
 mtk_pep30_get_charging_current_limit(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 
 	void __attribute__ ((weak))
 mtk_pep30_set_charging_current_limit(int cur)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #endif
 /* ************************************ */
 
 #define mtk_cooler_bcct_dprintk_always(fmt, args...) \
-	pr_notice("[Thermal/TC/bcct]" fmt, ##args)
+	pr_debug("[Thermal/TC/bcct]" fmt, ##args)
 
 #define mtk_cooler_bcct_dprintk(fmt, args...) \
 	do { \
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_char_curr_cus.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_char_curr_cus.c
index 68b954d10..b616fa9d6 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_char_curr_cus.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_char_curr_cus.c
@@ -45,7 +45,7 @@ static struct charger_consumer *thm_chr_consumer;
 #define CHAR_CURR_TABLE_INDEX 16
 
 #define mtk_cooler_char_curr_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/char_curr " fmt, ##args)
+	pr_debug("thermal/cooler/char_curr " fmt, ##args)
 
 static struct thermal_cooling_device
 *cl_char_curr_dev = { 0 };
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_dtm.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_dtm.c
index 450a11eb3..71a141561 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_dtm.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_dtm.c
@@ -101,13 +101,13 @@ static void set_static_gpu_power_limit(unsigned int limit);
 void __attribute__ ((weak))
 mt_ppm_cpu_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #else
 void __attribute__ ((weak))
 mt_cpufreq_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #endif
 #endif
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_fps.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_fps.c
index 8b01e6858..f3c404886 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_fps.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_fps.c
@@ -69,7 +69,7 @@ pr_debug("[Thermal/TC/fps]" fmt, ##args)
 #define mtk_cooler_fps_dprintk(fmt, args...) \
 do { \
 	if (cl_fps_klog_on == 1) \
-		pr_notice("[Thermal/TC/fps]" fmt, ##args); \
+		pr_debug("[Thermal/TC/fps]" fmt, ##args); \
 } while (0)
 
 #define MAX_NUM_INSTANCE_MTK_COOLER_FPS  4
@@ -172,14 +172,14 @@ enum {
 int __attribute__ ((weak))
 disp_mgr_get_session_info(struct disp_session_info *info)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 unsigned long  __attribute__ ((weak))
 ged_query_info(GED_INFO eType)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -187,7 +187,7 @@ bool  __attribute__ ((weak))
 mtk_get_gpu_loading(unsigned int *pLoading)
 {
 #ifdef CONFIG_MTK_GPU_SUPPORT
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 #endif
 	return 0;
 }
@@ -977,7 +977,7 @@ static const struct file_operations tm_fps_fops = {
  *		dentry_f = debugfs_create_u32
  *     (#name, S_IWUSR | S_IRUGO, _d, &name); \
  *		if (IS_ERR_OR_NULL(dentry_f)) {	\
- *		pr_notice("Unable to create debugfsfile: " #name "\n"); \
+ *		pr_err("Unable to create debugfsfile: " #name "\n"); \
  *			return; \
  *		} \
  *} while (0)
@@ -989,7 +989,7 @@ static const struct file_operations tm_fps_fops = {
  *
  *	_d = debugfs_create_dir("clfps", NULL);
  *	if (IS_ERR_OR_NULL(_d)) {
- *		pr_info("unable to create debugfs directory\n");
+ *		pr_err("unable to create debugfs directory\n");
  *		return;
  *	}
  *
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_gpu_cus.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_gpu_cus.c
index 10ccf9791..cc668f2bb 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_gpu_cus.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_gpu_cus.c
@@ -30,7 +30,7 @@
 
 
 #define mtk_cooler_gpu_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/gpu " fmt, ##args)
+	pr_debug("thermal/cooler/gpu " fmt, ##args)
 
 static struct thermal_cooling_device
 *cl_gpu_dev = { 0 };
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_md_cus.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_md_cus.c
index cba378644..be2979ac6 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_md_cus.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_md_cus.c
@@ -30,7 +30,7 @@
 
 
 #define mtk_cooler_md_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/md " fmt, ##args)
+	pr_debug("thermal/cooler/md " fmt, ##args)
 
 static struct thermal_cooling_device *cl_md_dev = { 0 };
 static unsigned int g_cl_id;
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt.c
index 4c916c55e..7998fe882 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt.c
@@ -203,7 +203,7 @@ static int triggered;
 unsigned long __attribute__ ((weak))
 ccci_get_md_boot_count(int md_id)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -211,7 +211,7 @@ int __attribute__ ((weak))
 exec_ccci_kern_func_by_md_id(
 int md_id, unsigned int id, char *buf, unsigned int len)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -316;
 }
 
@@ -1130,7 +1130,7 @@ static struct thermal_cooling_device_ops mtk_cl_adp_mutt_ops = {
  *do { \
  *	dentry_f = debugfs_create_u32(#name, S_IWUSR | S_IRUGO, _d, &name); \
  *	if (IS_ERR_OR_NULL(dentry_f)) {	\
- *		pr_notice("Unable to create debugfsfile: " #name "\n"); \
+ *		pr_err("Unable to create debugfsfile: " #name "\n"); \
  *		return; \
  *	} \
  *} while (0)
@@ -1142,7 +1142,7 @@ static struct thermal_cooling_device_ops mtk_cl_adp_mutt_ops = {
  *
  *	_d = debugfs_create_dir("cl_adp_mutt", NULL);
  *	if (IS_ERR_OR_NULL(_d)) {
- *		pr_info("unable to create debugfs directory\n");
+ *		pr_err("unable to create debugfs directory\n");
  *		return;
  *	}
  *
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt_gen97.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt_gen97.c
index 523b1714a..54be30d1c 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt_gen97.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_mutt_gen97.c
@@ -259,7 +259,7 @@ static struct clmutt_param clmutt_data = {
 unsigned long __attribute__ ((weak))
 ccci_get_md_boot_count(int md_id)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -267,7 +267,7 @@ int __attribute__ ((weak))
 exec_ccci_kern_func_by_md_id(
 int md_id, unsigned int id, char *buf, unsigned int len)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -316;
 }
 
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_sysrst.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_sysrst.c
index e076ed748..9ec609a1e 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_sysrst.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_sysrst.c
@@ -201,10 +201,10 @@ struct thermal_cooling_device *cdev, unsigned long state)
 	cl_dev_sysrst_state_tsbif = state;
 
 	if (cl_dev_sysrst_state_tsbif == 1) {
-		pr_notice("%s = 1\n", __func__);
-		pr_notice("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
-		pr_notice("*****************************************\n");
-		pr_notice("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		pr_debug("%s = 1\n", __func__);
+		pr_debug("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		pr_debug("*****************************************\n");
+		pr_debug("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
 
 		/* To trigger data abort to reset the system
 		 * for thermal protection.
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_vpu_cus.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_vpu_cus.c
index 0871db580..c5c63282f 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_vpu_cus.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_cooler_vpu_cus.c
@@ -29,7 +29,7 @@
 #include "vpu_dvfs.h"
 
 #define mtk_cooler_vpu_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/vpu " fmt, ##args)
+	pr_debug("thermal/cooler/vpu " fmt, ##args)
 
 static struct thermal_cooling_device
 *cl_vpu_dev = { 0 };
diff --git a/drivers/misc/mediatek/thermal/common/coolers/mtk_ta.c b/drivers/misc/mediatek/thermal/common/coolers/mtk_ta.c
index c944f7ed2..981fdf9bd 100644
--- a/drivers/misc/mediatek/thermal/common/coolers/mtk_ta.c
+++ b/drivers/misc/mediatek/thermal/common/coolers/mtk_ta.c
@@ -56,7 +56,7 @@ static int mtkts_ta_debug_log;
 		}                                   \
 	} while (0)
 
-#define tsta_warn(fmt, args...)  pr_notice("[Thermal/TC/TA]" fmt, ##args)
+#define tsta_warn(fmt, args...)  pr_warn("[Thermal/TC/TA]" fmt, ##args)
 
 /* ************************************ */
 /* Weak functions */
@@ -276,7 +276,7 @@ void atm_ctrl_cmd_from_user(void *nl_data, struct tad_nl_msg_t *ret_msg)
 		break;
 
 	default:
-		tsta_warn("bad TA_DAEMON_CTRL_CMD_FROM_USER 0x%x\n",
+		pr_err("bad TA_DAEMON_CTRL_CMD_FROM_USER 0x%x\n",
 							msg->tad_cmd);
 				g_ta_status = g_ta_status | 0x01000000;
 		break;
@@ -320,7 +320,7 @@ static void ta_nl_send_to_user(int pid, int seq, struct tad_nl_msg_t *reply_msg)
 	ret = netlink_unicast(daemo_nl_sk, skb, pid, MSG_DONTWAIT);
 	if (ret < 0) {
 		g_ta_status = g_ta_status | 0x00000010;
-		pr_notice("[%s] send failed %d\n", __func__, ret);
+		pr_err("[%s] send failed %d\n", __func__, ret);
 		return;
 	}
 
@@ -354,7 +354,7 @@ static void ta_nl_data_handler(struct sk_buff *skb)
 	tad_msg = (struct tad_nl_msg_t *)data;
 	if (tad_msg->tad_ret_data_len >= TAD_NL_MSG_MAX_LEN) {
 		g_ta_status = g_ta_status | 0x00000100;
-		tsta_warn("[%s] tad_msg->=ad_ret_data_len=%d\n", __func__,
+		tsta_dprintk("[%s] tad_msg->=ad_ret_data_len=%d\n", __func__,
 		tad_msg->tad_ret_data_len);
 		return;
 	}
@@ -380,7 +380,7 @@ int wakeup_ta_algo(int flow_state)
 	if (g_ta_counter >= 3) {
 		g_ta_counter = 0;
 		if (g_ta_status != 0)
-			tsta_warn("[%s] status: 0x%x\n", __func__, g_ta_status);
+			tsta_dprintk("[%s] status: 0x%x\n", __func__, g_ta_status);
 	}
 	g_ta_counter++;
 	if (g_tad_pid != 0) {
@@ -403,7 +403,7 @@ int wakeup_ta_algo(int flow_state)
 		kfree(tad_msg);
 		return 0;
 	}
-	tsta_warn("[%s] error,g_tad_pid=0\n", __func__);
+	pr_err("[%s] error,g_tad_pid=0\n", __func__);
 	g_ta_status = g_ta_status | 0x00001000;
 	return -1;
 }
@@ -437,7 +437,7 @@ struct file *file, const char __user *buffer, size_t count, loff_t *data)
 		return count;
 	}
 
-	tsta_warn("%s bad argument\n", __func__);
+	pr_err("%s bad argument\n", __func__);
 
 
 	return -EINVAL;
@@ -546,7 +546,7 @@ static int __init ta_init(void)
 	tsta_dprintk("netlink_kernel_create protol= %d\n", NETLINK_TAD);
 
 	if (daemo_nl_sk == NULL) {
-		tsta_warn("[%s] netlink_kernel_create error\n", __func__);
+		pr_err("[%s] netlink_kernel_create error\n", __func__);
 		g_ta_status = 0x00000001;
 		return -1;
 	}
diff --git a/drivers/misc/mediatek/thermal/common/mtk_change_policy.c b/drivers/misc/mediatek/thermal/common/mtk_change_policy.c
index 16700ab1f..f3f732aee 100644
--- a/drivers/misc/mediatek/thermal/common/mtk_change_policy.c
+++ b/drivers/misc/mediatek/thermal/common/mtk_change_policy.c
@@ -37,7 +37,7 @@
 
 #if 1
 #define mtk_thermal_policy_dprintk(fmt, args...)	\
-	pr_notice("thermal/thermal_policy " fmt, ##args)
+	pr_debug("thermal/thermal_policy " fmt, ##args)
 #else
 #define mtk_thermal_policy_dprintk(fmt, args...)
 #endif
diff --git a/drivers/misc/mediatek/thermal/common/mtk_thermal_platform.c b/drivers/misc/mediatek/thermal/common/mtk_thermal_platform.c
index 6340fc13f..f1b159395 100644
--- a/drivers/misc/mediatek/thermal/common/mtk_thermal_platform.c
+++ b/drivers/misc/mediatek/thermal/common/mtk_thermal_platform.c
@@ -49,7 +49,7 @@ bool __attribute__ ((weak))
 mtk_get_gpu_loading(unsigned int *pLoading)
 {
 #ifdef CONFIG_MTK_GPU_SUPPORT
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 #endif
 	return 0;
 }
@@ -57,7 +57,7 @@ mtk_get_gpu_loading(unsigned int *pLoading)
 int __attribute__ ((weak))
 force_get_tbat(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 30;
 }
 
@@ -80,12 +80,12 @@ static DEFINE_MUTEX(MTM_SYSINFO_LOCK);
 #define THRML_LOG(fmt, args...) \
 do { \
 	if (enable_ThermalMonitor)\
-		pr_notice("THERMAL/PLATFORM" fmt, ##args); \
+		pr_debug("THERMAL/PLATFORM" fmt, ##args); \
 } while (0)
 
 
 #define THRML_ERROR_LOG(fmt, args...) \
-	pr_notice("THERMAL/PLATFORM" fmt, ##args)
+	pr_err("THERMAL/PLATFORM" fmt, ##args)
 
 /* ************************************ */
 /* Define */
diff --git a/drivers/misc/mediatek/thermal/common/mtk_thermal_timer.c b/drivers/misc/mediatek/thermal/common/mtk_thermal_timer.c
index 1cd29fda8..d1617a9f7 100644
--- a/drivers/misc/mediatek/thermal/common/mtk_thermal_timer.c
+++ b/drivers/misc/mediatek/thermal/common/mtk_thermal_timer.c
@@ -47,7 +47,7 @@
 #define mtkTTimer_dprintk(fmt, args...)   \
 	do {	\
 		if (mtkTTimer_debug_log)	\
-			pr_notice("[Thermal timer] " fmt, ##args); \
+			pr_debug("[Thermal timer] " fmt, ##args); \
 	} while (0)
 
 static DEFINE_SPINLOCK(tTimer_lock);
@@ -267,7 +267,7 @@ static int mtk_thermal_cpu_pm_notifier(struct notifier_block *nb,
 #if defined(LVTS_CPU_PM_NTFY_PROFILE)
 			end = ktime_get();
 			time_us = ktime_to_us(ktime_sub(end, start));
-			pr_notice("PROF2 CT2:%d\n", time_us);
+			pr_debug("PROF2 CT2:%d\n", time_us);
 #endif
 		}
 		spin_unlock_irqrestore(&mt_thermal_timer_locker, flags);
@@ -285,7 +285,7 @@ static int mtk_thermal_cpu_pm_notifier(struct notifier_block *nb,
 #if defined(LVTS_CPU_PM_NTFY_PROFILE)
 			end = ktime_get();
 			time_us = ktime_to_us(ktime_sub(end, start));
-			pr_notice("PROF2 ST2:%d\n", time_us);
+			pr_debug("PROF2 ST2:%d\n", time_us);
 #endif
 		}
 		cpumask_clear_cpu(smp_processor_id(), &mt_cpu_pdn_mask);
@@ -310,7 +310,7 @@ static int __init mtk_thermal_pm_init(void)
 
 	ret = cpu_pm_register_notifier(&mtk_thermal_pm);
 
-	pr_notice("[Thermal timer][%s:%d] - Registry thermal pm notify (%d)\n",
+	pr_debug("[Thermal timer][%s:%d] - Registry thermal pm notify (%d)\n",
 		__func__, __LINE__, ret);
 
 	return 0;
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_tsAll.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_tsAll.c
index a58f14b94..30c5500ef 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_tsAll.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_tsAll.c
@@ -66,13 +66,13 @@ struct cooler_data {
 static struct cooler_data g_coolerData[RESERVED_TZS];
 #endif
 
-static int tsallts_debug_log;
+static int tsallts_debug_log = 0;
 
 #define TSALLTS_TEMP_CRIT 120000	/* 120.000 degree Celsius */
 
 #define tsallts_dprintk(fmt, args...)   \
 	do {                                    \
-		if (tsallts_debug_log) {                \
+		if (tsallts_debug_log != 0) {                \
 			pr_debug("[Thermal/TZ/CPUALL]" fmt, ##args);\
 		}                                   \
 	} while (0)
@@ -80,7 +80,7 @@ static int tsallts_debug_log;
 #if AUTO_GEN_COOLERS
 #define clnothings_dprintk(fmt, args...)   \
 	do {                                    \
-		if (tsallts_debug_log) {                \
+		if (tsallts_debug_log != 0) {                \
 			pr_debug("[Thermal/TZ/CLNOTHINGS]" fmt, ##args);\
 		}                                   \
 	} while (0)
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_backlight.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_backlight.c
index 21f4678e0..387232d5c 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_backlight.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_backlight.c
@@ -44,14 +44,14 @@
 int __attribute__ ((weak))
 IMM_IsAdcInitReady(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 int __attribute__ ((weak))
 IMM_GetOneChannelValue(int dwChannel, int data[4], int *rawdata)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 #endif
@@ -1163,7 +1163,7 @@ void mtkts_backlight_prepare_table(int table_num)
 		break;
 	}
 
-	pr_notice("[Thermal/TZ/BACKLIGHT] %s table_num=%d\n",
+	pr_debug("[Thermal/TZ/BACKLIGHT] %s table_num=%d\n",
 						__func__, table_num);
 
 #if 0
@@ -1173,10 +1173,10 @@ void mtkts_backlight_prepare_table(int table_num)
 		for (i = 0; i < (ntc_tbl_size
 					/ sizeof(struct BACKLIGHT_TEMPERATURE));
 		     i++) {
-			pr_notice(
+			pr_debug(
 				"BACKLIGHT_Temperature_Table[%d].APteryTemp =%d\n",
 				i, BACKLIGHT_Temperature_Table[i].BACKLIGHT_Temp);
-			pr_notice(
+			pr_debug(
 				"BACKLIGHT_Temperature_Table[%d].TemperatureR=%d\n",
 				i, BACKLIGHT_Temperature_Table[i].TemperatureR);
 		}
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_battery.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_battery.c
index d28bd8d5a..b2b867c0d 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_battery.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_battery.c
@@ -63,7 +63,7 @@ battery_get_bat_temperature(void)
 	int i;
 
 	for (i = 0; i < 5; i++)
-		pr_notice("[Thermal] E_WF: %s doesn't exist\n", __func__);
+		pr_err("[Thermal] E_WF: %s doesn't exist\n", __func__);
 
 	tsbattery_exit();
 	return -127000;
@@ -219,7 +219,7 @@ static int get_hw_battery_temp(void)
 	prop.intval = -1270;
 	psy = power_supply_get_by_name("battery");
 	if (psy == NULL) {
-			pr_notice("%s can't get battery node\n", __func__);
+			pr_err("%s can't get battery node\n", __func__);
 			return -ENODEV;
 	}
 	power_supply_get_property(psy, POWER_SUPPLY_PROP_TEMP, &prop);
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_bts.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_bts.c
index 327ee2f7f..7ca713a36 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_bts.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_bts.c
@@ -48,13 +48,13 @@
 int __attribute__ ((weak))
 IMM_IsAdcInitReady(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 int __attribute__ ((weak))
 IMM_GetOneChannelValue(int dwChannel, int data[4], int *rawdata)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 
@@ -116,7 +116,7 @@ do {                                    \
 
 
 #define mtkts_bts_printk(fmt, args...) \
-pr_notice("[Thermal/TZ/BTS]" fmt, ##args)
+pr_debug("[Thermal/TZ/BTS]" fmt, ##args)
 
 #if defined(CONFIG_MEDIATEK_MT6577_AUXADC)
 struct iio_channel *thermistor_ch0;
@@ -727,7 +727,7 @@ int mtkts_bts_get_hw_temp(void)
 		t_ret2 = wakeup_ta_algo(TA_CATMPLUS_TTJ);
 
 		if (t_ret2 < 0)
-			pr_notice("[Thermal/TZ/BTS]wakeup_ta_algo %d\n",
+			pr_debug("[Thermal/TZ/BTS]wakeup_ta_algo %d\n",
 				t_ret2);
 	}
 
@@ -1147,7 +1147,7 @@ void mtkts_bts_prepare_table(int table_num)
 		break;
 	}
 
-	pr_notice("[Thermal/TZ/BTS] %s table_num=%d\n", __func__, table_num);
+	pr_debug("[Thermal/TZ/BTS] %s table_num=%d\n", __func__, table_num);
 
 #if 0
 	{
@@ -1155,10 +1155,10 @@ void mtkts_bts_prepare_table(int table_num)
 
 		for (i = 0; i < (ntc_tbl_size
 			/ sizeof(struct BTS_TEMPERATURE)); i++) {
-			pr_notice(
+			pr_debug(
 				"BTS_Temperature_Table[%d].APteryTemp =%d\n", i,
 				BTS_Temperature_Table[i].BTS_Temp);
-			pr_notice(
+			pr_debug(
 				"BTS_Temperature_Table[%d].TemperatureR=%d\n",
 				i, BTS_Temperature_Table[i].TemperatureR);
 		}
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btscharger.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btscharger.c
index d9ab8b2cd..9cee0565c 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btscharger.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btscharger.c
@@ -44,7 +44,7 @@ do { \
 	pr_debug("[Thermal/tzcharger]" fmt, ##args)
 
 #define mtktscharger_pr_notice(fmt, args...) \
-	pr_notice("[Thermal/tzcharger]" fmt, ##args)
+	pr_err("[Thermal/tzcharger]" fmt, ##args)
 
 static kuid_t uid = KUIDT_INIT(0);
 static kgid_t gid = KGIDT_INIT(1000);
@@ -786,10 +786,10 @@ struct thermal_cooling_device *cdev, unsigned long state)
 {
 	cl_dev_sysrst_state = state;
 	if (cl_dev_sysrst_state == 1) {
-		pr_notice("[Thermal/mtktscharger_sysrst] reset, reset, reset!!!\n");
-		pr_notice("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
-		pr_notice("*****************************************\n");
-		pr_notice("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		pr_debug("[Thermal/mtktscharger_sysrst] reset, reset, reset!!!\n");
+		pr_debug("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		pr_debug("*****************************************\n");
+		pr_debug("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
 
 		/* To trigger data abort to reset the system
 		 * for thermal protection.
@@ -859,7 +859,7 @@ void mtkts_btscharger_prepare_table(int table_num)
 		break;
 	}
 
-	pr_notice("[Thermal/TZ/BTSCHARGER] %s table_num=%d\n",
+	pr_debug("[Thermal/TZ/BTSCHARGER] %s table_num=%d\n",
 						__func__, table_num);
 }
 static int mtktscharger_read(struct seq_file *m, void *v)
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsmdpa.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsmdpa.c
index 9ebb722be..fe96e9324 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsmdpa.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsmdpa.c
@@ -46,14 +46,14 @@
 int __attribute__ ((weak))
 IMM_IsAdcInitReady(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 int __attribute__ ((weak))
 IMM_GetOneChannelValue(int dwChannel, int data[4], int *rawdata)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 #endif
@@ -106,7 +106,7 @@ do {                                    \
 } while (0)
 
 #define mtkts_btsmdpa_printk(fmt, args...) \
-pr_notice("[Thermal/TZ/BTSMDPA]" fmt, ##args)
+pr_debug("[Thermal/TZ/BTSMDPA]" fmt, ##args)
 
 
 #if defined(CONFIG_MEDIATEK_MT6577_AUXADC)
@@ -1166,7 +1166,7 @@ void mtkts_btsmdpa_prepare_table(int table_num)
 		break;
 	}
 
-	pr_notice("[Thermal/TZ/BTSMDPA] %s table_num=%d\n",
+	pr_debug("[Thermal/TZ/BTSMDPA] %s table_num=%d\n",
 						__func__, table_num);
 
 #if 0
@@ -1176,10 +1176,10 @@ void mtkts_btsmdpa_prepare_table(int table_num)
 		for (i = 0; i < (ntc_tbl_size
 					/ sizeof(struct BTSMDPA_TEMPERATURE));
 		     i++) {
-			pr_notice(
+			pr_debug(
 				"BTSMDPA_Temperature_Table[%d].APteryTemp =%d\n",
 				i, BTSMDPA_Temperature_Table[i].BTSMDPA_Temp);
-			pr_notice(
+			pr_debug(
 				"BTSMDPA_Temperature_Table[%d].TemperatureR=%d\n",
 				i, BTSMDPA_Temperature_Table[i].TemperatureR);
 		}
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsnrpa.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsnrpa.c
index 042fd4aaa..6cb4c9074 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsnrpa.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_btsnrpa.c
@@ -46,14 +46,14 @@
 int __attribute__ ((weak))
 IMM_IsAdcInitReady(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 int __attribute__ ((weak))
 IMM_GetOneChannelValue(int dwChannel, int data[4], int *rawdata)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return -1;
 }
 #endif
@@ -106,7 +106,7 @@ do {                                    \
 } while (0)
 
 #define mtkts_btsnrpa_printk(fmt, args...) \
-pr_notice("[Thermal/TZ/BTSNRPA]" fmt, ##args)
+pr_debug("[Thermal/TZ/BTSNRPA]" fmt, ##args)
 
 
 #if defined(CONFIG_MEDIATEK_MT6577_AUXADC)
@@ -1166,7 +1166,7 @@ void mtkts_btsnrpa_prepare_table(int table_num)
 		break;
 	}
 
-	pr_notice("[Thermal/TZ/BTSNRPA] %s table_num=%d\n",
+	pr_debug("[Thermal/TZ/BTSNRPA] %s table_num=%d\n",
 						__func__, table_num);
 
 #if 0
@@ -1176,10 +1176,10 @@ void mtkts_btsnrpa_prepare_table(int table_num)
 		for (i = 0; i < (ntc_tbl_size
 					/ sizeof(struct BTSNRPA_TEMPERATURE));
 		     i++) {
-			pr_notice(
+			pr_debug(
 				"BTSNRPA_Temperature_Table[%d].APteryTemp =%d\n",
 				i, BTSNRPA_Temperature_Table[i].BTSNRPA_Temp);
-			pr_notice(
+			pr_debug(
 				"BTSNRPA_Temperature_Table[%d].TemperatureR=%d\n",
 				i, BTSNRPA_Temperature_Table[i].TemperatureR);
 		}
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger.c
index 15aa7e2c7..8b4e09a25 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger.c
@@ -48,7 +48,7 @@ do { \
 	pr_debug("[Thermal/tzcharger]" fmt, ##args)
 
 #define mtktscharger_pr_notice(fmt, args...) \
-	pr_notice("[Thermal/tzcharger]" fmt, ##args)
+	pr_err("[Thermal/tzcharger]" fmt, ##args)
 
 static kuid_t uid = KUIDT_INIT(0);
 static kgid_t gid = KGIDT_INIT(1000);
@@ -406,10 +406,10 @@ struct thermal_cooling_device *cdev, unsigned long state)
 {
 	cl_dev_sysrst_state = state;
 	if (cl_dev_sysrst_state == 1) {
-		pr_notice("[Thermal/mtktscharger_sysrst] reset, reset, reset!!!\n");
-		pr_notice("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
-		pr_notice("*****************************************\n");
-		pr_notice("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		pr_debug("[Thermal/mtktscharger_sysrst] reset, reset, reset!!!\n");
+		pr_debug("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		pr_debug("*****************************************\n");
+		pr_debug("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
 
 		/* To trigger data abort to reset the system
 		 * for thermal protection.
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger2.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger2.c
index 7d1d33ff9..83f9da739 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger2.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_charger2.c
@@ -41,7 +41,7 @@ do { \
 	pr_debug("[Thermal/tzcharger2]" fmt, ##args)
 
 #define mtktscharger2_pr_notice(fmt, args...) \
-	pr_notice("[Thermal/tzcharger2]" fmt, ##args)
+	pr_err("[Thermal/tzcharger2]" fmt, ##args)
 
 static kuid_t uid = KUIDT_INIT(0);
 static kgid_t gid = KGIDT_INIT(1000);
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu.c
index 71f6f8b79..024471f2d 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu.c
@@ -269,14 +269,14 @@ static void temp_valid_unlock(unsigned long *flags);
 unsigned int  __attribute__((weak))
 mt_gpufreq_get_max_power(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	int __attribute__ ((weak))
 IMM_IsAdcInitReady(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 #if 0
@@ -284,13 +284,13 @@ IMM_IsAdcInitReady(void)
 	void __attribute__ ((weak))
 mt_ppm_cpu_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #else
 	void __attribute__ ((weak))
 mt_cpufreq_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #endif
 #endif
@@ -299,7 +299,7 @@ mt_cpufreq_thermal_protect(unsigned int limited_power)
 mtk_get_gpu_loading(unsigned int *pLoading)
 {
 #ifdef CONFIG_MTK_GPU_SUPPORT
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 #endif
 	return 0;
 }
@@ -307,46 +307,46 @@ mtk_get_gpu_loading(unsigned int *pLoading)
 	void __attribute__ ((weak))
 mt_ptp_lock(unsigned long *flags)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 
 	void __attribute__ ((weak))
 mt_ptp_unlock(unsigned long *flags)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 
 	void __attribute__ ((weak))
 mt_cpufreq_thermal_5A_limit(bool enable)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 
 	unsigned int __attribute__ ((weak))
 mt_gpufreq_get_cur_freq(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	unsigned int __attribute__ ((weak))
 mt_ppm_thermal_get_max_power(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	unsigned int  __attribute__((weak))
 mt_gpufreq_get_seg_max_opp_index(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	unsigned int  __attribute__((weak))
 mt_gpufreq_get_dvfs_table_num(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -549,7 +549,7 @@ struct thermal_zone_device *thermal, struct thermal_cooling_device *cdev)
 	}
 
 	if (mtk_thermal_zone_bind_cooling_device(thermal, table_val, cdev)) {
-		tscpu_warn("%s error binding cooling dev\n", __func__);
+		pr_err("%s error binding cooling dev\n", __func__);
 		return -EINVAL;
 	}
 
@@ -601,7 +601,7 @@ struct thermal_zone_device *thermal, struct thermal_cooling_device *cdev)
 
 
 	if (thermal_zone_unbind_cooling_device(thermal, table_val, cdev)) {
-		tscpu_warn("%s error unbinding cooling dev\n", __func__);
+		pr_err("%s error unbinding cooling dev\n", __func__);
 		return -EINVAL;
 	}
 
@@ -704,13 +704,13 @@ static int tscpu_get_temp(struct thermal_zone_device *thermal, int *t)
 		ts_temp = get_immediate_ts4_wrap();
 		if (ts_temp > leave_hpm_temp && ts_temp != CLEAR_TEMP) {
 			if (vcorefs_get_kicker_opp(KIR_THERMAL) != OPPI_UNREQ) {
-				tscpu_warn("ts4: temp=%d leave HPM\n", ts_temp);
+				pr_debug("ts4: temp=%d leave HPM\n", ts_temp);
 				r = vcorefs_request_dvfs_opp(KIR_THERMAL,
 								OPPI_UNREQ);
 			}
 		} else if (ts_temp < enter_hpm_temp && ts_temp != CLEAR_TEMP) {
 			if (vcorefs_get_kicker_opp(KIR_THERMAL) != OPPI_PERF) {
-				tscpu_warn("ts4: temp=%d enter HPM\n", ts_temp);
+				pr_debug("ts4: temp=%d enter HPM\n", ts_temp);
 				r = vcorefs_request_dvfs_opp(KIR_THERMAL,
 								OPPI_PERF);
 			}
@@ -772,12 +772,12 @@ static int tscpu_get_temp(struct thermal_zone_device *thermal, int *t)
 	if (curr_temp >= thermal_5A_limit_H && thermal_6353_5A_status == 0) {
 		mt_ppm_set_5A_limit_throttle(1);
 		thermal_6353_5A_status = 1;
-		/*tscpu_warn("mt_ppm_set_5A_limit_throttle(1)\n");*/
+		/*pr_debug("mt_ppm_set_5A_limit_throttle(1)\n");*/
 	} else if (curr_temp < thermal_5A_limit_L
 	&& thermal_6353_5A_status == 1) {
 		mt_ppm_set_5A_limit_throttle(0);
 		thermal_6353_5A_status = 0;
-		/*tscpu_warn("mt_ppm_set_5A_limit_throttle(0)\n");*/
+		/*pr_debug("mt_ppm_set_5A_limit_throttle(0)\n");*/
 	}
 #endif
 
@@ -1295,7 +1295,7 @@ struct file *file, const char __user *buffer, size_t count, loff_t *data)
 	if ((trip1 >= 0) && (trip2 >= 0)) {
 		enter_hpm_temp = trip1;
 		leave_hpm_temp = trip2;
-		tscpu_warn(
+		pr_debug(
 			"%s applied enter_hpm: %d , leave_hpm: %d\n", __func__,
 			enter_hpm_temp, leave_hpm_temp);
 	} else {
@@ -1304,7 +1304,7 @@ struct file *file, const char __user *buffer, size_t count, loff_t *data)
 
 	if (set_enable) {
 		enable_hpm_temp = !!(enable);
-		tscpu_warn("%s enable: %d (%d)\n", __func__,
+		pr_debug("%s enable: %d (%d)\n", __func__,
 						enable_hpm_temp, enable);
 	}
 
@@ -1746,7 +1746,7 @@ struct platform_device *dev, pm_message_t state)
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(50);
@@ -1758,7 +1758,7 @@ struct platform_device *dev, pm_message_t state)
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(2);
@@ -1832,7 +1832,7 @@ static int tscpu_thermal_resume(struct platform_device *dev)
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(50);
@@ -1844,7 +1844,7 @@ static int tscpu_thermal_resume(struct platform_device *dev)
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(2);
@@ -1919,7 +1919,7 @@ static int ktp_thread(void *arg)
 		bank0_T = tscpu_max_temperature();
 		max_temp = bank0_T;
 
-		tscpu_warn("%s temp=%d\n", __func__, max_temp);
+		pr_debug("%s temp=%d\n", __func__, max_temp);
 
 		if ((temp_tc_mid_trip > -275000)
 		&& (max_temp >= (temp_tc_mid_trip - 5000))) {
@@ -2280,16 +2280,16 @@ static int thermal_auxadc_get_data(int times, int channel)
 {
 	int ret = 0, data[4], i, ret_value = 0, ret_temp = 0;
 
-	pr_notice("Thermal_auxadc_get_data\n");
+	pr_debug("Thermal_auxadc_get_data\n");
 
 	if (IMM_IsAdcInitReady() == 0) {
-		pr_notice("[%s]: AUXADC is not ready\n", __func__);
+		pr_err("[%s]: AUXADC is not ready\n", __func__);
 		return 0;
 	}
 
 	for (i = 0; i < times; i++) {
 		ret_value = IMM_GetOneChannelValue(channel, data, &ret_temp);
-		pr_notice("[%s]: raw%d= %d\n", __func__, i,
+		pr_debug("[%s]: raw%d= %d\n", __func__, i,
 								ret_temp);
 		ret += ret_temp;
 	}
@@ -2315,7 +2315,7 @@ static void tscpu_thermal_pause(void)
 	do {
 		temp = (readl(THAHBST0) >> 16);
 		if ((cnt + 1) % 10 == 0)
-			pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
+			pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
 								__LINE__);
 
 		udelay(50);
@@ -2327,7 +2327,7 @@ static void tscpu_thermal_pause(void)
 	do {
 		temp = (readl(THAHBST0) >> 16);
 		if ((cnt + 1) % 10 == 0)
-			pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
+			pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
 								__LINE__);
 
 		udelay(2);
@@ -2378,7 +2378,7 @@ static void tscpu_thermal_release(void)
 	do {
 		temp = (readl(THAHBST0) >> 16);
 		if ((cnt + 1) % 10 == 0)
-			pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
+			pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
 								__LINE__);
 
 		udelay(50);
@@ -2390,7 +2390,7 @@ static void tscpu_thermal_release(void)
 	do {
 		temp = (readl(THAHBST0) >> 16);
 		if ((cnt + 1) % 10 == 0)
-			pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
+			pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n", temp, cnt,
 								__LINE__);
 
 		udelay(2);
@@ -2833,14 +2833,14 @@ static int tscpu_thermal_probe(struct platform_device *dev)
 				tscpu_thermal_all_bank_interrupt_handler,
 				IRQF_TRIGGER_LOW, THERMAL_NAME, NULL);
 	if (err)
-		tscpu_warn("tscpu_init IRQ register fail\n");
+		pr_err("tscpu_init IRQ register fail\n");
 #else
 	err =
 		request_irq(THERM_CTRL_IRQ_BIT_ID,
 				tscpu_thermal_all_bank_interrupt_handler,
 				IRQF_TRIGGER_LOW, THERMAL_NAME, NULL);
 	if (err)
-		tscpu_warn("tscpu_init IRQ register fail\n");
+		pr_err("tscpu_init IRQ register fail\n");
 #endif
 
 	tscpu_config_all_tc_hw_protect(trip_temp[0], tc_mid_trip);
@@ -2894,13 +2894,13 @@ static int __init tscpu_init(void)
 #endif
 	err = platform_driver_register(&mtk_thermal_driver);
 	if (err) {
-		tscpu_warn("thermal driver callback register failed..\n");
+		pr_err("thermal driver callback register failed..\n");
 		return err;
 	}
 
 	err = tscpu_register_thermal();
 	if (err) {
-		tscpu_warn("tscpu_register_thermal fail\n");
+		pr_err("tscpu_register_thermal fail\n");
 		goto err_unreg;
 	}
 
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu_noBank.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu_noBank.c
index d9d9af8bc..9beb0859b 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu_noBank.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_cpu_noBank.c
@@ -278,7 +278,7 @@ static int g_is_TempOutsideNormalRange;
 	unsigned int  __attribute__((weak))
 mt_gpufreq_get_max_power(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -286,7 +286,7 @@ mt_gpufreq_get_max_power(void)
 int __attribute__ ((weak))
 IMM_IsAdcInitReady(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 #endif
@@ -296,13 +296,13 @@ IMM_IsAdcInitReady(void)
 	void __attribute__ ((weak))
 mt_ppm_cpu_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #else
 	void __attribute__ ((weak))
 mt_cpufreq_thermal_protect(unsigned int limited_power)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 #endif
 #endif
@@ -311,7 +311,7 @@ mt_cpufreq_thermal_protect(unsigned int limited_power)
 mtk_get_gpu_loading(unsigned int *pLoading)
 {
 #ifdef CONFIG_MTK_GPU_SUPPORT
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 #endif
 	return 0;
 }
@@ -319,46 +319,46 @@ mtk_get_gpu_loading(unsigned int *pLoading)
 	void __attribute__ ((weak))
 mt_ptp_lock(unsigned long *flags)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 
 	void __attribute__ ((weak))
 mt_ptp_unlock(unsigned long *flags)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 
 	void __attribute__ ((weak))
 mt_cpufreq_thermal_5A_limit(bool enable)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 }
 
 	unsigned int __attribute__ ((weak))
 mt_gpufreq_get_cur_freq(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	unsigned int __attribute__ ((weak))
 mt_ppm_thermal_get_max_power(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	unsigned int  __attribute__((weak))
 mt_gpufreq_get_seg_max_opp_index(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
 	unsigned int  __attribute__((weak))
 mt_gpufreq_get_dvfs_table_num(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 
@@ -513,7 +513,7 @@ static int tscpu_bind
 	}
 
 	if (mtk_thermal_zone_bind_cooling_device(thermal, table_val, cdev)) {
-		tscpu_warn("%s error binding cooling dev\n", __func__);
+		pr_err("%s error binding cooling dev\n", __func__);
 		return -EINVAL;
 	}
 
@@ -565,7 +565,7 @@ static int tscpu_unbind
 
 
 	if (thermal_zone_unbind_cooling_device(thermal, table_val, cdev)) {
-		tscpu_warn("%s error unbinding cooling dev\n", __func__);
+		pr_err("%s error unbinding cooling dev\n", __func__);
 		return -EINVAL;
 	}
 
@@ -1138,7 +1138,7 @@ static ssize_t tscpu_write_sspm_thermal_throttle
 	int sspm_thermal_throttle_switch;
 	int len = 0;
 
-	tscpu_warn("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	len = (count < (sizeof(desc) - 1)) ? count : (sizeof(desc) - 1);
 	if (copy_from_user(desc, buffer, len))
@@ -1150,7 +1150,7 @@ static ssize_t tscpu_write_sspm_thermal_throttle
 		tscpu_sspm_thermal_throttle =
 			sspm_thermal_throttle_switch;
 
-		tscpu_warn("%s , %d\n", __func__,
+		pr_debug("%s , %d\n", __func__,
 			tscpu_sspm_thermal_throttle);
 
 		lvts_ipi_send_sspm_thermal_thtottle();
@@ -1688,7 +1688,7 @@ static int tscpu_thermal_suspend
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(50);
@@ -1702,7 +1702,7 @@ static int tscpu_thermal_suspend
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(2);
@@ -1738,7 +1738,7 @@ static int tscpu_thermal_suspend
 	do_gettimeofday(&end);
 
 	/* Get milliseconds */
-	pr_notice("suspend time spent, sec : %lu , usec : %lu\n",
+	pr_debug("suspend time spent, sec : %lu , usec : %lu\n",
 						(end.tv_sec - begin.tv_sec),
 						(end.tv_usec - begin.tv_usec));
 #endif
@@ -1825,7 +1825,7 @@ static int tscpu_thermal_resume(struct platform_device *dev)
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(50);
@@ -1839,7 +1839,7 @@ static int tscpu_thermal_resume(struct platform_device *dev)
 		do {
 			temp = (readl(THAHBST0) >> 16);
 			if ((cnt + 1) % 10 == 0)
-				pr_notice("THAHBST0 = 0x%x, cnt = %d, %d\n",
+				pr_debug("THAHBST0 = 0x%x, cnt = %d, %d\n",
 							temp, cnt, __LINE__);
 
 			udelay(2);
@@ -1927,7 +1927,7 @@ static int ktp_thread(void *arg)
 
 		max_temp = tscpu_max_temperature();
 
-		tscpu_warn("%s temp=%d\n", __func__, max_temp);
+		pr_debug("%s temp=%d\n", __func__, max_temp);
 
 		if ((temp_tc_mid_trip > -275000)
 			&& (max_temp >= (temp_tc_mid_trip - 5000))) {
@@ -2309,7 +2309,7 @@ int tscpu_is_temp_valid(void)
 	if (g_is_temp_valid == 0) {
 		check_all_temp_valid();
 		if (g_is_temp_valid == 1)
-			tscpu_warn(
+			pr_debug(
 				"Driver is ready to report valid temperatures\n");
 	}
 
@@ -2541,7 +2541,7 @@ static void init_thermal(void)
 	while (cnt < 50) {
 		temp = (readl(THAHBST0) >> 16);
 		if ((cnt + 1) % 10 == 0)
-			pr_notice("THAHBST0 = 0x%x,cnt=%d, %d\n", temp, cnt,
+			pr_debug("THAHBST0 = 0x%x,cnt=%d, %d\n", temp, cnt,
 								__LINE__);
 
 		if (temp == 0x0) {
@@ -2555,7 +2555,7 @@ static void init_thermal(void)
 	}
 	thermal_disable_all_periodoc_temp_sensing();	/* TEMPMONCTL0 */
 
-	/* pr_notice(KERN_CRIT "cnt = %d, %d\n",cnt,__LINE__); */
+	/* pr_debug(KERN_CRIT "cnt = %d, %d\n",cnt,__LINE__); */
 
 	/*Normal initial */
 	tscpu_thermal_initial_all_tc();
@@ -2712,7 +2712,7 @@ static int tscpu_thermal_probe(struct platform_device *dev)
 				IRQF_TRIGGER_NONE, THERMAL_NAME, NULL);
 
 	if (err)
-		tscpu_warn("tscpu_init IRQ register fail\n");
+		pr_err("tscpu_init IRQ register fail\n");
 #else
 	err = request_irq(THERM_CTRL_IRQ_BIT_ID,
 #if CFG_LVTS_DOMINATOR
@@ -2725,7 +2725,7 @@ static int tscpu_thermal_probe(struct platform_device *dev)
 				IRQF_TRIGGER_LOW, THERMAL_NAME, NULL);
 
 	if (err)
-		tscpu_warn("tscpu_init IRQ register fail\n");
+		pr_err("tscpu_init IRQ register fail\n");
 #endif /* CONFIG_OF */
 
 #if CFG_LVTS_DOMINATOR
@@ -2747,13 +2747,13 @@ static int tscpu_thermal_probe(struct platform_device *dev)
 #if DUMP_VCORE_VOLTAGE
 	vcore_reg_id = regulator_get(&dev->dev, "vcore");
 	if (!vcore_reg_id)
-		tscpu_warn("regulator_get vcore_reg_id failed\n");
+		pr_err("regulator_get vcore_reg_id failed\n");
 #endif
 #endif
 
 	err = tscpu_register_thermal();
 	if (err) {
-		tscpu_warn("tscpu_register_thermal fail\n");
+		pr_err("tscpu_register_thermal fail\n");
 		return err;
 	}
 
@@ -2773,7 +2773,7 @@ static int __init tscpu_init(void)
 
 	err = platform_driver_register(&mtk_thermal_driver);
 	if (err) {
-		tscpu_warn("thermal driver callback register failed..\n");
+		pr_err("thermal driver callback register failed..\n");
 		return err;
 	}
 
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_dctm.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_dctm.c
index 9ddc425a4..a36233706 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_dctm.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_dctm.c
@@ -290,7 +290,7 @@ static int mtkts_dctm_get_temp(struct thermal_zone_device *thermal, int *t)
 	}
 
 	if (t_ret < 0)
-		pr_notice("%s, wakeup_ta_algo out of memory\n", __func__);
+		pr_err("%s, wakeup_ta_algo out of memory\n", __func__);
 
 	if ((int)*t >= polling_trip_temp1)
 		thermal->polling_delay = interval * 1000;
@@ -979,7 +979,7 @@ static int __init mtkts_dctm_init(void)
 #ifdef CONFIG_PM
 	ret = register_pm_notifier(&dctm_pm_notifier_func);
 	if (ret)
-		pr_notice("Failed to register dctm PM notifier.\n");
+		pr_err("Failed to register dctm PM notifier.\n");
 #endif
 	return 0;
 }
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_imgsensor.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_imgsensor.c
index 836a12cb6..c8f7384f0 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_imgsensor.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_imgsensor.c
@@ -43,7 +43,7 @@ enum CAMERA_DUAL_CAMERA_SENSOR_ENUM senDevId, MUINT8 *valid, MUINT32 *temp)
 {
 	*valid = SENSOR_TEMPERATURE_CANNOT_SEARCH_SENSOR;
 	*temp = -127;
-	pr_notice("[Thermal/TZ/IMGS] E_WF: %s doesn't exist\n", __func__);
+	pr_err("[Thermal/TZ/IMGS] E_WF: %s doesn't exist\n", __func__);
 
 	return -1;
 }
@@ -62,12 +62,12 @@ enum CAMERA_DUAL_CAMERA_SENSOR_ENUM senDevId, MUINT8 *valid, MUINT32 *temp)
 #define mtk_imgs_dprintk(fmt, args...)   \
 	do {                                    \
 		if (mtk_imgs_debug_log) {                \
-			pr_notice("[Thermal/TZ/IMGS]" fmt, ##args);\
+			pr_debug("[Thermal/TZ/IMGS]" fmt, ##args);\
 		}                                   \
 	} while (0)
 
 #define mtk_imgs_printk(fmt, args...)   \
-	pr_notice("[Thermal/TZ/IMGS]" fmt, ##args)
+	pr_debug("[Thermal/TZ/IMGS]" fmt, ##args)
 /*=============================================================
  * Function prototype
  *=============================================================
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_tsx.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_tsx.c
index 6c50bb429..fa07fc358 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_tsx.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_tsx.c
@@ -81,7 +81,7 @@ struct thermal_zone_device *thermal, unsigned long *t)
 {
 	*t = mtktstsx_get_hw_temp();
 	mtktstsx_cur_temp = *t;
-/*	pr_notice("[mtktstsx_cur_temp] Raw=%d\n", mtktstsx_cur_temp);*/
+/*	pr_debug("[mtktstsx_cur_temp] Raw=%d\n", mtktstsx_cur_temp);*/
 
 
 	thermal->polling_delay = interval * 1000;
diff --git a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_wmt.c b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_wmt.c
index bb4848437..f065d0041 100644
--- a/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_wmt.c
+++ b/drivers/misc/mediatek/thermal/common/thermal_zones/mtk_ts_wmt.c
@@ -39,7 +39,7 @@
 int __attribute__ ((weak))
 mtk_wcn_cmb_stub_query_ctrl(void)
 {
-	pr_notice("E_WF: %s doesn't exist\n", __func__);
+	pr_err("E_WF: %s doesn't exist\n", __func__);
 	return 0;
 }
 /*=============================================================*/
diff --git a/drivers/misc/mediatek/thermal/mt6785/inc/tscpu_settings.h b/drivers/misc/mediatek/thermal/mt6785/inc/tscpu_settings.h
index 2b641c29c..3b76f2877 100644
--- a/drivers/misc/mediatek/thermal/mt6785/inc/tscpu_settings.h
+++ b/drivers/misc/mediatek/thermal/mt6785/inc/tscpu_settings.h
@@ -46,10 +46,10 @@
 	do {                                    \
 		thermal_diff_us = thermal_cTime_us - thermal_pTime_us;	\
 		if (thermal_diff_us > THERMAL_TIME_TH) {                \
-			pr_notice(TSCPU_LOG_TAG "%s: %llu us\n", __func__, \
+			pr_debug(TSCPU_LOG_TAG "%s: %llu us\n", __func__, \
 							thermal_diff_us); \
 		} else if (thermal_diff_us < 0) {	\
-			pr_notice(TSCPU_LOG_TAG \
+			pr_warn(TSCPU_LOG_TAG \
 				"Warning: tProfiling uses incorrect %s %d\n", \
 				__func__, __LINE__); \
 		}	\
@@ -580,12 +580,12 @@ extern void lvts_dump_time_profiling_result(struct seq_file *m);
 #define tscpu_dprintk(fmt, args...)	\
 	do {					\
 		if (tscpu_debug_log == 1) {	\
-			pr_notice(TSCPU_LOG_TAG fmt, ##args);	\
+			pr_debug(TSCPU_LOG_TAG fmt, ##args);	\
 		}	\
 	} while (0)
 
-#define tscpu_printk(fmt, args...)	pr_notice(TSCPU_LOG_TAG fmt, ##args)
-#define tscpu_warn(fmt, args...)	pr_notice(TSCPU_LOG_TAG fmt, ##args)
+#define tscpu_printk(fmt, args...)	pr_debug(TSCPU_LOG_TAG fmt, ##args)
+#define tscpu_warn(fmt, args...)	pr_warn(TSCPU_LOG_TAG fmt, ##args)
 
 /*
  * Support LVTS
@@ -594,16 +594,16 @@ extern void lvts_dump_time_profiling_result(struct seq_file *m);
 #define LVTS_LOG_TAG            "[Thermal/TZ/LVTS]"
 #define LVTS_LOG_REG_TAG        "[Thermal/TZ/LVTSREG]"
 
-#define lvts_reg_print(fmt, args...)	pr_notice(LVTS_LOG_REG_TAG fmt, ##args)
-#define lvts_printk(fmt, args...)	pr_notice(LVTS_LOG_TAG fmt, ##args)
-#define lvts_warn(fmt, args...)		pr_notice(LVTS_LOG_TAG fmt, ##args)
+#define lvts_reg_print(fmt, args...)	pr_debug(LVTS_LOG_REG_TAG fmt, ##args)
+#define lvts_printk(fmt, args...)	pr_debug(LVTS_LOG_TAG fmt, ##args)
+#define lvts_warn(fmt, args...)		pr_warn(LVTS_LOG_TAG fmt, ##args)
 #if 0
-#define lvts_dbg_printk(fmt, args...)  pr_notice(LVTS_LOG_TAG fmt, ##args)
+#define lvts_dbg_printk(fmt, args...)  pr_debug(LVTS_LOG_TAG fmt, ##args)
 #else
 #define lvts_dbg_printk(fmt, args...)   \
 	do {                                    \
 		if (lvts_debug_log == 1) {                \
-			pr_notice(LVTS_LOG_TAG fmt, ##args); \
+			pr_debug(LVTS_LOG_TAG fmt, ##args); \
 		}                                   \
 	} while (0)
 #endif
diff --git a/drivers/misc/mediatek/thermal/mt6785/inc/tspmic_settings.h b/drivers/misc/mediatek/thermal/mt6785/inc/tspmic_settings.h
index 90c1857e8..52bd40c3b 100644
--- a/drivers/misc/mediatek/thermal/mt6785/inc/tspmic_settings.h
+++ b/drivers/misc/mediatek/thermal/mt6785/inc/tspmic_settings.h
@@ -31,13 +31,13 @@
 #define y_pmic_repeat_times	1
 #define THERMAL_USE_IIO_CHANNEL
 
-#define mtktspmic_info(fmt, args...)   pr_info("[Thermal/TZ/PMIC] " fmt, ##args)
+#define mtktspmic_info(fmt, args...)   pr_debug("[Thermal/TZ/PMIC] " fmt, ##args)
 
 
 #define mtktspmic_dprintk(fmt, args...)   \
 	do {								\
 		if (mtktspmic_debug_log == 1) {				\
-			pr_notice("[Thermal/TZ/PMIC] " fmt, ##args); \
+			pr_debug("[Thermal/TZ/PMIC] " fmt, ##args); \
 		}							\
 	} while (0)
 
diff --git a/drivers/misc/mediatek/thermal/mt6785/src/mtk_lvts_tc.c b/drivers/misc/mediatek/thermal/mt6785/src/mtk_lvts_tc.c
index 33bf607d2..af9d97e14 100644
--- a/drivers/misc/mediatek/thermal/mt6785/src/mtk_lvts_tc.c
+++ b/drivers/misc/mediatek/thermal/mt6785/src/mtk_lvts_tc.c
@@ -1436,7 +1436,7 @@ void lvts_wait_for_all_sensing_point_idle(void)
 			break;
 
 		if ((cnt + 1) % 10 == 0) {
-			pr_notice("Cnt = %d LVTS TC %d, LVTSMSRCTL1[10,7,0] = %d,%d,%d\n",
+			pr_debug("Cnt = %d LVTS TC %d, LVTSMSRCTL1[10,7,0] = %d,%d,%d\n",
 					cnt + 1, (temp >> 16),
 					((temp & _BIT_(2)) >> 2),
 					((temp & _BIT_(1)) >> 1),
diff --git a/drivers/misc/mediatek/thermal/mt6785/src/mtk_tc.c b/drivers/misc/mediatek/thermal/mt6785/src/mtk_tc.c
index 45d2d350f..d6406b4ae 100644
--- a/drivers/misc/mediatek/thermal/mt6785/src/mtk_tc.c
+++ b/drivers/misc/mediatek/thermal/mt6785/src/mtk_tc.c
@@ -199,19 +199,19 @@ static void set_tc_trigger_hw_protect
 	void __attribute__ ((weak))
 mt_ptp_lock(unsigned long *flags)
 {
-	pr_notice("[Power/CPU_Thermal]%s doesn't exist\n", __func__);
+	pr_err("[Power/CPU_Thermal]%s doesn't exist\n", __func__);
 }
 
 	void __attribute__ ((weak))
 mt_ptp_unlock(unsigned long *flags)
 {
-	pr_notice("[Power/CPU_Thermal]%s doesn't exist\n", __func__);
+	pr_err("[Power/CPU_Thermal]%s doesn't exist\n", __func__);
 }
 
 	int __attribute__ ((weak))
 get_wd_api(struct wd_api **obj)
 {
-	pr_notice("[Power/CPU_Thermal]%s doesn't exist\n", __func__);
+	pr_err("[Power/CPU_Thermal]%s doesn't exist\n", __func__);
 	return -1;
 }
 
@@ -339,56 +339,56 @@ void eDataCorrector(void)
 {
 
 	if (g_adc_ge_t < 265 || g_adc_ge_t > 758) {
-		tscpu_warn("[thermal] Bad efuse data, g_adc_ge_t\n");
+		pr_err("[thermal] Bad efuse data, g_adc_ge_t\n");
 		g_adc_ge_t = 512;
 	}
 	if (g_adc_oe_t < 265 || g_adc_oe_t > 758) {
-		tscpu_warn("[thermal] Bad efuse data, g_adc_oe_t\n");
+		pr_err("[thermal] Bad efuse data, g_adc_oe_t\n");
 		g_adc_oe_t = 512;
 	}
 	if (g_o_vtsmcu0 < -8 || g_o_vtsmcu0 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu1\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu1\n");
 		g_o_vtsmcu0 = 260;
 	}
 	if (g_o_vtsmcu1 < -8 || g_o_vtsmcu1 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu1\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu1\n");
 		g_o_vtsmcu1 = 260;
 	}
 	if (g_o_vtsmcu2 < -8 || g_o_vtsmcu2 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu2\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu2\n");
 		g_o_vtsmcu2 = 260;
 	}
 	/* There is no g_o_vtsmcu3 in MT6785 compared with MT6779 */
 	if (g_o_vtsmcu4 < -8 || g_o_vtsmcu4 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu4\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu4\n");
 		g_o_vtsmcu4 = 260;
 	}
 	if (g_o_vtsmcu5 < -8 || g_o_vtsmcu5 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu5\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu5\n");
 		g_o_vtsmcu5 = 260;
 	}
 	if (g_o_vtsmcu6 < -8 || g_o_vtsmcu6 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu6\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu6\n");
 		g_o_vtsmcu6 = 260;
 	}
 	if (g_o_vtsmcu7 < -8 || g_o_vtsmcu7 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu7\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu7\n");
 		g_o_vtsmcu7 = 260;
 	}
 	if (g_o_vtsmcu8 < -8 || g_o_vtsmcu8 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu8\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu8\n");
 		g_o_vtsmcu8 = 260;
 	}
 	if (g_o_vtsmcu9 < -8 || g_o_vtsmcu9 > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsmcu8\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsmcu8\n");
 		g_o_vtsmcu9 = 260;
 	}
 	if (g_o_vtsabb < -8 || g_o_vtsabb > 484) {
-		tscpu_warn("[thermal] Bad efuse data, g_o_vtsabb\n");
+		pr_err("[thermal] Bad efuse data, g_o_vtsabb\n");
 		g_o_vtsabb = 260;
 	}
 	if (g_degc_cali < 1 || g_degc_cali > 63) {
-		tscpu_warn("[thermal] Bad efuse data, g_degc_cali\n");
+		pr_err("[thermal] Bad efuse data, g_degc_cali\n");
 		g_degc_cali = 40;
 	}
 }
@@ -402,10 +402,10 @@ void tscpu_thermal_cal_prepare(void)
 	temp3 = get_devinfo_with_index(ADDRESS_INDEX_3); /* 01AC */
 	temp4 = get_devinfo_with_index(ADDRESS_INDEX_4); /* 01B0 */
 
-	pr_notice(
+	pr_debug(
 		"[calibration] tmp0=0x%x, tmp1=0x%x, tmp2=0x%x\n",
 		temp0, temp1, temp2);
-	pr_notice(
+	pr_debug(
 		"[calibration] tmp3=0x%x, tmp4=0x%x\n",
 		temp3, temp4);
 
@@ -1094,7 +1094,7 @@ int tscpu_thermal_fast_init(int tc_num)
 	temp = readl(offset + TEMPMSR0) & 0x0fff;
 	while (temp != THERMAL_INIT_VALUE && cunt < 20) {
 		cunt++;
-		/* pr_notice("[Power/CPU_Thermal]0 temp=%d,cunt=%d\n",
+		/* pr_debug("[Power/CPU_Thermal]0 temp=%d,cunt=%d\n",
 		 *					temp,cunt);
 		 */
 		temp = readl(offset + TEMPMSR0) & 0x0fff;
@@ -1104,7 +1104,7 @@ int tscpu_thermal_fast_init(int tc_num)
 	temp = readl(offset + TEMPMSR1) & 0x0fff;
 	while (temp != THERMAL_INIT_VALUE && cunt < 20) {
 		cunt++;
-		/* pr_notice("[Power/CPU_Thermal]1 temp=%d,cunt=%d\n",
+		/* pr_debug("[Power/CPU_Thermal]1 temp=%d,cunt=%d\n",
 		 *					temp,cunt);
 		 */
 		temp = readl(offset + TEMPMSR1) & 0x0fff;
@@ -1114,7 +1114,7 @@ int tscpu_thermal_fast_init(int tc_num)
 	temp = readl(offset + TEMPMSR2) & 0x0fff;
 	while (temp != THERMAL_INIT_VALUE && cunt < 20) {
 		cunt++;
-		/* pr_notice("[Power/CPU_Thermal]2 temp=%d,cunt=%d\n",
+		/* pr_debug("[Power/CPU_Thermal]2 temp=%d,cunt=%d\n",
 		 *					temp,cunt);
 		 */
 		temp = readl(offset + TEMPMSR2) & 0x0fff;
@@ -1124,7 +1124,7 @@ int tscpu_thermal_fast_init(int tc_num)
 	temp = readl(offset + TEMPMSR3) & 0x0fff;
 	while (temp != THERMAL_INIT_VALUE && cunt < 20) {
 		cunt++;
-		/* pr_notice("[Power/CPU_Thermal]3 temp=%d,cunt=%d\n",
+		/* pr_debug("[Power/CPU_Thermal]3 temp=%d,cunt=%d\n",
 		 *					temp,cunt);
 		 */
 		temp = readl(offset + TEMPMSR3) & 0x0fff;
@@ -1337,7 +1337,7 @@ void tscpu_config_all_tc_hw_protect(int temperature, int temperature2)
 	do_gettimeofday(&end);
 
 	/* Get milliseconds */
-	pr_notice("resume time spent, sec : %lu , usec : %lu\n",
+	pr_debug("resume time spent, sec : %lu , usec : %lu\n",
 						(end.tv_sec - begin.tv_sec),
 						(end.tv_usec - begin.tv_usec));
 #endif
diff --git a/drivers/misc/mediatek/thermal/mtk_cooler_backlight.c b/drivers/misc/mediatek/thermal/mtk_cooler_backlight.c
index a2c4d2670..f0ef4b432 100644
--- a/drivers/misc/mediatek/thermal/mtk_cooler_backlight.c
+++ b/drivers/misc/mediatek/thermal/mtk_cooler_backlight.c
@@ -27,7 +27,7 @@
 #include "mt-plat/mtk_thermal_monitor.h"
 
 #define mtk_cooler_backlight_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/backlight " fmt, ##args)
+	pr_debug("thermal/cooler/backlight " fmt, ##args)
 
 #define BACKLIGHT_COOLER_NR 3
 
diff --git a/drivers/misc/mediatek/thermal/mtk_cooler_backlight_cus.c b/drivers/misc/mediatek/thermal/mtk_cooler_backlight_cus.c
index 96f8e4f93..0a1ee16dd 100644
--- a/drivers/misc/mediatek/thermal/mtk_cooler_backlight_cus.c
+++ b/drivers/misc/mediatek/thermal/mtk_cooler_backlight_cus.c
@@ -30,7 +30,7 @@
 #define MAX_BACKLIGHT_BRIGHTNESS 100
 
 #define mtk_cooler_backlight_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/backlight " fmt, ##args)
+	pr_debug("thermal/cooler/backlight " fmt, ##args)
 
 
 static struct thermal_cooling_device
diff --git a/drivers/misc/mediatek/thermal/mtk_cooler_cam.c b/drivers/misc/mediatek/thermal/mtk_cooler_cam.c
index b1bdef6cb..ab12d18d4 100644
--- a/drivers/misc/mediatek/thermal/mtk_cooler_cam.c
+++ b/drivers/misc/mediatek/thermal/mtk_cooler_cam.c
@@ -35,12 +35,12 @@ static kuid_t uid = KUIDT_INIT(0);
 static kgid_t gid = KGIDT_INIT(1000);
 
 #define mtk_cooler_cam_dprintk_always(fmt, args...) \
-pr_notice("[Thermal/TC/cam]" fmt, ##args)
+pr_debug("[Thermal/TC/cam]" fmt, ##args)
 
 #define mtk_cooler_cam_dprintk(fmt, args...) \
 do { \
 	if (cl_cam_klog_on == 1) \
-		pr_notice("[Thermal/TC/cam]" fmt, ##args); \
+		pr_debug("[Thermal/TC/cam]" fmt, ##args); \
 } while (0)
 
 
diff --git a/drivers/misc/mediatek/thermal/mtk_cooler_flashlight_cus.c b/drivers/misc/mediatek/thermal/mtk_cooler_flashlight_cus.c
index ecd912f42..a43919cfc 100644
--- a/drivers/misc/mediatek/thermal/mtk_cooler_flashlight_cus.c
+++ b/drivers/misc/mediatek/thermal/mtk_cooler_flashlight_cus.c
@@ -29,7 +29,7 @@
 #include "flashlight-core.h"
 
 #define mtk_cooler_flashlight_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/flashlight " fmt, ##args)
+	pr_debug("thermal/cooler/flashlight " fmt, ##args)
 
 #define FLASHLIGHT_COOLER_NR 1
 
diff --git a/drivers/misc/mediatek/thermal/mtk_cooler_kshutdown.c b/drivers/misc/mediatek/thermal/mtk_cooler_kshutdown.c
index 51045f6a2..e169a6807 100644
--- a/drivers/misc/mediatek/thermal/mtk_cooler_kshutdown.c
+++ b/drivers/misc/mediatek/thermal/mtk_cooler_kshutdown.c
@@ -29,7 +29,7 @@
 
 #if 1
 #define mtk_cooler_kshutdown_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/kshutdown " fmt, ##args)
+	pr_debug("thermal/cooler/kshutdown " fmt, ##args)
 #else
 #define mtk_cooler_kshutdown_dprintk(fmt, args...)
 #endif
diff --git a/drivers/misc/mediatek/thermal/mtk_cooler_shutdown.c b/drivers/misc/mediatek/thermal/mtk_cooler_shutdown.c
index 7fbf3f7ab..6912c5148 100644
--- a/drivers/misc/mediatek/thermal/mtk_cooler_shutdown.c
+++ b/drivers/misc/mediatek/thermal/mtk_cooler_shutdown.c
@@ -45,7 +45,7 @@
 
 #if 1
 #define mtk_cooler_shutdown_dprintk(fmt, args...)	\
-	pr_notice("thermal/cooler/shutdown " fmt, ##args)
+	pr_debug("thermal/cooler/shutdown " fmt, ##args)
 #else
 #define mtk_cooler_shutdown_dprintk(fmt, args...)
 #endif
diff --git a/drivers/misc/mediatek/thermal/mtk_thermal_monitor.c b/drivers/misc/mediatek/thermal/mtk_thermal_monitor.c
index dbfa9aff4..d7ce318e6 100644
--- a/drivers/misc/mediatek/thermal/mtk_thermal_monitor.c
+++ b/drivers/misc/mediatek/thermal/mtk_thermal_monitor.c
@@ -175,12 +175,12 @@ static kgid_t gid = KGIDT_INIT(1000);
 #define THRML_LOG(fmt, args...) \
 	do { \
 		if (unlikely(enable_ThermalMonitorXlog)) { \
-			pr_notice("THERMAL/MONITOR " fmt, ##args); \
+			pr_debug("THERMAL/MONITOR " fmt, ##args); \
 		} \
 	} while (0)
 
 
-#define THRML_ERROR_LOG(fmt, args...) pr_notice("THERMAL/MONITOR " fmt, ##args)
+#define THRML_ERROR_LOG(fmt, args...) pr_err("THERMAL/MONITOR " fmt, ##args)
 
 /* ************************************ */
 /* Define */
diff --git a/drivers/misc/mediatek/trusted_mem/Makefile.configs b/drivers/misc/mediatek/trusted_mem/Makefile.configs
index 3be10e9ae..d1636515b 100644
--- a/drivers/misc/mediatek/trusted_mem/Makefile.configs
+++ b/drivers/misc/mediatek/trusted_mem/Makefile.configs
@@ -38,7 +38,7 @@ endif
 #==========================================================================
 # Dump Option Settings
 #==========================================================================
-$(info TCORE_UT_TESTS_SUPPORT = $(TCORE_UT_TESTS_SUPPORT))
-$(info TCORE_PROFILING_SUPPORT = $(TCORE_PROFILING_SUPPORT))
-$(info TCORE_PROFILING_AUTO_DUMP = $(TCORE_PROFILING_AUTO_DUMP))
-$(info TCORE_MEMORY_LEAK_DETECTION_SUPPORT = $(TCORE_MEMORY_LEAK_DETECTION_SUPPORT))
+#$(info TCORE_UT_TESTS_SUPPORT = $(TCORE_UT_TESTS_SUPPORT))
+#$(info TCORE_PROFILING_SUPPORT = $(TCORE_PROFILING_SUPPORT))
+#$(info TCORE_PROFILING_AUTO_DUMP = $(TCORE_PROFILING_AUTO_DUMP))
+#$(info TCORE_MEMORY_LEAK_DETECTION_SUPPORT = $(TCORE_MEMORY_LEAK_DETECTION_SUPPORT))
diff --git a/drivers/misc/mediatek/video/mt6785/videox/disp_drv_log.h b/drivers/misc/mediatek/video/mt6785/videox/disp_drv_log.h
index 2fe3a0010..8c85b6e44 100644
--- a/drivers/misc/mediatek/video/mt6785/videox/disp_drv_log.h
+++ b/drivers/misc/mediatek/video/mt6785/videox/disp_drv_log.h
@@ -27,19 +27,19 @@
 	do {								\
 		dprec_logger_pr(DPREC_LOGGER_DEBUG, string, ##args);	\
 		if (g_mobilelog)					\
-			pr_info("[DISP]"string, ##args);		\
+			pr_debug("[DISP]"string, ##args);		\
 	} while (0)
 
 #define DISPMSG(string, args...)					\
 	do {								\
 		dprec_logger_pr(DPREC_LOGGER_DEBUG, string, ##args);	\
-		pr_info("[DISP]"string, ##args);			\
+		pr_debug("[DISP]"string, ##args);			\
 	} while (0)
 
 #define DISPCHECK(string, args...)					\
 	do {								\
 		dprec_logger_pr(DPREC_LOGGER_DEBUG, string, ##args);	\
-		pr_info("[DISP]"string, ##args);			\
+		pr_debug("[DISP]"string, ##args);			\
 	} while (0)
 
 #define DISP_ONESHOT_DUMP(string, args...)				\
@@ -51,7 +51,7 @@
 #define DISP_PR_INFO(string, args...)					\
 	do {								\
 		dprec_logger_pr(DPREC_LOGGER_ERROR, string, ##args);	\
-		pr_info("[DISP][%s #%d]warn:"string,			\
+		pr_warn("[DISP][%s #%d]warn:"string,			\
 				__func__, __LINE__, ##args);		\
 	} while (0)
 
@@ -79,7 +79,7 @@
 	do {								\
 		dprec_logger_pr(DPREC_LOGGER_DEBUG, "func|%s\n", __func__); \
 		if (g_mobilelog)					\
-			pr_info("%s line:%d", __func__, __LINE__);\
+			pr_debug("%s line:%d", __func__, __LINE__);\
 	} while (0)
 
 #define DISPDBGFUNC() DISPFUNC()
diff --git a/drivers/misc/mediatek/video/mt6785/videox/disp_recovery.c b/drivers/misc/mediatek/video/mt6785/videox/disp_recovery.c
index 8572c5876..adf3098da 100644
--- a/drivers/misc/mediatek/video/mt6785/videox/disp_recovery.c
+++ b/drivers/misc/mediatek/video/mt6785/videox/disp_recovery.c
@@ -1129,7 +1129,7 @@ static int primary_display_check_recovery_worker_kthread(void *data)
 	struct sched_param param = { .sched_priority = 87 };
 	int ret = 0;
 	int i = 0;
-	int esd_try_cnt = 5;
+	int esd_try_cnt = 1;
 	int recovery_done = 0;
 
 	DISPFUNC();
@@ -1169,7 +1169,6 @@ static int primary_display_check_recovery_worker_kthread(void *data)
 			DISP_PR_ERR(
 				"[ESD]LCM recover fail. Try time:%d. Disable esd check\n",
 				    esd_try_cnt);
-			primary_display_esd_check_enable(0);
 		} else if (recovery_done == 1) {
 			DISPCHECK("[ESD]esd recovery success\n");
 			recovery_done = 0;
diff --git a/drivers/misc/mediatek/video/mt6785/videox/primary_display.c b/drivers/misc/mediatek/video/mt6785/videox/primary_display.c
index 1b735780c..98ac0a5b5 100644
--- a/drivers/misc/mediatek/video/mt6785/videox/primary_display.c
+++ b/drivers/misc/mediatek/video/mt6785/videox/primary_display.c
@@ -148,6 +148,9 @@ static int osc_last_stat;
 static bool has_rsz_input;
 static bool has_yuv_input;
 
+static uint display_framerate_main;
+static uint display_framerate_ext;
+
 #if 0
 /* global variable for idle manager */
 static unsigned long long idlemgr_last_kick_time = ~(0ULL);
@@ -847,6 +850,7 @@ static unsigned int _fps_ctx_get_avg_fps(struct fps_ctx_t *fps_ctx)
 	if (fps_ctx->cur_wnd_sz == 0)
 		return 0;
 	avg_fps = fps_ctx->total / fps_ctx->cur_wnd_sz;
+	display_framerate_main = avg_fps;
 	return avg_fps;
 }
 
@@ -856,6 +860,7 @@ static unsigned int _fps_ctx_get_avg_fps_ext(struct fps_ctx_t *fps_ctx,
 	unsigned int avg_fps;
 
 	avg_fps = (fps_ctx->total + abs_fps) / (fps_ctx->cur_wnd_sz + 1);
+	display_framerate_ext = avg_fps;
 	return avg_fps;
 }
 
@@ -3740,38 +3745,6 @@ static int _ovl_fence_release_callback(unsigned long userdata)
 #endif
 	_primary_path_unlock(__func__);
 
-	/* debug: check last ovl status: should be idle when config */
-	if (primary_display_is_video_mode() &&
-	    !primary_display_is_decouple_mode()) {
-		unsigned int status = 0;
-
-#ifdef DEBUG_OVL_CONFIG_TIME
-		unsigned int time_event = 0;
-		unsigned int time_event1 = 0;
-		unsigned int time_event2 = 0;
-
-		cmdqBackupReadSlot(pgc->ovl_config_time, 0, &time_event);
-		cmdqBackupReadSlot(pgc->ovl_config_time, 1, &time_event1);
-		cmdqBackupReadSlot(pgc->ovl_config_time, 2, &time_event2);
-		DISPMSG(
-			"ovl config time_event %d time_event1 %d time_event2 %d time1_diff  %d  time2_diff %d\n",
-			time_event, time_event1, time_event2,
-			time_event1 - time_event, time_event2 - time_event1);
-#endif
-
-		cmdqBackupReadSlot(pgc->ovl_status_info, 0, &status);
-		if (status & 0x1) {
-			/* ovl is not idle! */
-			DISP_PR_ERR("disp ovl status error! stat=0x%x\n",
-				    status);
-			/* disp_aee_print("ovl_stat 0x%x\n", status); */
-			mmprofile_log_ex(ddp_mmp_get_events()->primary_error,
-					 MMPROFILE_FLAG_PULSE, status, 0);
-			primary_display_diagnose(__func__, __LINE__);
-			ret = -1;
-		}
-	}
-
 	/* fence release */
 	for (i = 0; i < PRIMARY_SESSION_INPUT_LAYER_COUNT; i++) {
 		int fence_idx = 0;
@@ -11405,3 +11378,5 @@ int primary_display_set_panel_param(unsigned int param)
 	return ret;
 }
 
+module_param(display_framerate_main, uint, 0664);
+module_param(display_framerate_ext, uint, 0664);
\ No newline at end of file
diff --git a/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_helper_ext.h b/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_helper_ext.h
index d9b519af1..05e3cb78a 100644
--- a/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_helper_ext.h
+++ b/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_helper_ext.h
@@ -79,14 +79,14 @@ struct DumpFirstErrorStruct {
 
 #define CMDQ_LOG(string, args...) \
 do {			\
-	pr_notice("[CMDQ]"string, ##args); \
+	pr_debug("[CMDQ]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ]"string, ##args); \
 } while (0)
 
 #define CMDQ_MSG(string, args...) \
 do {			\
 	if (cmdq_core_should_print_msg()) { \
-		pr_notice("[CMDQ]"string, ##args); \
+		pr_debug("[CMDQ]"string, ##args); \
 	} \
 } while (0)
 
@@ -100,7 +100,7 @@ do { \
 
 #define CMDQ_ERR(string, args...) \
 do {			\
-	pr_notice("[CMDQ][ERR]"string, ##args); \
+	pr_err("[CMDQ][ERR]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ][ERR]"string, ##args); \
 } while (0)
 
@@ -116,7 +116,7 @@ if (status < 0)		\
 do {			\
 	char dispatchedTag[50]; \
 	snprintf(dispatchedTag, 50, "CRDISPATCH_KEY:%s", tag); \
-	pr_notice("[CMDQ][AEE]"string, ##args); \
+	pr_debug("[CMDQ][AEE]"string, ##args); \
 	cmdq_core_save_first_dump("[CMDQ][AEE]"string, ##args); \
 	cmdq_core_turnoff_first_dump(); \
 	aee_kernel_warning_api(__FILE__, __LINE__, \
diff --git a/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_mdp_common.c b/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_mdp_common.c
index 35a799785..ade9c2822 100644
--- a/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_mdp_common.c
+++ b/drivers/misc/mediatek/video/mt6853/cmdq/v3/cmdq_mdp_common.c
@@ -72,7 +72,7 @@ struct plist_head qos_isp_module_request_list[MDP_TOTAL_THREAD];
 #define CMDQ_LOG_PMQOS(string, args...) \
 do {			\
 	if (cmdq_core_should_pmqos_log()) { \
-		pr_notice("[CMDQ][MDP]"string, ##args); \
+		pr_debug("[CMDQ][MDP]"string, ##args); \
 	} \
 } while (0)
 
diff --git a/drivers/misc/mediatek/vpu/2.0/vpu_algo.c b/drivers/misc/mediatek/vpu/2.0/vpu_algo.c
index 9301e4215..0f0251d1c 100644
--- a/drivers/misc/mediatek/vpu/2.0/vpu_algo.c
+++ b/drivers/misc/mediatek/vpu/2.0/vpu_algo.c
@@ -168,7 +168,7 @@ int vpu_get_algo_id_by_name(int core, char *name)
 	}
 
 	algo_id = algo->id[core];
-	LOG_INF("vpu(%d)_get algo_id:%d\n", core, algo_id);
+	LOG_DBG("vpu(%d)_get algo_id:%d\n", core, algo_id);
 	return algo_id;
 
 out:
@@ -245,7 +245,7 @@ int vpu_create_algo(int core, char *name,
 	LOG_DBG("[vpu] vpu_hw_load_algo done, (%d/0x%lx/0x%x)\n",
 		id, (unsigned long)mva, length);
 
-	LOG_INF("[vpu_%d] vpu_hw_load_algo done, (%d/0x%lx/0x%x)\n",
+	LOG_DBG("[vpu_%d] vpu_hw_load_algo done, (%d/0x%lx/0x%x)\n",
 		core, algo->id[core],
 		(unsigned long)(algo->bin_ptr), algo->bin_length);
 
@@ -264,7 +264,7 @@ int vpu_create_algo(int core, char *name,
 			goto out;
 		}
 
-		LOG_INF("[vpu_%d] vpu_hw_get_algo_info done\n", core);
+		LOG_DBG("[vpu_%d] vpu_hw_get_algo_info done\n", core);
 
 		ret = vpu_calc_prop_offset(algo->info_descs,
 				algo->info_desc_count, &algo->info_length);
@@ -273,7 +273,7 @@ int vpu_create_algo(int core, char *name,
 			goto out;
 		}
 
-		LOG_INF("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
+		LOG_DBG("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
 				core,
 				"algo->info_length", algo->info_length);
 
@@ -284,7 +284,7 @@ int vpu_create_algo(int core, char *name,
 			goto out;
 		}
 
-		LOG_INF("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
+		LOG_DBG("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
 				core,
 				"algo->sett_length", algo->sett_length);
 	}
diff --git a/drivers/misc/mediatek/vpu/2.0/vpu_cmn.h b/drivers/misc/mediatek/vpu/2.0/vpu_cmn.h
index 248208f95..e73f6264e 100644
--- a/drivers/misc/mediatek/vpu/2.0/vpu_cmn.h
+++ b/drivers/misc/mediatek/vpu/2.0/vpu_cmn.h
@@ -528,10 +528,10 @@ bool vpu_is_idle(int core);
 #define LOG_DBG(format, args...)
 #endif
 #define LOG_INF(format, args...)    pr_info(VPU_TAG " " format, ##args)
-#define LOG_WRN(format, args...)    pr_info(VPU_TAG "[warn] " format, ##args)
-#define LOG_ERR(format, args...)    pr_info(VPU_TAG "[error] " format, ##args)
+#define LOG_WRN(format, args...)    pr_warn(VPU_TAG "[warn] " format, ##args)
+#define LOG_ERR(format, args...)    pr_error(VPU_TAG "[error] " format, ##args)
 
-#define PRINT_LINE() pr_info(VPU_TAG " %s (%s:%d)\n", \
+#define PRINT_LINE() pr_debug(VPU_TAG " %s (%s:%d)\n", \
 						__func__,  __FILE__, __LINE__)
 
 #define vpu_print_seq(seq_file, format, args...) \
diff --git a/drivers/misc/mediatek/vpu/2.0/vpu_dbg.c b/drivers/misc/mediatek/vpu/2.0/vpu_dbg.c
index 77362b7e6..709df98a8 100644
--- a/drivers/misc/mediatek/vpu/2.0/vpu_dbg.c
+++ b/drivers/misc/mediatek/vpu/2.0/vpu_dbg.c
@@ -166,7 +166,7 @@ static void vpu_test_wpp(void)
 	/* compare with golden */
 	ret = memcmp(buf_va + img_size,
 				g_datadst_640x360_golden_wpp, img_size);
-	LOG_INF("comparison result:%d", ret);
+	LOG_DBG("comparison result:%d", ret);
 	vpu_save_file("/data/vpu_result_wpp.raw",
 				buf_va + img_size, img_size);
 
@@ -253,7 +253,7 @@ static void vpu_test_be_true(void)
 	 */
 	memset(buf_va, 0x2, width * height);
 	ret = memcmp(buf_va, buf_va + width * height, width * height);
-	LOG_INF("vpu test: comparison result=%d and param5=%d",
+	LOG_DBG("vpu test: comparison result=%d and param5=%d",
 			ret, sett->param5);
 
 	vpu_free_request(req);
@@ -429,7 +429,7 @@ static int vpu_test_set(void *data, u64 val)
 	/* CHRISTODO */
 	int TEMP_CORE = 0;
 
-	LOG_INF("%s:val=%llu\n", __func__, val);
+	LOG_DBG("%s:val=%llu\n", __func__, val);
 
 	switch (val) {
 	case 0:
@@ -437,11 +437,11 @@ static int vpu_test_set(void *data, u64 val)
 		break;
 	case 1:
 		vpu_boot_up(TEMP_CORE);
-		LOG_INF("[vpu_%d] vpu_boot_up\n", TEMP_CORE);
+		LOG_DBG("[vpu_%d] vpu_boot_up\n", TEMP_CORE);
 		break;
 	case 2:
 		vpu_shut_down(TEMP_CORE);
-		LOG_INF("[vpu_%d] vpu_shut_down\n", TEMP_CORE);
+		LOG_DBG("[vpu_%d] vpu_shut_down\n", TEMP_CORE);
 		break;
 
 	case 10 ... 39: /* use algo's id to load algo */
@@ -451,14 +451,14 @@ static int vpu_test_set(void *data, u64 val)
 		if (vpu_find_algo_by_id(TEMP_CORE, id, &algo)) {
 			LOG_DBG("vpu test: algo(%d) is not existed\n", id);
 		} else {
-			LOG_INF("vpu test: load algo(%d)\n", id);
+			LOG_DBG("vpu test: load algo(%d)\n", id);
 
 			if (vpu_hw_load_algo(TEMP_CORE, algo)) {
 				LOG_ERR("[vpu_%d] vpu_hw_load_algo failed!\n\n",
 						TEMP_CORE);
 			}
 
-			LOG_INF("[vpu_%d] vpu_hw_load_algo done\n", TEMP_CORE);
+			LOG_DBG("[vpu_%d] vpu_hw_load_algo done\n", TEMP_CORE);
 		}
 
 		break;
@@ -559,7 +559,7 @@ static int vpu_test_set(void *data, u64 val)
 		vpu_user_test_case3(NULL);
 		break;
 	default:
-		LOG_INF("%s error,val=%llu\n", __func__, val);
+		LOG_DBG("%s error,val=%llu\n", __func__, val);
 	}
 
 	test_value = val;
@@ -580,7 +580,7 @@ DEFINE_SIMPLE_ATTRIBUTE(vpu_debug_test_fops, vpu_test_get,
 static int vpu_log_level_set(void *data, u64 val)
 {
 	g_vpu_log_level = val & 0xf;
-	LOG_INF("g_vpu_log_level: %d\n", g_vpu_log_level);
+	LOG_DBG("g_vpu_log_level: %d\n", g_vpu_log_level);
 
 	return 0;
 }
@@ -598,7 +598,7 @@ DEFINE_SIMPLE_ATTRIBUTE(vpu_debug_log_level_fops, vpu_log_level_get,
 static int vpu_internal_log_level_set(void *data, u64 val)
 {
 	g_vpu_internal_log_level = val;
-	LOG_INF("g_vpu_internal_log_level: %d\n", g_vpu_internal_log_level);
+	LOG_DBG("g_vpu_internal_log_level: %d\n", g_vpu_internal_log_level);
 
 	return 0;
 }
@@ -619,7 +619,7 @@ DEFINE_SIMPLE_ATTRIBUTE(vpu_debug_internal_log_level_fops,
 static int vpu_func_mask_set(void *data, u64 val)
 {
 	g_func_mask = val & 0xffffffff;
-	LOG_INF("g_func_mask: 0x%x\n", g_func_mask);
+	LOG_DBG("g_func_mask: 0x%x\n", g_func_mask);
 
 	return 0;
 }
diff --git a/drivers/misc/mediatek/vpu/2.0/vpu_drv.c b/drivers/misc/mediatek/vpu/2.0/vpu_drv.c
index 795e45187..a37e6a5fa 100644
--- a/drivers/misc/mediatek/vpu/2.0/vpu_drv.c
+++ b/drivers/misc/mediatek/vpu/2.0/vpu_drv.c
@@ -253,7 +253,7 @@ struct ion_handle *vpu_hw_ion_import_handle(struct ion_client *client, int fd)
 	}
 
 	if (g_vpu_log_level > Log_STATE_MACHINE)
-		LOG_INF("[vpu] ion_import_handle(0x%p)\n", handle);
+		LOG_DBG("[vpu] ion_import_handle(0x%p)\n", handle);
 
 	return handle;
 }
@@ -311,7 +311,7 @@ int vpu_put_request_to_pool(struct vpu_user *user, struct vpu_request *req)
 				return -EINVAL;
 			} else {
 				if (g_vpu_log_level > Log_STATE_MACHINE)
-					LOG_INF("[vpu_drv]cnt_%d,%s=0x%p\n",
+					LOG_DBG("[vpu_drv]cnt_%d,%s=0x%p\n",
 						cnt,
 						"ion_import_dma_buf handle",
 						handle);
@@ -537,7 +537,7 @@ int vpu_get_request_from_queue(struct vpu_user *user,
 		}
 
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] %s (%d)\n", __func__, get);
+			LOG_DBG("[vpu] %s (%d)\n", __func__, get);
 		if (get)
 			list_del_init(vlist_link(req, struct vpu_request));
 
@@ -595,7 +595,7 @@ bool vpu_is_available(void)
 
 
 	if (pool_wait_size != 0) {
-		LOG_INF("common pool size = %d, no empty vpu \r\n",
+		LOG_DBG("common pool size = %d, no empty vpu \r\n",
 			pool_wait_size);
 
 		return false;
@@ -609,13 +609,13 @@ bool vpu_is_available(void)
 
 		mutex_unlock(&vpu_device->servicepool_mutex[i]);
 
-		LOG_INF("vpu_%d, pool size = %d\r\n", i, pool_wait_size);
+		LOG_DBG("vpu_%d, pool size = %d\r\n", i, pool_wait_size);
 		if ((pool_wait_size == 0) && vpu_is_idle(i)) {
-			LOG_INF("vpu_%d, is available !!\r\n", i);
+			LOG_DBG("vpu_%d, is available !!\r\n", i);
 			return true;
 		}
 	}
-	LOG_INF("GG, no vpu available !!\r\n");
+	LOG_DBG("GG, no vpu available !!\r\n");
 
 	return false;
 
@@ -661,7 +661,7 @@ int vpu_delete_user(struct vpu_user *user)
 		vpu_hw_unlock(user);
 
 	mutex_lock(&vpu_device->user_mutex);
-	LOG_INF("deleted user[0x%lx]\n", (unsigned long)(user->id));
+	LOG_DBG("deleted user[0x%lx]\n", (unsigned long)(user->id));
 	list_del(vlist_link(user, struct vpu_user));
 	mutex_unlock(&vpu_device->user_mutex);
 
@@ -786,7 +786,7 @@ static int vpu_open(struct inode *inode, struct file *flip)
 		return -ENODEV;
 	}
 
-	LOG_INF("vpu_support core : 0x%x\n", efuse_data);
+	LOG_DBG("vpu_support core : 0x%x\n", efuse_data);
 
 	vpu_create_user(&user);
 	if (IS_ERR_OR_NULL(user)) {
@@ -795,7 +795,7 @@ static int vpu_open(struct inode *inode, struct file *flip)
 	}
 
 	user->id = (unsigned long *)user;
-	LOG_INF("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
+	LOG_DBG("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
 		vpu_num_users,
 		(unsigned long)(user->id),
 		user->open_pid, user->open_tgid);
@@ -868,7 +868,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		struct vpu_request *u_req;
 
 		/*if (g_vpu_log_level > VpuLogThre_PERFORMANCE)*/
-		LOG_INF("[vpu] VPU_IOCTL_ENQUE_REQUEST +\n");
+		LOG_DBG("[vpu] VPU_IOCTL_ENQUE_REQUEST +\n");
 
 		ret = vpu_alloc_request(&req);
 		if (ret) {
@@ -932,7 +932,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		/* free the request, error happened here*/
 		vpu_free_request(req);
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] .VPU_IOCTL_ENQUE_REQUEST - ");
+			LOG_DBG("[vpu] .VPU_IOCTL_ENQUE_REQUEST - ");
 		ret = -EFAULT;
 		break;
 	}
@@ -943,7 +943,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		struct vpu_request *u_req;
 
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] VPU_IOCTL_DEQUE_REQUEST + ");
+			LOG_DBG("[vpu] VPU_IOCTL_DEQUE_REQUEST + ");
 
 		u_req = (struct vpu_request *) arg;
 		#if 1
@@ -982,7 +982,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			goto out;
 		}
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] VPU_IOCTL_DEQUE_REQUEST - ");
+			LOG_DBG("[vpu] VPU_IOCTL_DEQUE_REQUEST - ");
 		break;
 	}
 	case VPU_IOCTL_FLUSH_REQUEST:
@@ -1131,7 +1131,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		dev_debug_info->open_tgid = user->open_tgid;
 
 		if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-			LOG_INF("[%s] user:%s/%d. pid(%d/%d)\n",
+			LOG_DBG("[%s] user:%s/%d. pid(%d/%d)\n",
 				"VPU_IOCTL_OPEN_DEV_NOTICE",
 				dev_debug_info->callername,
 				dev_debug_info->dev_fd,
@@ -1172,7 +1172,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			dbg_info = vlist_node_of(head,
 						struct vpu_dev_debug_info);
 			if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-				LOG_INF("[%s] req_user-> = %s/%d, %d/%d\n",
+				LOG_DBG("[%s] req_user-> = %s/%d, %d/%d\n",
 					"VPU_IOCTL_CLOSE_DEV_NOTICE",
 					dbg_info->callername,
 					dbg_info->dev_fd, dbg_info->open_pid,
@@ -1188,7 +1188,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		}
 
 		if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-			LOG_INF("[%s] user:%d. pid(%d/%d), get(%d)\n",
+			LOG_DBG("[%s] user:%d. pid(%d/%d), get(%d)\n",
 					"VPU_IOCTL_CLOSE_DEV_NOTICE",
 					dev_fd, user->open_pid,
 					user->open_tgid, get);
@@ -1301,7 +1301,7 @@ static int vpu_release(struct inode *inode, struct file *flip)
 {
 	struct vpu_user *user = flip->private_data;
 
-	LOG_INF("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
+	LOG_DBG("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
 		vpu_num_users,
 		(unsigned long)(user->id),
 		user->open_pid, user->open_tgid);
@@ -1326,7 +1326,7 @@ static int vpu_mmap(struct file *flip, struct vm_area_struct *vma)
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	pfn = vma->vm_pgoff << PAGE_SHIFT;
 
-	LOG_INF("%s:%s=0x%lx,%s=0x%x,%s=0x%lx,%s=0x%lx,%s=0x%lx,%s=0x%lx\n",
+	LOG_DBG("%s:%s=0x%lx,%s=0x%x,%s=0x%lx,%s=0x%lx,%s=0x%lx,%s=0x%lx\n",
 			__func__,
 			"vm_pgoff", vma->vm_pgoff,
 			"pfn", pfn,
@@ -1413,7 +1413,7 @@ static int vpu_probe(struct platform_device *pdev)
 	smi_node = NULL;
 
 	if (core == MTK_VPU_CORE) {
-		LOG_INF("%s(%d), core(%d) = core(%d)+2 in FPGA, return\n",
+		LOG_DBG("%s(%d), core(%d) = core(%d)+2 in FPGA, return\n",
 			"vpu_num_devs", vpu_num_devs, core, MTK_VPU_CORE);
 		return ret;
 	}
@@ -1426,7 +1426,7 @@ static int vpu_probe(struct platform_device *pdev)
 
 	node = pdev->dev.of_node;
 	vpu_device->dev[vpu_num_devs] = &pdev->dev;
-	LOG_INF("probe 0, pdev id = %d name = %s, name = %s\n",
+	LOG_DBG("probe 0, pdev id = %d name = %s, name = %s\n",
 			pdev->id, pdev->name,
 			pdev->dev.of_node->name);
 
@@ -1471,7 +1471,7 @@ static int vpu_probe(struct platform_device *pdev)
 	/* emulator will fill vpu_base and bin_base */
 	vpu_init_emulator(vpu_device);
 #else
-	LOG_INF("[vpu] core/total : %d/%d\n", core, MTK_VPU_CORE);
+	LOG_DBG("[vpu] core/total : %d/%d\n", core, MTK_VPU_CORE);
 	vpu_device->vpu_base[core] = (unsigned long) of_iomap(node, 0);
 	/* get physical address of binary data loaded by LK */
 	if (vpu_num_devs == 0) {
@@ -1490,7 +1490,7 @@ static int vpu_probe(struct platform_device *pdev)
 		vpu_device->bin_pa = phy_addr;
 		vpu_device->bin_size = phy_size;
 
-		LOG_INF("probe core:%d, %s=0x%lx %s=0x%x, %s=0x%x\n",
+		LOG_DBG("probe core:%d, %s=0x%lx %s=0x%x, %s=0x%x\n",
 			core,
 			"bin_base", (unsigned long)vpu_device->bin_base,
 			"phy_addr", phy_addr,
@@ -1510,7 +1510,7 @@ static int vpu_probe(struct platform_device *pdev)
 		vpu_device->vpu_syscfg_base =
 				(unsigned long) of_iomap(ipu_conn_node, 0);
 
-		LOG_INF("probe, smi_cmn_base: 0x%lx, ipu_conn:0x%lx\n",
+		LOG_DBG("probe, smi_cmn_base: 0x%lx, ipu_conn:0x%lx\n",
 				vpu_device->smi_cmn_base,
 				vpu_device->vpu_syscfg_base);
 	}
diff --git a/drivers/misc/mediatek/vpu/3.0/vpu_algo.c b/drivers/misc/mediatek/vpu/3.0/vpu_algo.c
index 7a0507a79..3e61c0e2b 100644
--- a/drivers/misc/mediatek/vpu/3.0/vpu_algo.c
+++ b/drivers/misc/mediatek/vpu/3.0/vpu_algo.c
@@ -248,7 +248,7 @@ int vpu_get_algo_id_by_name(int core_s, char *name, struct vpu_user *user)
 	}
 
 	algo_id = algo->id[core];
-	LOG_INF("vpu(%d)_get algo_id:%d\n", core, algo_id);
+	LOG_DBG("vpu(%d)_get algo_id:%d\n", core, algo_id);
 	return algo_id;
 
 out:
@@ -326,7 +326,7 @@ int vpu_create_algo(int core_s, char *name,
 	LOG_DBG("[vpu] vpu_hw_load_algo done, (%d/0x%lx/0x%x)\n",
 		id, (unsigned long)mva, length);
 
-	LOG_INF("[vpu_%d] vpu_hw_load_algo done, (%d/0x%lx/0x%x)\n",
+	LOG_DBG("[vpu_%d] vpu_hw_load_algo done, (%d/0x%lx/0x%x)\n",
 		core, algo->id[core],
 		(unsigned long)(algo->bin_ptr), algo->bin_length);
 
@@ -345,7 +345,7 @@ int vpu_create_algo(int core_s, char *name,
 			goto out;
 		}
 
-		LOG_INF("[vpu_%d] vpu_hw_get_algo_info done\n", core);
+		LOG_DBG("[vpu_%d] vpu_hw_get_algo_info done\n", core);
 
 		ret = vpu_calc_prop_offset(algo->info_descs,
 				algo->info_desc_count, &algo->info_length);
@@ -354,7 +354,7 @@ int vpu_create_algo(int core_s, char *name,
 			goto out;
 		}
 
-		LOG_INF("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
+		LOG_DBG("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
 				core,
 				"algo->info_length", algo->info_length);
 
@@ -365,7 +365,7 @@ int vpu_create_algo(int core_s, char *name,
 			goto out;
 		}
 
-		LOG_INF("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
+		LOG_DBG("[vpu_%d] vpu_calc_prop_offset done, %s(0x%x)\n",
 				core,
 				"algo->sett_length", algo->sett_length);
 	}
diff --git a/drivers/misc/mediatek/vpu/3.0/vpu_cmn.h b/drivers/misc/mediatek/vpu/3.0/vpu_cmn.h
index 1ddd8d4e2..e43cb94ce 100644
--- a/drivers/misc/mediatek/vpu/3.0/vpu_cmn.h
+++ b/drivers/misc/mediatek/vpu/3.0/vpu_cmn.h
@@ -602,13 +602,13 @@ bool vpu_is_idle(int core);
 
 #define LOG_DVFS(format, args...) \
 	do { if (g_vpu_log_level > Log_STATE_MACHINE) \
-		pr_info(VPU_TAG " " format, ##args); \
+		pr_debug(VPU_TAG " " format, ##args); \
 	} while (0)
 #define LOG_INF(format, args...)    pr_info(VPU_TAG " " format, ##args)
-#define LOG_WRN(format, args...)    pr_info(VPU_TAG "[warn] " format, ##args)
-#define LOG_ERR(format, args...)    pr_info(VPU_TAG "[error] " format, ##args)
+#define LOG_WRN(format, args...)    pr_warn(VPU_TAG "[warn] " format, ##args)
+#define LOG_ERR(format, args...)    pr_err(VPU_TAG "[error] " format, ##args)
 
-#define PRINT_LINE() pr_info(VPU_TAG " %s (%s:%d)\n", \
+#define PRINT_LINE() pr_debug(VPU_TAG " %s (%s:%d)\n", \
 						__func__,  __FILE__, __LINE__)
 
 #define vpu_print_seq(seq_file, format, args...) \
diff --git a/drivers/misc/mediatek/vpu/3.0/vpu_dbg.c b/drivers/misc/mediatek/vpu/3.0/vpu_dbg.c
index b010f4d5a..9bcc51afa 100644
--- a/drivers/misc/mediatek/vpu/3.0/vpu_dbg.c
+++ b/drivers/misc/mediatek/vpu/3.0/vpu_dbg.c
@@ -43,7 +43,7 @@ static ssize_t vpu_debug_vpu_memory_write(struct file *filp,
 static int vpu_log_level_set(void *data, u64 val)
 {
 	g_vpu_log_level = val & 0xf;
-	LOG_INF("g_vpu_log_level: %d\n", g_vpu_log_level);
+	LOG_DBG("g_vpu_log_level: %d\n", g_vpu_log_level);
 
 	return 0;
 }
@@ -61,7 +61,7 @@ DEFINE_SIMPLE_ATTRIBUTE(vpu_debug_log_level_fops, vpu_log_level_get,
 static int vpu_internal_log_level_set(void *data, u64 val)
 {
 	g_vpu_internal_log_level = val;
-	LOG_INF("g_vpu_internal_log_level: %d\n", g_vpu_internal_log_level);
+	LOG_DBG("g_vpu_internal_log_level: %d\n", g_vpu_internal_log_level);
 
 	return 0;
 }
@@ -81,7 +81,7 @@ DEFINE_SIMPLE_ATTRIBUTE(vpu_debug_internal_log_level_fops,
 static int vpu_func_mask_set(void *data, u64 val)
 {
 	g_func_mask = val & 0xffffffff;
-	LOG_INF("g_func_mask: 0x%x\n", g_func_mask);
+	LOG_DBG("g_func_mask: 0x%x\n", g_func_mask);
 
 	return 0;
 }
diff --git a/drivers/misc/mediatek/vpu/3.0/vpu_drv.c b/drivers/misc/mediatek/vpu/3.0/vpu_drv.c
index 5fc7563cd..3c733c1b8 100644
--- a/drivers/misc/mediatek/vpu/3.0/vpu_drv.c
+++ b/drivers/misc/mediatek/vpu/3.0/vpu_drv.c
@@ -258,7 +258,7 @@ struct ion_handle *vpu_hw_ion_import_handle(struct ion_client *client, int fd)
 	}
 
 	if (g_vpu_log_level > Log_STATE_MACHINE)
-		LOG_INF("[vpu] ion_import_handle(0x%p)\n", handle);
+		LOG_DBG("[vpu] ion_import_handle(0x%p)\n", handle);
 
 	return handle;
 }
@@ -324,7 +324,7 @@ int vpu_put_request_to_pool(struct vpu_user *user, struct vpu_request *req)
 				return -EINVAL;
 			} else {
 				if (g_vpu_log_level > Log_STATE_MACHINE)
-					LOG_INF("[vpu_drv]cnt_%d,%s=0x%p\n",
+					LOG_DBG("[vpu_drv]cnt_%d,%s=0x%p\n",
 						cnt,
 						"ion_import_dma_buf handle",
 						handle);
@@ -346,7 +346,7 @@ int vpu_put_request_to_pool(struct vpu_user *user, struct vpu_request *req)
 
 			} else {
 				/* import fd to handle for buffer ref count+1*/
-				LOG_INF("imprt sett ion fd to 0x%p", handle);
+				LOG_DBG("imprt sett ion fd to 0x%p", handle);
 				req->sett.sett_ion_fd =
 						(uint64_t)(uintptr_t)handle;
 			}
@@ -563,7 +563,7 @@ int vpu_get_request_from_queue(struct vpu_user *user,
 		}
 
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] %s (%d)\n", __func__, get);
+			LOG_DBG("[vpu] %s (%d)\n", __func__, get);
 		if (get)
 			list_del_init(vlist_link(req, struct vpu_request));
 
@@ -613,7 +613,7 @@ bool vpu_is_available(void)
 	pool_wait_size = vpu_pool_size(&vpu_device->pool_common);
 
 	if (pool_wait_size != 0) {
-		LOG_INF("common pool size = %d, no empty vpu \r\n",
+		LOG_DBG("common pool size = %d, no empty vpu \r\n",
 			pool_wait_size);
 
 		return false;
@@ -621,13 +621,13 @@ bool vpu_is_available(void)
 
 	for (i = 0; i < MTK_VPU_CORE; i++) {
 		pool_wait_size = vpu_pool_size(&vpu_device->pool[i]);
-		LOG_INF("vpu_%d, pool size = %d\r\n", i, pool_wait_size);
+		LOG_DBG("vpu_%d, pool size = %d\r\n", i, pool_wait_size);
 		if ((pool_wait_size == 0) && vpu_is_idle(i)) {
-			LOG_INF("vpu_%d, is available !!\r\n", i);
+			LOG_DBG("vpu_%d, is available !!\r\n", i);
 			return true;
 		}
 	}
-	LOG_INF("GG, no vpu available !!\r\n");
+	LOG_DBG("GG, no vpu available !!\r\n");
 
 	return false;
 
@@ -693,7 +693,7 @@ int vpu_delete_user(struct vpu_user *user)
 		vpu_hw_unlock(user);
 
 	mutex_lock(&vpu_device->user_mutex);
-	LOG_INF("deleted user[0x%lx]\n", (unsigned long)(user->id));
+	LOG_DBG("deleted user[0x%lx]\n", (unsigned long)(user->id));
 	list_del(vlist_link(user, struct vpu_user));
 	mutex_unlock(&vpu_device->user_mutex);
 
@@ -860,7 +860,7 @@ static int vpu_open(struct inode *inode, struct file *flip)
 		return -ENODEV;
 	}
 
-	LOG_INF("vpu_support core : 0x%x\n", efuse_data);
+	LOG_DBG("vpu_support core : 0x%x\n", efuse_data);
 
 	vpu_create_user(&user);
 	if (IS_ERR_OR_NULL(user)) {
@@ -869,7 +869,7 @@ static int vpu_open(struct inode *inode, struct file *flip)
 	}
 
 	user->id = (unsigned long *)user;
-	LOG_INF("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
+	LOG_DBG("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
 		vpu_num_users,
 		(unsigned long)(user->id),
 		user->open_pid, user->open_tgid);
@@ -957,7 +957,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			LOG_ERR("[EARA_LOCK] get arg fail\n");
 			goto out;
 			}
-		LOG_INF("[vpu] EARA_LOCK + core:%d, maxb:%d, minb:%d\n",
+		LOG_DBG("[vpu] EARA_LOCK + core:%d, maxb:%d, minb:%d\n",
 			vpu_lock_power.core, vpu_lock_power.max_boost_value,
 				vpu_lock_power.min_boost_value);
 		ret = vpu_lock_set_power(&vpu_lock_power);
@@ -983,7 +983,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			LOG_ERR("[EARA_UNLOCK] get arg fail\n");
 			goto out;
 			}
-		LOG_INF("[vpu] EARA_UNLOCK + core:%d\n",
+		LOG_DBG("[vpu] EARA_UNLOCK + core:%d\n",
 			vpu_lock_power.core);
 		vpu_unlock_set_power(&vpu_lock_power);
 		if (ret) {
@@ -1009,7 +1009,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			LOG_ERR("[POWER_HAL] get arg fail\n");
 			goto out;
 			}
-		LOG_INF("[vpu]POWER_HAL_LOCK+core:%d, maxb:%d, minb:%d\n",
+		LOG_DBG("[vpu]POWER_HAL_LOCK+core:%d, maxb:%d, minb:%d\n",
 			vpu_lock_power.core, vpu_lock_power.max_boost_value,
 				vpu_lock_power.min_boost_value);
 		ret = vpu_lock_set_power(&vpu_lock_power);
@@ -1037,7 +1037,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			LOG_ERR("[POWER_HAL_UNLOCK] get arg fail\n");
 			goto out;
 			}
-		LOG_INF("[vpu]POWER_HAL_UNLOCK+ core:%d\n",
+		LOG_DBG("[vpu]POWER_HAL_UNLOCK+ core:%d\n",
 			vpu_lock_power.core);
 		ret = vpu_unlock_set_power(&vpu_lock_power);
 		if (ret) {
@@ -1055,7 +1055,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		u_req = (struct vpu_request *) arg;
 
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] VPU_IOCTL_ENQUE_REQUEST +\n");
+			LOG_DBG("[vpu] VPU_IOCTL_ENQUE_REQUEST +\n");
 
 		ret = vpu_alloc_request(&req);
 		if (ret) {
@@ -1077,12 +1077,12 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		if (req_core == VPU_TRYLOCK_CORENUM &&
 			(ret == 0)) {
 			if (false == vpu_is_available()) {
-				LOG_INF("[vpu] vpu try lock fail!!\n");
+				LOG_DBG("[vpu] vpu try lock fail!!\n");
 				vpu_free_request(req);
 				ret = -EFAULT;
 				goto out;
 			}
-			LOG_INF("[vpu] ret = %d req->requested_core = 0x%x +\n",
+			LOG_DBG("[vpu] ret = %d req->requested_core = 0x%x +\n",
 			ret, req_core);
 		}  else if (req_core != VPU_CORE_COMMON &&
 			req_core > VPU_MAX_NUM_CORES) {
@@ -1173,7 +1173,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		/* free the request, error happened here*/
 		vpu_free_request(req);
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] .VPU_IOCTL_ENQUE_REQUEST - ");
+			LOG_DBG("[vpu] .VPU_IOCTL_ENQUE_REQUEST - ");
 		ret = -EFAULT;
 		break;
 	}
@@ -1184,7 +1184,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		struct vpu_request *u_req;
 
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] VPU_IOCTL_DEQUE_REQUEST + ");
+			LOG_DBG("[vpu] VPU_IOCTL_DEQUE_REQUEST + ");
 
 		u_req = (struct vpu_request *) arg;
 		#if 1
@@ -1225,7 +1225,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			goto out;
 		}
 		if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-			LOG_INF("[vpu] VPU_IOCTL_DEQUE_REQUEST - ");
+			LOG_DBG("[vpu] VPU_IOCTL_DEQUE_REQUEST - ");
 		break;
 	}
 	case VPU_IOCTL_FLUSH_REQUEST:
@@ -1459,7 +1459,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		dev_debug_info->open_tgid = user->open_tgid;
 
 		if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-			LOG_INF("[%s] user:%s/%d. pid(%d/%d)\n",
+			LOG_DBG("[%s] user:%s/%d. pid(%d/%d)\n",
 				"VPU_IOCTL_OPEN_DEV_NOTICE",
 				dev_debug_info->callername,
 				dev_debug_info->dev_fd,
@@ -1500,7 +1500,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 			dbg_info = vlist_node_of(head,
 						struct vpu_dev_debug_info);
 			if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-				LOG_INF("[%s] req_user-> = %s/%d, %d/%d\n",
+				LOG_DBG("[%s] req_user-> = %s/%d, %d/%d\n",
 					"VPU_IOCTL_CLOSE_DEV_NOTICE",
 					dbg_info->callername,
 					dbg_info->dev_fd, dbg_info->open_pid,
@@ -1516,7 +1516,7 @@ static long vpu_ioctl(struct file *flip, unsigned int cmd, unsigned long arg)
 		}
 
 		if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-			LOG_INF("[%s] user:%d. pid(%d/%d), get(%d)\n",
+			LOG_DBG("[%s] user:%d. pid(%d/%d), get(%d)\n",
 					"VPU_IOCTL_CLOSE_DEV_NOTICE",
 					dev_fd, user->open_pid,
 					user->open_tgid, get);
@@ -1625,7 +1625,7 @@ static int vpu_release(struct inode *inode, struct file *flip)
 {
 	struct vpu_user *user = flip->private_data;
 
-	LOG_INF("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
+	LOG_DBG("%s cnt(%d) user->id : 0x%lx, tids(%d/%d)\n", __func__,
 		vpu_num_users,
 		(unsigned long)(user->id),
 		user->open_pid, user->open_tgid);
@@ -1650,7 +1650,7 @@ static int vpu_mmap(struct file *flip, struct vm_area_struct *vma)
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	pfn = vma->vm_pgoff << PAGE_SHIFT;
 
-	LOG_INF("%s:%s=0x%lx,%s=0x%x,%s=0x%lx,%s=0x%lx,%s=0x%lx,%s=0x%lx\n",
+	LOG_DBG("%s:%s=0x%lx,%s=0x%x,%s=0x%lx,%s=0x%lx,%s=0x%lx,%s=0x%lx\n",
 			__func__,
 			"vm_pgoff", vma->vm_pgoff,
 			"pfn", pfn,
@@ -1738,14 +1738,14 @@ static int vpu_probe(struct platform_device *pdev)
 	smi_node = NULL;
 
 	if (core == MTK_VPU_CORE) {
-		LOG_INF("%s(%d), core(%d) = core(%d)+2 in FPGA, return\n",
+		LOG_DBG("%s(%d), core(%d) = core(%d)+2 in FPGA, return\n",
 			"vpu_num_devs", vpu_num_devs, core, MTK_VPU_CORE);
 		return ret;
 	}
 
 	node = pdev->dev.of_node;
 	vpu_device->dev[vpu_num_devs] = &pdev->dev;
-	LOG_INF("probe 0, pdev id = %d name = %s, name = %s\n",
+	LOG_DBG("probe 0, pdev id = %d name = %s, name = %s\n",
 			pdev->id, pdev->name,
 			pdev->dev.of_node->name);
 
@@ -1786,7 +1786,7 @@ static int vpu_probe(struct platform_device *pdev)
 	/* emulator will fill vpu_base and bin_base */
 	vpu_init_emulator(vpu_device);
 #else
-	LOG_INF("[vpu] core/total : %d/%d\n", core, MTK_VPU_CORE);
+	LOG_DBG("[vpu] core/total : %d/%d\n", core, MTK_VPU_CORE);
 	vpu_device->vpu_base[core] = (unsigned long) of_iomap(node, 0);
 	/* get physical address of binary data loaded by LK */
 	if (vpu_num_devs == 0) {
@@ -1805,7 +1805,7 @@ static int vpu_probe(struct platform_device *pdev)
 		vpu_device->bin_pa = phy_addr;
 		vpu_device->bin_size = phy_size;
 
-		LOG_INF("probe core:%d, %s=0x%lx %s=0x%x, %s=0x%x\n",
+		LOG_DBG("probe core:%d, %s=0x%lx %s=0x%x, %s=0x%x\n",
 			core,
 			"bin_base", (unsigned long)vpu_device->bin_base,
 			"phy_addr", phy_addr,
@@ -1831,11 +1831,11 @@ static int vpu_probe(struct platform_device *pdev)
 		vpu_device->vpu_vcorecfg_base =
 			   (unsigned long) of_iomap(ipu_vcore_node, 0);
 
-		LOG_INF("probe, smi_cmn_base: 0x%lx, ipu_conn:0x%lx\n",
+		LOG_DBG("probe, smi_cmn_base: 0x%lx, ipu_conn:0x%lx\n",
 				vpu_device->smi_cmn_base,
 				vpu_device->vpu_syscfg_base);
 
-		LOG_INF("probe, vcorecfg_base: 0x%lx\n",
+		LOG_DBG("probe, vcorecfg_base: 0x%lx\n",
 				vpu_device->vpu_vcorecfg_base);
 	}
 #endif
diff --git a/drivers/misc/mediatek/vpu/mt6785/apu_dvfs.c b/drivers/misc/mediatek/vpu/mt6785/apu_dvfs.c
index c9709f22a..40c58f598 100644
--- a/drivers/misc/mediatek/vpu/mt6785/apu_dvfs.c
+++ b/drivers/misc/mediatek/vpu/mt6785/apu_dvfs.c
@@ -278,7 +278,7 @@ void dump_opp_table(void)
 
 	LOG_DBG("%s start\n", __func__);
 	for (i = 0; i < VPU_DVFS_OPP_MAX; i++) {
-		LOG_INF("vpu opp:%d, vol:%d, freq:%d\n", i
+		LOG_DBG("vpu opp:%d, vol:%d, freq:%d\n", i
 			, vpu_opp_table[i].vpufreq_volt
 		, vpu_opp_table[i].vpufreq_khz);
 	}
@@ -290,7 +290,7 @@ void dump_ptp_count(void)
 
 	LOG_DBG("%s start\n", __func__);
 	for (i = 0; i < 4; i++) {
-		LOG_INF("vvpu id:%d, ptp cnt:%d\n", i
+		LOG_DBG("vvpu id:%d, ptp cnt:%d\n", i
 			, vpu_ptp_count_table[i].vpu_ptp_count);
 	}
 	LOG_DBG("%s end\n", __func__);
@@ -331,12 +331,12 @@ void apu_get_power_info(void)
 	LOG_DVFS("vvpu=%d, vcore=%d\n", vvpu, vcore);
 	if (vvpu < 700000) {
 		if	((dsp_freq >= 364000) || (ipuif_freq >= 364000)) {
-			LOG_INF("freq check fail\n");
-			LOG_INF("dsp_freq = %d\n", dsp_freq);
-			LOG_INF("dsp1_freq = %d\n", dsp1_freq);
-			LOG_INF("dsp2_freq = %d\n", dsp2_freq);
-			LOG_INF("ipuif_freq = %d\n", ipuif_freq);
-	LOG_INF("vvpu=%d, vcore=%d\n", vvpu, vcore);
+			LOG_DBG("freq check fail\n");
+			LOG_DBG("dsp_freq = %d\n", dsp_freq);
+			LOG_DBG("dsp1_freq = %d\n", dsp1_freq);
+			LOG_DBG("dsp2_freq = %d\n", dsp2_freq);
+			LOG_DBG("ipuif_freq = %d\n", ipuif_freq);
+	LOG_DBG("vvpu=%d, vcore=%d\n", vvpu, vcore);
 	aee_kernel_warning("freq check", "%s: failed.", __func__);
 			}
 	}
@@ -383,10 +383,10 @@ unsigned int vvpu_update_ptp_count(unsigned int ptp_count[],
 
 	for (i = 0; i < array_size; i++) {
 		vpu_ptp_count_table[i].vpu_ptp_count = ptp_count[i];
-		LOG_INF("%s id:%d, ptp cnt:0x%x\n", __func__, i, ptp_count[i]);
+		LOG_DBG("%s id:%d, ptp cnt:0x%x\n", __func__, i, ptp_count[i]);
 		}
 //
-LOG_INF("[CPE]:VPU Det_Count: %d, %d, %d, %d\n",
+LOG_DBG("[CPE]:VPU Det_Count: %d, %d, %d, %d\n",
 vpu_ptp_count_table[0].vpu_ptp_count,
 	vpu_ptp_count_table[1].vpu_ptp_count,
 	vpu_ptp_count_table[2].vpu_ptp_count,
@@ -488,11 +488,11 @@ int vvpu_regulator_set_mode(bool enable)
 	int ret = 0;
 
 	if (!vvpu_reg_id) {
-		LOG_INF("vvpu_reg_id not ready\n");
+		LOG_DBG("vvpu_reg_id not ready\n");
 		return ret;
 	}
 	if (vvpu_DVFS_is_paused_by_ptpod) {
-		LOG_INF("vvpu dvfs lock\n");
+		LOG_DBG("vvpu dvfs lock\n");
 		return ret;
 	}
 	mutex_lock(&vpu_opp_lock);
@@ -722,7 +722,7 @@ static int vvpu_vbin(int opp)
 
 	for (i = 0; i < 4; i++) {
 		if (vpu_ptp_count_table[i].vpu_ptp_count == 0) {
-			LOG_INF("vpu ptp count 0\n");
+			LOG_DBG("vpu ptp count 0\n");
 			result = 0;
 			return result;
 		}
@@ -768,7 +768,7 @@ static int vvpu_vbin(int opp)
 		else
 			result = 1;
 	}
-LOG_INF("[CPE]:VPU_OPP=%d,VPU_BIN=%d,CPE_VBIN=%d,Criteria=%d,Result=%d\n",
+LOG_DBG("[CPE]:VPU_OPP=%d,VPU_BIN=%d,CPE_VBIN=%d,Criteria=%d,Result=%d\n",
 	opp, vvpu_opp, vbin, pass_crit, result);
 	return result;
 }
@@ -780,19 +780,19 @@ int apu_dvfs_dump_info(void)
 
 	mode = regulator_get_mode(vvpu_reg_id);
 		if (mode == REGULATOR_MODE_FAST)
-			LOG_INF("++vvpu_reg_id pwm mode\n");
+			LOG_DBG("++vvpu_reg_id pwm mode\n");
 		else
-			LOG_INF("++vvpu_reg_id auto mode\n");
+			LOG_DBG("++vvpu_reg_id auto mode\n");
 
 	for (i = 0; i < 4; i++) {
-		LOG_INF("id:%d, vpu ptp cnt:0x%x\n",
+		LOG_DBG("id:%d, vpu ptp cnt:0x%x\n",
 			i, vpu_ptp_count_table[i].vpu_ptp_count);
 	}
 
 
-	LOG_INF("vpu dvfs lock:%d\n",
+	LOG_DBG("vpu dvfs lock:%d\n",
 		vvpu_DVFS_is_paused_by_ptpod);
-	LOG_INF("vpu cpe0:%d, cpe1:%d, cpe2:%d\n",
+	LOG_DBG("vpu cpe0:%d, cpe1:%d, cpe2:%d\n",
 		vvpu0_cpe_result, vvpu1_cpe_result, vvpu2_cpe_result);
 	vvpu_vbin(0);
 	vvpu_vbin(1);
@@ -886,7 +886,7 @@ static int commit_data(int type, int data)
 	case PM_QOS_VVPU_OPP:
 		mutex_lock(&vpu_opp_lock);
 		if (get_vvpu_DVFS_is_paused_by_ptpod()) {
-			LOG_INF("PM_QOS_VVPU_OPP paused by ptpod %d\n", data);
+			LOG_DBG("PM_QOS_VVPU_OPP paused by ptpod %d\n", data);
 		} else {
 			LOG_DVFS("%s PM_QOS_VVPU_OPP %d\n", __func__, data);
 			/*settle time*/
@@ -946,7 +946,7 @@ static int commit_data(int type, int data)
 
 	get_vvpu_efuse();
 	if (ret < 0) {
-		pr_info("%s: type: 0x%x, data: 0x%x, opp: %d, level: %d\n",
+		pr_debug("%s: type: 0x%x, data: 0x%x, opp: %d, level: %d\n",
 				__func__, type, data, opp, level);
 		apu_get_power_info();
 		apu_dvfs_dump_reg(NULL);
@@ -973,7 +973,7 @@ char *apu_dvfs_dump_reg(char *ptr)
 	if (ptr)
 		ptr += sprintf(ptr, "%s\n", buf);
 	else
-		pr_info("%s\n", buf);
+		pr_debug("%s\n", buf);
 
 	return ptr;
 }
diff --git a/drivers/misc/mediatek/vpu/mt6785/vpu_hw.c b/drivers/misc/mediatek/vpu/mt6785/vpu_hw.c
index 3274ccb94..465d46438 100644
--- a/drivers/misc/mediatek/vpu/mt6785/vpu_hw.c
+++ b/drivers/misc/mediatek/vpu/mt6785/vpu_hw.c
@@ -323,7 +323,7 @@ static inline void lock_command(int core_s, int cmd)
 	mutex_lock(&(vpu_service_cores[core].cmd_mutex));
 	vpu_service_cores[core].is_cmd_done = false;
 	vpu_write_field(core, FLD_XTENSA_INFO17, 0);
-	LOG_INF("%s: vpu%d: cmd: %02xh, info00:%xh, info17:%xh\n",
+	LOG_DBG("%s: vpu%d: cmd: %02xh, info00:%xh, info17:%xh\n",
 		__func__, core, cmd,
 		vpu_read_field(core, FLD_XTENSA_INFO00),
 		vpu_read_field(core, FLD_XTENSA_INFO17));
@@ -348,9 +348,10 @@ static void vpu_err_msg(int core, const char *msg)
 		opp_keep_flag);
 }
 
+#if defined(CONFIG_MTK_AEE_FEATURE)
 #define vpu_err_hnd(hw_fail, core, req, key, fmt, args...) \
 	do { \
-		pr_info(fmt, ##args); \
+		pr_debug(fmt, ##args); \
 		vpu_err_msg(core, __func__); \
 		if (hw_fail) { \
 			vpu_dmp_create_locked(core, req, fmt, ##args); \
@@ -359,6 +360,19 @@ static void vpu_err_msg(int core, const char *msg)
 			"\nCRDISPATCH_KEY:" key "\n" fmt, ##args); \
 		} \
 	} while (0)
+#else
+#define vpu_err_hnd(hw_fail, core, req, key, fmt, args...) \
+        do { \
+                pr_info(fmt, ##args); \
+                vpu_err_msg(core, __func__); \
+                if (hw_fail) { \
+                        vpu_dmp_create_locked(core, req, fmt, ##args); \
+                        apu_get_power_info(); \
+                        pr_err("VPU", \
+                        "\nCRDISPATCH_KEY:" key "\n" fmt, ##args); \
+                } \
+        } while (0)
+#endif
 
 static void vpu_status(int core)
 {
@@ -377,7 +391,7 @@ static int wait_idle(int core, uint32_t latency, uint32_t retry)
 		udelay(latency);
 	} while (count < retry);
 
-	pr_info("%s: vpu%d: %d us: pwaitmode: %d, info00: 0x%x, info25: 0x%x\n",
+	pr_debug("%s: vpu%d: %d us: pwaitmode: %d, info00: 0x%x, info25: 0x%x\n",
 		__func__, core, (latency * retry), pwait,
 		vpu_read_field(core, FLD_XTENSA_INFO00),
 		vpu_read_field(core, FLD_XTENSA_INFO25));
@@ -402,11 +416,11 @@ start:
 
 	/* ret == -ERESTARTSYS, if signal interrupt */
 	if (ret == -ERESTARTSYS) {
-		pr_info("%s: vpu%d: interrupt by signal: ret=%d\n",
+		pr_debug("%s: vpu%d: interrupt by signal: ret=%d\n",
 			__func__, core, ret);
 
 		if (retry) {
-			pr_info("%s: vpu%d: try wait again\n",
+			pr_debug("%s: vpu%d: try wait again\n",
 				__func__, core);
 			retry = false;
 			goto start;
@@ -419,7 +433,7 @@ start:
 		ret = 0;
 	} else {    /* condition false: timeout or retry*/
 		if (count >= CMD_WAIT_COUNT) {
-			pr_info("%s: vpu%d: timeout: %d ms\n",
+			pr_debug("%s: vpu%d: timeout: %d ms\n",
 				__func__, core, CMD_WAIT_TIME_MS);
 			ret = -ETIMEDOUT;
 		} else {
@@ -585,7 +599,7 @@ static inline int wait_to_do_change_vcore_opp(int core)
 	/* now this function just return directly. NO WAIT */
 	if (g_func_mask & VFM_NEED_WAIT_VCORE) {
 		if (g_vpu_log_level > Log_STATE_MACHINE) {
-			LOG_INF("[vpu_%d_0x%x] wait for vcore change now\n",
+			LOG_DBG("[vpu_%d_0x%x] wait for vcore change now\n",
 					core, g_func_mask);
 		}
 	} else {
@@ -665,7 +679,7 @@ static inline int wait_to_do_vpu_running(int core)
 	/* now this function just return directly. NO WAIT */
 	if (g_func_mask & VFM_NEED_WAIT_VCORE) {
 		if (g_vpu_log_level > Log_STATE_MACHINE) {
-			LOG_INF("[vpu_%d_0x%x] wait for vpu running now\n",
+			LOG_DBG("[vpu_%d_0x%x] wait for vpu running now\n",
 					core, g_func_mask);
 		}
 	} else {
@@ -944,7 +958,7 @@ EXPORT_SYMBOL(get_vpu_init_done);
 static void get_segment_from_efuse(void)
 {
 	segment_max_opp = 0;
-	LOG_INF("vpu segment_max_opp: %d\n", segment_max_opp);
+	LOG_DBG("vpu segment_max_opp: %d\n", segment_max_opp);
 }
 
 /* expected range, vvpu_index: 0~15 */
@@ -1007,7 +1021,7 @@ static void vpu_opp_check(int core_s, uint8_t vvpu_index, uint8_t freq_index)
 			change_freq_first[core] = true;
 
 		if (vcore_index < max_vcore_opp) {
-			LOG_INF("vpu bound vcore opp(%d) to %d",
+			LOG_DBG("vpu bound vcore opp(%d) to %d",
 					vcore_index, max_vcore_opp);
 
 			vcore_index = max_vcore_opp;
@@ -1040,7 +1054,7 @@ if (vvpu_index == 0xFF) {
 		change_freq_first[core] = true;
 
 	if (vvpu_index < max_vvpu_opp) {
-		LOG_INF("vpu bound vvpu opp(%d) to %d",
+		LOG_DBG("vpu bound vvpu opp(%d) to %d",
 				vvpu_index, max_vvpu_opp);
 
 		vvpu_index = max_vvpu_opp;
@@ -1073,7 +1087,7 @@ if (vvpu_index == 0xFF) {
 		force_change_dsp_freq[core] = false;
 	} else {
 		if (freq_index < max_dsp_freq) {
-			LOG_INF("vpu bound dsp freq(%dMHz) to %dMHz",
+			LOG_DBG("vpu bound dsp freq(%dMHz) to %dMHz",
 					log_freq, log_max_freq);
 			freq_index = max_dsp_freq;
 		}
@@ -1089,7 +1103,7 @@ if (vvpu_index == 0xFF) {
 				(freq_index > opps.dspcore[core].index) &&
 				(opp_keep_flag)) {
 				if (g_vpu_log_level > Log_ALGO_OPP_INFO) {
-					LOG_INF("%s(%d) %s (%d/%d_%d/%d)\n",
+					LOG_DBG("%s(%d) %s (%d/%d_%d/%d)\n",
 						__func__,
 						core,
 						"dsp keep high",
@@ -1166,7 +1180,7 @@ if (vvpu_index == 0xFF) {
 		} else {
 			/* vcore not change & dsp not change */
 			if (g_vpu_log_level > Log_ALGO_OPP_INFO)
-				LOG_INF("opp_check(%d) vcore/dsp no change\n",
+				LOG_DBG("opp_check(%d) vcore/dsp no change\n",
 						core);
 
 			opp_keep_flag = true;
@@ -1177,7 +1191,7 @@ if (vvpu_index == 0xFF) {
 	}
 	mutex_unlock(&opp_mutex);
 out:
-	LOG_INF("%s(%d)(%d/%d_%d)(%d/%d)(%d.%d.%d.%d)(%d/%d)(%d/%d/%d/%d)%d\n",
+	LOG_DBG("%s(%d)(%d/%d_%d)(%d/%d)(%d.%d.%d.%d)(%d/%d)(%d/%d/%d/%d)%d\n",
 		"opp_check",
 		core,
 		is_power_debug_lock,
@@ -1201,7 +1215,7 @@ out:
 static bool vpu_change_opp(int core_s, int type)
 {
 #ifdef MTK_VPU_FPGA_PORTING
-	LOG_INF("[vpu_%d] %d Skip at FPGA", core, type);
+	LOG_DBG("[vpu_%d] %d Skip at FPGA", core, type);
 
 	return true;
 #else
@@ -1209,7 +1223,7 @@ static bool vpu_change_opp(int core_s, int type)
 	unsigned int core = (unsigned int)core_s;
 #if 0
 	if (get_vvpu_DVFS_is_paused_by_ptpod()) {
-		LOG_INF("[vpu_%d] dvfs skip by ptpod", core);
+		LOG_DBG("[vpu_%d] dvfs skip by ptpod", core);
 		return true;
 	}
 #endif
@@ -1221,7 +1235,7 @@ static bool vpu_change_opp(int core_s, int type)
 	/* dsp freq opp */
 	case OPPTYPE_DSPFREQ:
 		mutex_lock(&opp_mutex);
-		LOG_INF("[vpu_%d] %s setclksrc(%d/%d/%d/%d)\n",
+		LOG_DBG("[vpu_%d] %s setclksrc(%d/%d/%d/%d)\n",
 				core,
 				__func__,
 				opps.dsp.index,
@@ -1384,7 +1398,7 @@ int32_t vpu_thermal_en_throttle_cb(uint8_t vcore_opp, uint8_t vpu_opp)
 		mutex_unlock(&power_counter_mutex[i]);
 	}
 	if (vpu_down) {
-		LOG_INF("[vpu] all vpu are off currently, do nothing\n");
+		LOG_DBG("[vpu] all vpu are off currently, do nothing\n");
 		return ret;
 	}
 	#endif
@@ -1406,7 +1420,7 @@ int32_t vpu_thermal_en_throttle_cb(uint8_t vcore_opp, uint8_t vpu_opp)
 		return -1;
 	}
 	#endif
-	LOG_INF("%s, opp(%d)->(%d/%d)\n", __func__,
+	LOG_DBG("%s, opp(%d)->(%d/%d)\n", __func__,
 		vpu_opp, vvpu_opp_index, vpu_freq_index);
 
 	mutex_lock(&opp_mutex);
@@ -1429,59 +1443,59 @@ int32_t vpu_thermal_en_throttle_cb(uint8_t vcore_opp, uint8_t vpu_opp)
 			switch (vpu_freq_index) {
 			case 0:
 			default:
-				LOG_INF("thermal force bound freq @750MHz\n");
+				LOG_DBG("thermal force bound freq @750MHz\n");
 				break;
 			case 1:
-				LOG_INF("thermal force bound freq @ 700MHz\n");
+				LOG_DBG("thermal force bound freq @ 700MHz\n");
 				break;
 			case 2:
-				LOG_INF("thermal force bound freq @624MHz\n");
+				LOG_DBG("thermal force bound freq @624MHz\n");
 				break;
 			case 3:
-				LOG_INF("thermal force bound freq @594MHz\n");
+				LOG_DBG("thermal force bound freq @594MHz\n");
 				break;
 			case 4:
-				LOG_INF("thermal force bound freq @560MHz\n");
+				LOG_DBG("thermal force bound freq @560MHz\n");
 				break;
 			case 5:
-				LOG_INF("thermal force bound freq @525MHz\n");
+				LOG_DBG("thermal force bound freq @525MHz\n");
 				break;
 			case 6:
-				LOG_INF("thermal force bound freq @450MHz\n");
+				LOG_DBG("thermal force bound freq @450MHz\n");
 				break;
 			case 7:
-				LOG_INF("thermal force bound freq @416MHz\n");
+				LOG_DBG("thermal force bound freq @416MHz\n");
 				break;
 			case 8:
-				LOG_INF("thermal force bound freq @364MHz\n");
+				LOG_DBG("thermal force bound freq @364MHz\n");
 				break;
 			case 9:
-				LOG_INF("thermal force bound freq @312MHz\n");
+				LOG_DBG("thermal force bound freq @312MHz\n");
 				break;
 			case 10:
-				LOG_INF("thermal force bound freq @273MHz\n");
+				LOG_DBG("thermal force bound freq @273MHz\n");
 				break;
 			case 11:
-				LOG_INF("thermal force bound freq @208MHz\n");
+				LOG_DBG("thermal force bound freq @208MHz\n");
 				break;
 			case 12:
-				LOG_INF("thermal force bound freq @137MHz\n");
+				LOG_DBG("thermal force bound freq @137MHz\n");
 				break;
 			case 13:
-				LOG_INF("thermal force bound freq @104MHz\n");
+				LOG_DBG("thermal force bound freq @104MHz\n");
 				break;
 			case 14:
-				LOG_INF("thermal force bound freq @52MHz\n");
+				LOG_DBG("thermal force bound freq @52MHz\n");
 				break;
 			case 15:
-				LOG_INF("thermal force bound freq @26MHz\n");
+				LOG_DBG("thermal force bound freq @26MHz\n");
 				break;
 			}
 			/*vpu_change_opp(i, OPPTYPE_DSPFREQ);*/
 		}
 		if (force_change_vvpu_opp[i]) {
 			/* vcore change should wait */
-			LOG_INF("thermal force bound vcore opp to %d\n",
+			LOG_DBG("thermal force bound vcore opp to %d\n",
 					vvpu_opp_index);
 			/* vcore only need to change one time from
 			 * thermal request
@@ -1500,13 +1514,13 @@ int32_t vpu_thermal_dis_throttle_cb(void)
 
 	if (vpu_init_done != 1)
 		return ret;
-	LOG_INF("%s +\n", __func__);
+	LOG_DBG("%s +\n", __func__);
 	mutex_lock(&opp_mutex);
 	max_vcore_opp = 0;
 	max_dsp_freq = 0;
 	max_vvpu_opp = 0;
 	mutex_unlock(&opp_mutex);
-	LOG_INF("%s -\n", __func__);
+	LOG_DBG("%s -\n", __func__);
 
 	return ret;
 }
@@ -1524,7 +1538,7 @@ static int vpu_prepare_regulator_and_clock(struct device *pdev)
 
 
 #ifdef MTK_VPU_FPGA_PORTING
-	LOG_INF("%s skip at FPGA\n", __func__);
+	LOG_DBG("%s skip at FPGA\n", __func__);
 #else
 #define PREPARE_VPU_MTCMOS(clk) \
 	{ \
@@ -1608,7 +1622,7 @@ static int vpu_prepare_regulator_and_clock(struct device *pdev)
 static int vpu_enable_regulator_and_clock(int core)
 {
 #ifdef MTK_VPU_FPGA_PORTING
-	LOG_INF("%s skip at FPGA\n", __func__);
+	LOG_DBG("%s skip at FPGA\n", __func__);
 
 	is_power_on[core] = true;
 	force_change_vcore_opp[core] = false;
@@ -1637,7 +1651,7 @@ static int vpu_enable_regulator_and_clock(int core)
 	ret1 = vvpu_regulator_set_mode(true);
 	udelay(100);//slew rate:rising10mV/us
 if (g_vpu_log_level > Log_STATE_MACHINE)
-	LOG_INF("enable vvpu ret:%d\n", ret1);
+	LOG_DBG("enable vvpu ret:%d\n", ret1);
 
 
 
@@ -1796,7 +1810,7 @@ clk_on:
 #undef ENABLE_VPU_MTCMOS
 #undef ENABLE_VPU_CLK
 
-	LOG_INF("[vpu_%d] en_rc setclksrc(%d/%d/%d/%d)\n",
+	LOG_DBG("[vpu_%d] en_rc setclksrc(%d/%d/%d/%d)\n",
 			core,
 			opps.dsp.index,
 			opps.dspcore[0].index,
@@ -1911,9 +1925,9 @@ static unsigned int vpu_read_smi_bus_debug(int core)
 		}
 		smi_bus_vpu_value = (smi_bus_value & 0x007FE000) >> 13;
 	} else {
-		LOG_INF("[vpu_%d] null smi_cmn_base\n", core);
+		LOG_DBG("[vpu_%d] null smi_cmn_base\n", core);
 	}
-	LOG_INF("[vpu_%d] read_smi_bus (0x%x/0x%x)\n", core,
+	LOG_DBG("[vpu_%d] read_smi_bus (0x%x/0x%x)\n", core,
 			smi_bus_value, smi_bus_vpu_value);
 
 	return smi_bus_vpu_value;
@@ -1926,7 +1940,7 @@ static int vpu_disable_regulator_and_clock(int core)
 	int ret1 = 0;
 
 #ifdef MTK_VPU_FPGA_PORTING
-	LOG_INF("%s skip at FPGA\n", __func__);
+	LOG_DBG("%s skip at FPGA\n", __func__);
 
 	is_power_on[core] = false;
 	if (!is_power_debug_lock)
@@ -1942,13 +1956,13 @@ static int vpu_disable_regulator_and_clock(int core)
 #ifdef MTK_VPU_SMI_DEBUG_ON
 	smi_bus_vpu_value = vpu_read_smi_bus_debug(core);
 
-	LOG_INF("[vpu_%d] dis_rc 1 (0x%x)\n", core, smi_bus_vpu_value);
+	LOG_DBG("[vpu_%d] dis_rc 1 (0x%x)\n", core, smi_bus_vpu_value);
 
 	if ((int)smi_bus_vpu_value != 0) {
 		mdelay(1);
 		smi_bus_vpu_value = vpu_read_smi_bus_debug(core);
 
-		LOG_INF("[vpu_%d] dis_rc again (0x%x)\n", core,
+		LOG_DBG("[vpu_%d] dis_rc again (0x%x)\n", core,
 				smi_bus_vpu_value);
 
 		if ((int)smi_bus_vpu_value != 0) {
@@ -2063,7 +2077,7 @@ out:
 	opps.dsp.index = 9;
 	opps.ipu_if.index = 9;
 if (g_vpu_log_level > Log_STATE_MACHINE)
-	LOG_INF("[vpu_%d] dis_rc -\n", core);
+	LOG_DBG("[vpu_%d] dis_rc -\n", core);
 	return ret;
 #endif
 }
@@ -2072,7 +2086,7 @@ static void vpu_unprepare_regulator_and_clock(void)
 {
 
 #ifdef MTK_VPU_FPGA_PORTING
-	LOG_INF("%s skip at FPGA\n", __func__);
+	LOG_DBG("%s skip at FPGA\n", __func__);
 #else
 #define UNPREPARE_VPU_CLK(clk) \
 	{ \
@@ -2576,7 +2590,7 @@ info18_out:
 #ifdef VPU_MOVE_WAKE_TO_BACK
 	if (normal_check_done == 1) {
 		vpu_trace_dump("VPU%d VPU_REQ_DO_CHECK_STATE OK", core);
-		LOG_INF("normal_check_done UNLOCK\n");
+		LOG_DBG("normal_check_done UNLOCK\n");
 		vpu_service_cores[core].is_cmd_done = true;
 		wake_up_interruptible(&cmd_wait);
 	}
@@ -2635,7 +2649,7 @@ static void vpu_hw_ion_free_handle(struct ion_client *client,
 		return;
 	}
 	if (g_vpu_log_level > Log_STATE_MACHINE)
-		LOG_INF("[vpu] ion_free_handle(0x%p)\n", handle);
+		LOG_DBG("[vpu] ion_free_handle(0x%p)\n", handle);
 
 	ion_free(client, handle);
 }
@@ -2793,7 +2807,7 @@ for (j = 0 ; j < req->buffers[i].plane_count ; j++) { \
 			service_core, i,
 				vpu_dev->priority_list[service_core][i]);
 		if (vpu_dev->priority_list[service_core][i] > 0) {
-			LOG_INF("+ opp due to priority %d\n", req->priority);
+			LOG_DBG("+ opp due to priority %d\n", req->priority);
 			vcore_opp_index = 0;
 			dsp_freq_index = 0;
 			break;
@@ -2817,7 +2831,7 @@ for (j = 0 ; j < req->buffers[i].plane_count ; j++) { \
 #define LOG_STRING \
 "[v%d<-0x%x]0x%lx,ID=0x%lx_%d,%d->%d,%d,%d/%d-%d,%d-%d,0x%x,%d/%d/%d/0x%x\n"
 
-			LOG_INF(LOG_STRING,
+			LOG_DBG(LOG_STRING,
 				service_core,
 				req->requested_core,
 				(unsigned long)req->user_id,
@@ -2916,7 +2930,7 @@ out:
 			list_add_tail(vlist_link(req, struct vpu_request),
 						&user->deque_list);
 
-			LOG_INF("[vpu_%d, 0x%x->0x%x] %s(%d_%d), st(%d) %s\n",
+			LOG_DBG("[vpu_%d, 0x%x->0x%x] %s(%d_%d), st(%d) %s\n",
 				service_core,
 				req->requested_core, req->occupied_core,
 				"algo_id", (int)(req->algo_id[service_core]),
@@ -3372,14 +3386,14 @@ void vpu_put_power(int core_s, enum VpuPowerOnType type)
 				msecs_to_jiffies(10 * PWR_KEEP_TIME_MS));
 			break;
 		case VPT_IMT_OFF:
-			LOG_INF("[vpu_%d] VPT_IMT_OFF\n", core);
+			LOG_DBG("[vpu_%d] VPT_IMT_OFF\n", core);
 			mod_delayed_work(wq,
 				&(power_counter_work[core].my_work),
 				msecs_to_jiffies(0));
 			break;
 		case VPT_SDSP_OFF:
 			power_counter_work[core].logbackup = 0;
-			LOG_INF("[vpu_%d] VPT_IMT_OFF (SDSP)\n", core);
+			LOG_DBG("[vpu_%d] VPT_IMT_OFF (SDSP)\n", core);
 			mod_delayed_work(wq,
 				&(power_counter_work[core].my_work),
 				msecs_to_jiffies(0));
@@ -3424,7 +3438,7 @@ int vpu_set_power(struct vpu_user *user, struct vpu_power *power)
 		return ret;
 	}
 
-	LOG_INF("[vpu_%d] set power opp:%d, pid=%d, tid=%d\n",
+	LOG_DBG("[vpu_%d] set power opp:%d, pid=%d, tid=%d\n",
 			core, power->opp_step,
 			user->open_pid, user->open_tgid);
 
@@ -3457,7 +3471,7 @@ int vpu_set_power(struct vpu_user *user, struct vpu_power *power)
 
 	/* to avoid power leakage, power on/off need be paired */
 	vpu_put_power(core, VPT_PRE_ON);
-	LOG_INF("[vpu_%d] %s -\n", core, __func__);
+	LOG_DBG("[vpu_%d] %s -\n", core, __func__);
 	return ret;
 }
 
@@ -3482,7 +3496,7 @@ int vpu_sdsp_get_power(struct vpu_user *user)
 	mod_delayed_work(wq, &sdsp_work,
 		msecs_to_jiffies(SDSP_KEEP_TIME_MS));
 
-	LOG_INF("[vpu] %s -\n", __func__);
+	LOG_DBG("[vpu] %s -\n", __func__);
 	return ret;
 }
 
@@ -3501,7 +3515,7 @@ int vpu_sdsp_put_power(struct vpu_user *user)
 			while (is_power_on[core] == true)
 				usleep_range(100, 500);
 
-			LOG_INF("[vpu] power_counter[%d] = %d/%d -\n",
+			LOG_DBG("[vpu] power_counter[%d] = %d/%d -\n",
 				core, power_counter[core], is_power_on[core]);
 
 		}
@@ -3510,7 +3524,7 @@ int vpu_sdsp_put_power(struct vpu_user *user)
 		&sdsp_work,
 		msecs_to_jiffies(0));
 
-	LOG_INF("[vpu] %s, sdsp_power_counter = %d -\n",
+	LOG_DBG("[vpu] %s, sdsp_power_counter = %d -\n",
 		__func__, sdsp_power_counter);
 	return ret;
 }
@@ -3553,7 +3567,7 @@ bool vpu_is_idle(int core_s)
 
 	mutex_unlock(&(vpu_service_cores[core].state_mutex));
 
-	LOG_INF("%s vpu_%d, idle = %d, state = %d  !!\r\n", __func__,
+	LOG_DBG("%s vpu_%d, idle = %d, state = %d  !!\r\n", __func__,
 		core, idle, vpu_service_cores[core].state);
 
 	return idle;
@@ -3566,7 +3580,7 @@ int vpu_quick_suspend(int core_s)
 
 	LOG_DBG("[vpu_%d] q_suspend +\n", core);
 	mutex_lock(&power_counter_mutex[core]);
-	LOG_INF("[vpu_%d] q_suspend (%d/%d)\n", core,
+	LOG_DBG("[vpu_%d] q_suspend (%d/%d)\n", core,
 		power_counter[core], vpu_service_cores[core].state);
 
 	if (power_counter[core] == 0) {
@@ -3612,10 +3626,10 @@ static void vpu_sdsp_routine(struct work_struct *work)
 {
 
 	if (sdsp_power_counter != 0) {
-		LOG_INF("%s long time not unlock!!! -\n", __func__);
+		LOG_DBG("%s long time not unlock!!! -\n", __func__);
 		LOG_ERR("%s long time not unlock error!!! -\n", __func__);
 	} else {
-		LOG_INF("%s sdsp_power_counter is correct!!! -\n", __func__);
+		LOG_DBG("%s sdsp_power_counter is correct!!! -\n", __func__);
 	}
 }
 
@@ -3687,7 +3701,7 @@ int vpu_init_hw(int core_s, struct vpu_device *device)
 		vpu_dev->vpu_hw_support[1] = true;
 #else
 		efuse_data = (get_devinfo_with_index(3) & 0xC00) >> 10;
-		LOG_INF("efuse_data: efuse_data(0x%x)\n", efuse_data);
+		LOG_DBG("efuse_data: efuse_data(0x%x)\n", efuse_data);
 		switch (efuse_data) {
 		case 0x3: /*b11*/
 			vpu_dev->vpu_hw_support[0] = false;
@@ -3783,7 +3797,7 @@ int vpu_init_hw(int core_s, struct vpu_device *device)
 
 			vpu_service_cores[i].work_buf_logsize = 0;
 
-			LOG_INF("core(%d):work_buf va (0x%lx),pa(0x%x)\n",
+			LOG_DBG("core(%d):work_buf va (0x%lx),pa(0x%x)\n",
 				i,
 				(unsigned long)
 				    (vpu_service_cores[i].work_buf->va),
@@ -3816,7 +3830,7 @@ int vpu_init_hw(int core_s, struct vpu_device *device)
 					&(vpu_service_cores[i].exec_kernel_lib),
 					&mem_param);
 
-			LOG_INF("core(%d):kernel_lib va (0x%lx),pa(0x%x)\n",
+			LOG_DBG("core(%d):kernel_lib va (0x%lx),pa(0x%x)\n",
 				i,
 				(unsigned long)
 				    (vpu_service_cores[i].exec_kernel_lib->va),
@@ -4198,7 +4212,7 @@ int vpu_hw_boot_sequence(int core_s)
 	}
 
 	vpu_trace_begin("%s", __func__);
-	LOG_INF("[vpu_%d] boot-seq core(%d)\n", core, core);
+	LOG_DBG("[vpu_%d] boot-seq core(%d)\n", core, core);
 
 	LOG_DBG("CTRL(0x%x)\n",
 			vpu_read_reg32(vpu_service_cores[core].vpu_base,
@@ -4287,7 +4301,7 @@ int vpu_hw_boot_sequence(int core_s)
 	VPU_SET_BIT(ptr_axi_0, 28);
 
 	if (g_vpu_log_level > VpuLogThre_PERFORMANCE) {
-		LOG_INF("[vpu_%d] REG_AXI_DEFAULT0(0x%x)\n", core,
+		LOG_DBG("[vpu_%d] REG_AXI_DEFAULT0(0x%x)\n", core,
 			vpu_read_reg32(vpu_service_cores[core].vpu_base,
 						CTRL_BASE_OFFSET + 0x13C));
 	}
@@ -4333,7 +4347,7 @@ out:
 	vpu_trace_end();
 	vpu_write_field(core, FLD_APMCU_INT, 1);
 
-	LOG_INF("[vpu_%d] hw_boot_sequence with clr INT-\n", core);
+	LOG_DBG("[vpu_%d] hw_boot_sequence with clr INT-\n", core);
 	return ret;
 }
 
@@ -4405,7 +4419,7 @@ int vpu_hw_set_debug(int core_s)
 	vpu_write_field(core, FLD_XTENSA_INFO30,
 		vpu_service_cores[core].work_buf_logsize);
 
-	LOG_INF("[vpu_%d] %s=(0x%lx), INFO01(0x%x), 23(%d)\n",
+	LOG_DBG("[vpu_%d] %s=(0x%lx), INFO01(0x%x), 23(%d)\n",
 		core,
 		"work_buf->pa + VPU_OFFSET_LOG",
 		(unsigned long)(vpu_service_cores[core].work_buf->pa +
@@ -4469,7 +4483,7 @@ out:
 	ret = vpu_hw_set_log_option(core);
 #endif
 	vpu_trace_end();
-	LOG_INF("[vpu_%d] hw_set_debug - version check(0x%x/0x%x)\n",
+	LOG_DBG("[vpu_%d] hw_set_debug - version check(0x%x/0x%x)\n",
 			core,
 			vpu_read_field(core, FLD_XTENSA_INFO20),
 			vpu_read_field(core, FLD_XTENSA_INFO29));
@@ -4543,7 +4557,7 @@ int vpu_get_entry_of_algo(int core_s, char *name, int *id,
 	for (i = 0; i < VPU_NUMS_IMAGE_HEADER; i++) {
 		for (j = 0; j < header[i].algo_info_count; j++) {
 			algo_info = &header[i].algo_infos[j];
-			LOG_INF("%s: %s/%s, %s:0x%x, %s:%d, %s:0x%x, 0x%x\n",
+			LOG_DBG("%s: %s/%s, %s:0x%x, %s:%d, %s:0x%x, 0x%x\n",
 					"algo name", name, algo_info->name,
 					"core info", (algo_info->vpu_core),
 					"input core", core,
@@ -4552,7 +4566,7 @@ int vpu_get_entry_of_algo(int core_s, char *name, int *id,
 			/* CHRISTODO */
 			if ((strcmp(name, algo_info->name) == 0) &&
 				(algo_info->vpu_core & coreMagicNum)) {
-				LOG_INF("[%d] algo_info->offset(0x%x)/0x%x",
+				LOG_DBG("[%d] algo_info->offset(0x%x)/0x%x",
 					core,
 					algo_info->offset,
 				    (unsigned int)
@@ -4562,7 +4576,7 @@ int vpu_get_entry_of_algo(int core_s, char *name, int *id,
 					 VPU_OFFSET_ALGO_AREA +
 					 vpu_service_cores[core].algo_data_mva;
 
-				LOG_INF("[%d] *mva(0x%x/0x%lx), s(%d)",
+				LOG_DBG("[%d] *mva(0x%x/0x%lx), s(%d)",
 						core, *mva,
 						(unsigned long)(*mva), s);
 
@@ -4955,7 +4969,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 		}
 	}
 
-	LOG_INF("%s: vpu%d: algo: %s(%d)\n", __func__,
+	LOG_DBG("%s: vpu%d: algo: %s(%d)\n", __func__,
 		core, algo ? algo->name : "", request->algo_id[core]);
 
 	/* step3. do processing, algo loader and d2d*/
@@ -4987,7 +5001,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 		LOG_DBG("[vpu_%d] vpu_check_precond done\n", core);
 
 		if (g_vpu_log_level > Log_ALGO_OPP_INFO)
-			LOG_INF("[vpu_%d] algo_%d ptr/length (0x%lx/0x%x), bf(%d)\n",
+			LOG_DBG("[vpu_%d] algo_%d ptr/length (0x%lx/0x%x), bf(%d)\n",
 				core, algo->id[core],
 				(unsigned long)algo->bin_ptr,
 				algo->bin_length,
@@ -5016,7 +5030,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 		vpu_write_field(core, FLD_CTL_INT, 1);
 
 	if (g_vpu_log_level > Log_STATE_MACHINE) {
-		LOG_INF("[0x%lx]:load algo start ",
+		LOG_DBG("[0x%lx]:load algo start ",
 			(unsigned long)request->request_id);
 	}
 		/* 3. wait until done */
@@ -5029,7 +5043,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 			ret |= vpu_check_postcond(core);
 
 		if (g_vpu_log_level > Log_ALGO_OPP_INFO)
-			LOG_INF("[vpu_%d] algo_%d %s=0x%lx, %s=%d, %s=%d, %s=%d, %d\n",
+			LOG_DBG("[vpu_%d] algo_%d %s=0x%lx, %s=%d, %s=%d, %s=%d, %d\n",
 			core, algo->id[core],
 			"bin_ptr", (unsigned long)algo->bin_ptr,
 			"done", vpu_service_cores[core].is_cmd_done,
@@ -5123,7 +5137,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 	vpu_write_field(core, FLD_CTL_INT, 1);
 	ktime_get_ts(&start);
 	if (g_vpu_log_level > Log_ALGO_OPP_INFO)
-		LOG_INF("[0x%lx]:d2d start ",
+		LOG_DBG("[0x%lx]:d2d start ",
 		(unsigned long)request->request_id);
 	/* 3. wait until done */
 	ret = wait_command(core);
@@ -5135,7 +5149,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 		ret |= vpu_check_postcond(core);
 
 	if (g_vpu_log_level > VpuLogThre_PERFORMANCE) {
-		LOG_INF("[vpu_%d] end d2d, done(%d), ret(%d), info00(%d), %d\n",
+		LOG_DBG("[vpu_%d] end d2d, done(%d), ret(%d), info00(%d), %d\n",
 			core,
 			vpu_service_cores[core].is_cmd_done, ret,
 			vpu_read_field(core, FLD_XTENSA_INFO00),
@@ -5159,7 +5173,7 @@ int vpu_hw_processing_request(int core_s, struct vpu_request *request)
 	latency += (uint64_t)(timespec_to_ns(&end) -
 		timespec_to_ns(&start));
 if (g_vpu_log_level > Log_STATE_MACHINE) {
-	LOG_INF("[0x%lx]:load algo + d2d latency[%lld] ",
+	LOG_DBG("[0x%lx]:load algo + d2d latency[%lld] ",
 		(unsigned long)request->request_id, latency);
 }
 	#ifdef ENABLE_PMQOS
@@ -5217,7 +5231,7 @@ out2:
 	request->bandwidth = vpu_cmd_qos_end(core);
 #endif
 if (g_vpu_log_level > Log_STATE_MACHINE) {
-	LOG_INF("[0x%lx]:vpu busy_time[%lld],bw[%d] ",
+	LOG_DBG("[0x%lx]:vpu busy_time[%lld],bw[%d] ",
 		(unsigned long)request->request_id,
 		request->busy_time, request->bandwidth);
 }
@@ -5261,7 +5275,7 @@ int vpu_hw_get_algo_info(int core_s, struct vpu_algo *algo)
 	ofs_sett_descs = ofs_info_descs +
 			sizeof(((struct vpu_algo *)0)->info_descs);
 
-	LOG_INF("[vpu_%d] %s check precond done\n", core, __func__);
+	LOG_DBG("[vpu_%d] %s check precond done\n", core, __func__);
 
 	/* 1. write register */
 	vpu_write_field(core, FLD_XTENSA_INFO01, VPU_CMD_GET_ALGO);
@@ -5288,7 +5302,7 @@ int vpu_hw_get_algo_info(int core_s, struct vpu_algo *algo)
 	if (ret == -ERESTARTSYS)
 		is_hw_fail = false;
 
-	LOG_INF("[vpu_%d] VPU_CMD_GET_ALGO done\n", core);
+	LOG_DBG("[vpu_%d] VPU_CMD_GET_ALGO done\n", core);
 	vpu_trace_end();
 	if (ret) {
 		vpu_err_hnd(is_hw_fail, core,
@@ -5616,7 +5630,7 @@ int vpu_dump_mesg_seq(struct seq_file *s, int core_s)
 		(void *)(vpu_service_cores[core].work_buf->va + VPU_OFFSET_LOG),
 		VPU_SIZE_LOG_BUF, true);
 	} else
-		pr_info("%s: NULL handle for dump!\n", __func__);
+		pr_debug("%s: NULL handle for dump!\n", __func__);
 	return 0;
 }
 
@@ -5821,7 +5835,7 @@ int vpu_set_power_parameter(uint8_t param, int argc, int *args)
 		vpu_lock_power.priority = POWER_HAL;
 		vpu_lock_power.max_boost_value = args[2];
 		vpu_lock_power.min_boost_value = args[1];
-		LOG_INF("[vpu]POWER_HAL_LOCK+core:%d, maxb:%d, minb:%d\n",
+		LOG_DBG("[vpu]POWER_HAL_LOCK+core:%d, maxb:%d, minb:%d\n",
 			vpu_lock_power.core, vpu_lock_power.max_boost_value,
 				vpu_lock_power.min_boost_value);
 		ret = vpu_lock_set_power(&vpu_lock_power);
@@ -5862,7 +5876,7 @@ int vpu_set_power_parameter(uint8_t param, int argc, int *args)
 		vpu_lock_power.priority = EARA_QOS;
 		vpu_lock_power.max_boost_value = args[2];
 		vpu_lock_power.min_boost_value = args[1];
-		LOG_INF("[vpu]EARA_LOCK+core:%d, maxb:%d, minb:%d\n",
+		LOG_DBG("[vpu]EARA_LOCK+core:%d, maxb:%d, minb:%d\n",
 			vpu_lock_power.core, vpu_lock_power.max_boost_value,
 				vpu_lock_power.min_boost_value);
 		ret = vpu_lock_set_power(&vpu_lock_power);
@@ -5996,7 +6010,7 @@ bool vpu_update_lock_power_parameter(struct vpu_lock_power *vpu_lock_power)
 	lock_power[priority][core].lock = true;
 	lock_power[priority][core].priority =
 		vpu_lock_power->priority;
-LOG_INF("power_parameter core %d, maxb:%d, minb:%d priority %d\n",
+LOG_DBG("power_parameter core %d, maxb:%d, minb:%d priority %d\n",
 		lock_power[priority][core].core,
 		lock_power[priority][core].max_boost_value,
 		lock_power[priority][core].min_boost_value,
@@ -6031,7 +6045,7 @@ bool vpu_update_unlock_power_parameter(struct vpu_lock_power *vpu_lock_power)
 	lock_power[priority][core].lock = false;
 	lock_power[priority][core].priority =
 		vpu_lock_power->priority;
-	LOG_INF("%s\n", __func__);
+	LOG_DBG("%s\n", __func__);
 	return ret;
 }
 uint8_t min_of(uint8_t value1, uint8_t value2)
diff --git a/drivers/misc/mediatek/vpu/mt6785/vpu_profile.c b/drivers/misc/mediatek/vpu/mt6785/vpu_profile.c
index b76c1a24c..332835445 100644
--- a/drivers/misc/mediatek/vpu/mt6785/vpu_profile.c
+++ b/drivers/misc/mediatek/vpu/mt6785/vpu_profile.c
@@ -290,7 +290,7 @@ static int vpu_profile_start(int core)
 
 static int vpu_profile_stop(int type)
 {
-	LOG_INF("%s (%d)+\n", __func__, type);
+	LOG_DBG("%s (%d)+\n", __func__, type);
 	if (type)
 		stop_result = vpu_profile_timer_try_stop();
 	else
@@ -310,7 +310,7 @@ int vpu_profile_state_set(int core, int val)
 		mutex_lock(&profile_mutex);
 		profiling_counter--;
 		vpu_on[core] = false;
-		LOG_INF("[vpu_profile_%d->%d] (stop) counter(%d, %d)\n",
+		LOG_DBG("[vpu_profile_%d->%d] (stop) counter(%d, %d)\n",
 			core, vpu_on[core], m_vpu_profile_state,
 			profiling_counter);
 
@@ -326,7 +326,7 @@ int vpu_profile_state_set(int core, int val)
 		mutex_lock(&profile_mutex);
 		profiling_counter++;
 		vpu_on[core] = true;
-		LOG_INF("[vpu_profile_%d->%d] (start) counter(%d, %d)\n",
+		LOG_DBG("[vpu_profile_%d->%d] (start) counter(%d, %d)\n",
 			core, vpu_on[core], m_vpu_profile_state,
 			profiling_counter);
 		m_vpu_profile_state = val;
diff --git a/drivers/misc/mediatek/vpu/mt6785/vpu_qos.c b/drivers/misc/mediatek/vpu/mt6785/vpu_qos.c
index 006f34098..369012822 100644
--- a/drivers/misc/mediatek/vpu/mt6785/vpu_qos.c
+++ b/drivers/misc/mediatek/vpu/mt6785/vpu_qos.c
@@ -100,7 +100,7 @@ static int add_qos_request(struct pm_qos_request *req)
 static void update_qos_request(struct pm_qos_request *req, int32_t val)
 {
 	if (g_vpu_log_level > VpuLogThre_PERFORMANCE)
-		LOG_INF("[vpu][qos] %s, peakBw=%d -\n", __func__, val);
+		LOG_DBG("[vpu][qos] %s, peakBw=%d -\n", __func__, val);
 
 	pm_qos_update_request(req, val);
 }
@@ -262,7 +262,7 @@ static int deque_cmd_qos(struct qos_counter *counter)
 	};
 
 	if (g_vpu_log_level > VpuLogThre_PERFORMANCE) {
-		LOG_INF("[vpu][qos] cmd:bw(%d/%d)\n",
+		LOG_DBG("[vpu][qos] cmd:bw(%d/%d)\n",
 			avg_bw, cmd_qos->total_bw);
 	}
 
diff --git a/drivers/misc/mediatek/vpu/mt6785/vpu_reg.c b/drivers/misc/mediatek/vpu/mt6785/vpu_reg.c
index 00c1e9e2f..280e8db56 100644
--- a/drivers/misc/mediatek/vpu/mt6785/vpu_reg.c
+++ b/drivers/misc/mediatek/vpu/mt6785/vpu_reg.c
@@ -293,7 +293,7 @@ int vpu_init_reg(int core, struct vpu_device *device)
 	vpu_write_reg32(device->vpu_syscfg_base, 0xF0, 0x3FE0E000);
 	vpu_write_reg32(device->vpu_syscfg_base, 0x118, 0x3FE0E000);
 
-	LOG_INF("After 0x1900_00F0=0x%08X, 0x1900_0118=0x%08X\n",
+	LOG_DBG("After 0x1900_00F0=0x%08X, 0x1900_0118=0x%08X\n",
 			vpu_read_reg32(device->vpu_syscfg_base, 0xF0),
 			vpu_read_reg32(device->vpu_syscfg_base, 0x118));
 
diff --git a/drivers/misc/mediatek/zone_movable_cma/single_cma.c b/drivers/misc/mediatek/zone_movable_cma/single_cma.c
index 580ea5b16..1121c68fd 100644
--- a/drivers/misc/mediatek/zone_movable_cma/single_cma.c
+++ b/drivers/misc/mediatek/zone_movable_cma/single_cma.c
@@ -77,7 +77,7 @@ static void __init check_and_fix_base(struct reserved_mem *rmem,
 {
 	phys_addr_t new_zmc_base, return_size;
 
-	pr_info("%s: total phys size: %pa\n", __func__, &total_phys_size);
+	pr_debug("%s: total phys size: %pa\n", __func__, &total_phys_size);
 
 	/* No need to fix if the size of DRAM is less or equal to 4GB */
 	if (total_phys_size <= 0x100000000ULL)
@@ -99,7 +99,7 @@ static void __init check_and_fix_base(struct reserved_mem *rmem,
 		memblock_add(rmem->base, return_size);
 		rmem->base = new_zmc_base;
 		rmem->size -= return_size;
-		pr_info("%s: new base: %pa, new size: %pa\n",
+		pr_debug("%s: new base: %pa, new size: %pa\n",
 				__func__, &rmem->base, &rmem->size);
 	}
 }
@@ -118,7 +118,7 @@ static bool __init zmc_is_the_last(struct reserved_mem *rmem)
 	phys_addr_t rmem_end_max = rmem->base + rmem->size +
 		(pageblock_nr_pages << PAGE_SHIFT);
 
-	pr_info("%s: phys end: %pa, rmem end max: %pa\n",
+	pr_debug("%s: phys end: %pa, rmem end max: %pa\n",
 			__func__, &phys_end, &rmem_end_max);
 
 	if (rmem_end_max >= phys_end)
@@ -136,12 +136,12 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 	phys_addr_t zmc_size = rmem->size;
 	phys_addr_t total_phys_size = memblock_phys_mem_size();
 
-	pr_info("%s, name: %s, base: %pa, size: %pa\n", __func__,
+	pr_debug("%s, name: %s, base: %pa, size: %pa\n", __func__,
 			rmem->name, &rmem->base, &rmem->size);
 
 #ifdef CONFIG_MTK_MEMORY_LOWPOWER
 	if (!zmc_is_the_last(rmem)) {
-		pr_info("[Fail] ZMC is not the last\n");
+		pr_debug("[Fail] ZMC is not the last\n");
 		memblock_free(rmem->base, rmem->size);
 		memblock_add(rmem->base, rmem->size);
 		return -1;
@@ -161,7 +161,7 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 	for (order = 0; order < NR_ZMC_LOCATIONS; order++) {
 		struct single_cma_registration *p;
 
-		pr_info("Start to zone: %d\n", order);
+		pr_debug("Start to zone: %d\n", order);
 		for (i = 0; i < ARRAY_SIZE(single_cma_list[order]); i++) {
 			phys_addr_t start, end;
 
@@ -175,9 +175,9 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 			}
 
 			end = rmem->base + rmem->size;
-			pr_info("::[%s]: size: %pa, align: %pa\n",
+			pr_debug("::[%s]: size: %pa, align: %pa\n",
 					p->name, &p->size, &p->align);
-			pr_info("::[%pa-%pa] remain of rmem\n",
+			pr_debug("::[%pa-%pa] remain of rmem\n",
 					&rmem->base, &end);
 
 			if (p->flag & ZMC_ALLOC_ALL)
@@ -195,16 +195,16 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 						   p->size, alignment);
 
 				if (start < rmem->base) {
-					pr_info("::[Reserve fail]: insufficient memory.\n");
-					pr_info("::[%pa - %pa] remain of rmem\n",
+					pr_debug("::[Reserve fail]: insufficient memory.\n");
+					pr_debug("::[%pa - %pa] remain of rmem\n",
 							&rmem->base, &end);
-					pr_info("::[%pa - %pa] to cma init\n",
+					pr_debug("::[%pa - %pa] to cma init\n",
 							&start, &end);
 					continue;
 				}
 			}
 
-			pr_info("::cma_init_reserved_mem - [%pa - %pa]\n",
+			pr_debug("::cma_init_reserved_mem - [%pa - %pa]\n",
 					&start, &end);
 			ret = cma_init_reserved_mem(start,
 						    end - start,
@@ -212,7 +212,7 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 						    rmem->name,
 						    &cma[cma_area_count]);
 			if (ret) {
-				pr_info(":: %s cma failed at %d, ret: %d\n",
+				pr_debug(":: %s cma failed at %d, ret: %d\n",
 						__func__, cma_area_count, ret);
 				continue;
 			}
@@ -227,7 +227,7 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 			if (order == ZMC_LOCATE_MOVABLE) {
 				movable_min = min(movable_min, start);
 				movable_max = max(movable_max, end);
-				pr_info("===> MOVABLE ZONE: Update range[%pa,%pa)\n",
+				pr_debug("===> MOVABLE ZONE: Update range[%pa,%pa)\n",
 						&movable_min, &movable_max);
 			}
 
@@ -236,7 +236,7 @@ static int __init zmc_memory_init(struct reserved_mem *rmem)
 
 			cma_area_count++;
 			zmc_reserved_mem_inited = true;
-			pr_info("::[PASS]: %s[%pa-%pa] (rmem->size=%pa)\n",
+			pr_debug("::[PASS]: %s[%pa-%pa] (rmem->size=%pa)\n",
 					p->name, &start, &end, &rmem->size);
 		}
 	}
@@ -260,7 +260,7 @@ bool is_zmc_inited(void)
 void zmc_get_range(phys_addr_t *base, phys_addr_t *size)
 {
 	if (movable_max > movable_min) {
-		pr_info("Query return: [%pa,%pa)\n",
+		pr_debug("Query return: [%pa,%pa)\n",
 				&movable_min, &movable_max);
 		*base = movable_min;
 		*size = movable_max - movable_min;
@@ -289,7 +289,7 @@ static bool system_mem_status_ok(unsigned long count)
 		}
 	}
 
-	pr_info("%s: free(%lu) file(%lu) high(%lu) count(%lu)\n",
+	pr_debug("%s: free(%lu) file(%lu) high(%lu) count(%lu)\n",
 			__func__, free, file, high_wmark, count);
 
 	/* Hope the system has as less memory reclaim as possible */
@@ -318,7 +318,7 @@ static bool zmc_check_mem_status_ok(unsigned long count)
 		available += minus;
 	}
 
-	pr_info("%s: count(%lu) free(%lu) available(%lu) minus(%lu)\n",
+	pr_debug("%s: count(%lu) free(%lu) available(%lu) minus(%lu)\n",
 			__func__, count, free, available, minus);
 
 	/*
@@ -345,7 +345,7 @@ struct page *zmc_cma_alloc(struct cma *cma, int count,
 
 	/* Check current memory status before proceeding */
 	if (p->prio >= ZMC_CHECK_MEM_STAT && !zmc_check_mem_status_ok(count)) {
-		pr_info("%s: mem status is not ok\n", __func__);
+		pr_debug("%s: mem status is not ok\n", __func__);
 		return NULL;
 	}
 
@@ -360,7 +360,7 @@ struct page *zmc_cma_alloc(struct cma *cma, int count,
 	 * for memory reclaim or abort cma_alloc.
 	 */
 	if (!cma_alloc_range_ok(cma, count, align)) {
-		pr_info("No more space in zone movable cma\n");
+		pr_debug("No more space in zone movable cma\n");
 		return NULL;
 	}
 
@@ -376,7 +376,7 @@ retry:
 			candidate != NULL &&
 			page_to_pfn(candidate) == ABANDON_PFN) {
 		abandon = candidate;
-		pr_info("%s %p is abandoned\n", __func__, candidate);
+		pr_debug("%s %p is abandoned\n", __func__, candidate);
 		goto retry;
 	}
 
diff --git a/drivers/power/supply/mediatek/battery_begonia/mtk_battery.c b/drivers/power/supply/mediatek/battery_begonia/mtk_battery.c
index 5f32e397a..b9239a13b 100644
--- a/drivers/power/supply/mediatek/battery_begonia/mtk_battery.c
+++ b/drivers/power/supply/mediatek/battery_begonia/mtk_battery.c
@@ -189,13 +189,13 @@ int __attribute__ ((weak))
 
 void __attribute__ ((weak)) enable_bat_temp_det(bool en)
 {
-	pr_notice("[%s] not support!\n", __func__);
+	pr_err("[%s] not support!\n", __func__);
 }
 
 unsigned int __attribute__ ((weak)) mt6358_irq_get_virq(struct device *dev,
 							unsigned int hwirq)
 {
-	pr_notice_once("%s: API not ready!\n", __func__);
+	pr_err("%s: API not ready!\n", __func__);
 	return 0;
 }
 
@@ -413,7 +413,7 @@ static int bms_get_property(struct power_supply *psy,
 		}
 		break;
 	case POWER_SUPPLY_PROP_BATTERY_TYPE:
-		pr_info("gm.battery_id :%d.\n", gm.battery_id);
+		pr_debug("gm.battery_id :%d.\n", gm.battery_id);
 		switch (gm.battery_id) {
 		case 0:
 			val->strval = "g7_nvt";
@@ -687,7 +687,7 @@ void battery_update(struct battery_data *bat_data)
 		bm_err("battery_update set FULL! ui:%d chr:%d %d\n",
 			bat_data->BAT_CAPACITY, upmu_get_rgs_chrdet(), bat_data->BAT_STATUS);
 
-		bm_trace("battery_update status: ui:%d chr:%d status%d\n",
+		bm_debug("battery_update status: ui:%d chr:%d status%d\n",
 			bat_data->BAT_CAPACITY, upmu_get_rgs_chrdet(), bat_data->BAT_STATUS);
 	}
 #if defined(CONFIG_MTK_DISABLE_GAUGE)
@@ -1486,7 +1486,7 @@ int BattThermistorConverTemp(int Res)
 		TBatt_Value = (((Res - RES2) * TMP1) +
 			((RES1 - Res) * TMP2)) * 10 / (RES1 - RES2);
 	}
-	bm_trace(
+	bm_debug(
 		"[%s] %d %d %d %d %d %d\n",
 		__func__,
 		RES1, RES2, Res, TMP1,
@@ -1538,7 +1538,7 @@ unsigned int TempToBattVolt(int temp, int update)
 			(fg_meter_res_value + fg_r_value)) / 10000);
 	}
 
-	bm_notice("[%s] temp %d R_NTC %d V(%lld %lld) I %d CHG %d\n",
+	bm_debug("[%s] temp %d R_NTC %d V(%lld %lld) I %d CHG %d\n",
 		__func__,
 		temp, R_NTC, Vin, V_IR_comp, fg_current_temp, fg_current_state);
 
@@ -1603,7 +1603,7 @@ int BattVoltToTemp(int dwVolt, int volt_cali)
 		sBaTTMP = BattThermistorConverTemp((int)TRes -
 		gm.rbat.bif_ntc_r);
 
-	bm_notice(
+	bm_debug(
 		"[%s] %d %d %d %d\n",
 		__func__,
 		dwVolt, gm.rbat.rbat_pull_up_r,
@@ -1696,7 +1696,7 @@ int force_get_tbat_internal(bool update)
 #ifdef CONFIG_MTK_BIF_SUPPORT
 		/*	CHARGING_CMD_GET_BIF_TBAT need fix */
 #endif
-		bm_notice("[force_get_tbat] %d,%d,%d,%d,%d,%d r:%d %d %d\n",
+		bm_debug("[force_get_tbat] %d,%d,%d,%d,%d,%d r:%d %d %d\n",
 		bat_temperature_volt_temp, bat_temperature_volt,
 		fg_current_state, fg_current_temp,
 		fg_r_value, bat_temperature_val,
@@ -1745,7 +1745,7 @@ int force_get_tbat_internal(bool update)
 			pre_fg_r_value = fg_r_value;
 			pre_bat_temperature_val2 = bat_temperature_val;
 			pre_time = ctime;
-			bm_trace(
+			bm_debug(
 			"[force_get_tbat] current:%d,%d,%d,%d,%d,%d pre:%d,%d,%d,%d,%d,%d time:%d\n",
 			bat_temperature_volt_temp, bat_temperature_volt,
 			fg_current_state, fg_current_temp,
@@ -2135,7 +2135,7 @@ void fg_ocv_query_soc(int ocv)
 		FG_INTR_KERNEL_CMD, FG_KERNEL_CMD_REQ_ALGO_DATA,
 		ocv);
 
-	bm_trace("[%s] ocv:%d\n",
+	bm_debug("[%s] ocv:%d\n",
 		__func__, ocv);
 }
 
@@ -3162,7 +3162,7 @@ void exec_BAT_EC(int cmd, int param)
 static ssize_t show_FG_daemon_disable(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG] show FG disable : %d\n", gm.disableGM30);
+	bm_debug("[FG] show FG disable : %d\n", gm.disableGM30);
 	return sprintf(buf, "%d\n", gm.disableGM30);
 }
 
@@ -3184,7 +3184,7 @@ static DEVICE_ATTR(
 static ssize_t show_FG_meter_resistance(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace(
+	bm_debug(
 		"[FG] show com_fg_meter_resistance : %d\n",
 		fg_cust_data.com_fg_meter_resistance);
 	return sprintf(buf, "%d\n", fg_cust_data.com_fg_meter_resistance);
@@ -3228,7 +3228,7 @@ static DEVICE_ATTR(
 static ssize_t show_FG_nafg_disable(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG] show nafg disable : %d\n", gm.cmd_disable_nafg);
+	bm_debug("[FG] show nafg disable : %d\n", gm.cmd_disable_nafg);
 	return sprintf(buf, "%d\n", gm.cmd_disable_nafg);
 }
 
@@ -3277,7 +3277,7 @@ static DEVICE_ATTR(
 static ssize_t show_FG_ntc_disable_nafg(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG]%s: %d\n", __func__, gm.ntc_disable_nafg);
+	bm_debug("[FG]%s: %d\n", __func__, gm.ntc_disable_nafg);
 	return sprintf(buf, "%d\n", gm.ntc_disable_nafg);
 }
 
@@ -3331,7 +3331,7 @@ static DEVICE_ATTR(
 static ssize_t show_uisoc_update_type(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG] %s : %d\n",
+	bm_debug("[FG] %s : %d\n",
 		__func__,
 		fg_cust_data.uisoc_update_type);
 	return sprintf(buf, "%d\n", fg_cust_data.uisoc_update_type);
@@ -3442,7 +3442,7 @@ static DEVICE_ATTR(FG_daemon_log_level, 0664,
 static ssize_t show_shutdown_cond_enable(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace(
+	bm_debug(
 		"[FG] %s : %d\n",
 		__func__,
 		get_shutdown_cond_flag());
@@ -3486,7 +3486,7 @@ static DEVICE_ATTR(
 static ssize_t show_reset_battery_cycle(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG] %s : %d\n",
+	bm_debug("[FG] %s : %d\n",
 		__func__,
 		gm.is_reset_battery_cycle);
 	return sprintf(buf, "%d\n", gm.is_reset_battery_cycle);
@@ -3532,7 +3532,7 @@ static DEVICE_ATTR(
 static ssize_t show_reset_aging_factor(
 	struct device *dev, struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG] %s : %d\n",
+	bm_debug("[FG] %s : %d\n",
 		__func__,
 		gm.is_reset_aging_factor);
 	return sprintf(buf, "%d\n", gm.is_reset_aging_factor);
@@ -3790,7 +3790,7 @@ struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	int adc_out_datas[2] = { 1, 1 };
 
-	bm_notice("%s 32bit IOCTL, cmd=0x%08x\n",
+	bm_debug("%s 32bit IOCTL, cmd=0x%08x\n",
 		__func__, cmd);
 	if (!filp->f_op || !filp->f_op->unlocked_ioctl) {
 		bm_err("%s file has no f_op or no f_op->unlocked_ioctl.\n",
@@ -3810,7 +3810,7 @@ struct file *filp, unsigned int cmd, unsigned long arg)
 	case Set_META_BAT_CAR_TUNE_VALUE:
 	case Set_BAT_DISABLE_NAFG:
 	case Set_CARTUNE_TO_KERNEL: {
-		bm_notice(
+		bm_debug(
 			"%s send to unlocked_ioctl cmd=0x%08x\n",
 			__func__,
 			cmd);
@@ -3841,7 +3841,7 @@ static long adc_cali_ioctl(
 	int temp_car_tune;
 	int isdisNAFG = 0;
 
-	bm_notice("%s enter\n", __func__);
+	bm_debug("%s enter\n", __func__);
 	mutex_lock(&gm.fg_mutex);
 	user_data_addr = (int *)arg;
 	ret = copy_from_user(adc_in_data, user_data_addr, sizeof(adc_in_data));
@@ -3867,9 +3867,9 @@ static long adc_cali_ioctl(
 				*(adc_cali_slop + i) = 1000;
 		}
 		for (i = 0; i < 14; i++)
-			bm_notice("adc_cali_slop[%d] = %d\n", i,
+			bm_debug("adc_cali_slop[%d] = %d\n", i,
 				    *(adc_cali_slop + i));
-		bm_notice("**** unlocked_ioctl : SET_ADC_CALI_Slop Done!\n");
+		bm_debug("**** unlocked_ioctl : SET_ADC_CALI_Slop Done!\n");
 		break;
 
 	case SET_ADC_CALI_Offset:
@@ -3877,9 +3877,9 @@ static long adc_cali_ioctl(
 		ret = copy_from_user(adc_cali_offset, naram_data_addr, 36);
 		g_ADC_Cali = false;
 		for (i = 0; i < 14; i++)
-			bm_notice("adc_cali_offset[%d] = %d\n", i,
+			bm_debug("adc_cali_offset[%d] = %d\n", i,
 				    *(adc_cali_offset + i));
-		bm_notice("**** unlocked_ioctl : SET_ADC_CALI_Offset Done!\n");
+		bm_debug("**** unlocked_ioctl : SET_ADC_CALI_Offset Done!\n");
 		break;
 
 	case SET_ADC_CALI_Cal:
@@ -3892,9 +3892,9 @@ static long adc_cali_ioctl(
 			g_ADC_Cali = false;
 
 		for (i = 0; i < 1; i++)
-			bm_notice("adc_cali_cal[%d] = %d\n", i,
+			bm_debug("adc_cali_cal[%d] = %d\n", i,
 				    *(adc_cali_cal + i));
-		bm_notice("**** unlocked_ioctl : SET_ADC_CALI_Cal Done!\n");
+		bm_debug("**** unlocked_ioctl : SET_ADC_CALI_Cal Done!\n");
 		break;
 
 	case ADC_CHANNEL_READ:
@@ -3918,7 +3918,7 @@ static long adc_cali_ioctl(
 		} else if (adc_in_data[0] == 66)
 			adc_out_data[0] = (battery_get_bat_current()) / 10;
 		else {
-			bm_notice("unknown channel(%d,%d)\n",
+			bm_err("unknown channel(%d,%d)\n",
 				    adc_in_data[0], adc_in_data[1]);
 		}
 
@@ -3934,7 +3934,7 @@ static long adc_cali_ioctl(
 			adc_out_data[1] = 0;	/* success */
 
 		ret = copy_to_user(user_data_addr, adc_out_data, 8);
-		bm_notice(
+		bm_debug(
 			    "**** unlocked_ioctl : Channel %d * %d times = %d\n",
 			    adc_in_data[0], adc_in_data[1], adc_out_data[0]);
 		break;
@@ -3948,7 +3948,7 @@ static long adc_cali_ioctl(
 		else
 			battery_out_data[0] = 0;
 		ret = copy_to_user(user_data_addr, battery_out_data, 4);
-		bm_notice(
+		bm_debug(
 			"unlocked_ioctl : CAL:%d\n", battery_out_data[0]);
 		break;
 #if 0
@@ -3991,7 +3991,7 @@ static long adc_cali_ioctl(
 		else
 			charging_level_data[0] = CHARGE_CURRENT_450_00_MA;
 		wake_up_bat();
-		bm_notice("**** unlocked_ioctl : set_Charger_Current:%d\n",
+		bm_debug("**** unlocked_ioctl : set_Charger_Current:%d\n",
 			    charging_level_data[0]);
 		break;
 #endif
@@ -4004,7 +4004,7 @@ static long adc_cali_ioctl(
 			return -EFAULT;
 		}
 
-		bm_notice("**** unlocked_ioctl :Get_META_BAT_VOL Done!\n");
+		bm_debug("**** unlocked_ioctl :Get_META_BAT_VOL Done!\n");
 		break;
 	case Get_META_BAT_SOC:
 		adc_out_data[0] = battery_get_uisoc();
@@ -4015,7 +4015,7 @@ static long adc_cali_ioctl(
 			return -EFAULT;
 		}
 
-		bm_notice("**** unlocked_ioctl :Get_META_BAT_SOC Done!\n");
+		bm_debug("**** unlocked_ioctl :Get_META_BAT_SOC Done!\n");
 		break;
 
 	case Get_META_BAT_CAR_TUNE_VALUE:
@@ -4028,7 +4028,7 @@ static long adc_cali_ioctl(
 			return -EFAULT;
 		}
 
-		bm_notice("**** unlocked_ioctl :Get_META_BAT_CAR_TUNE_VALUE Done!\n");
+		bm_debug("**** unlocked_ioctl :Get_META_BAT_CAR_TUNE_VALUE Done!\n");
 		break;
 
 	case Set_META_BAT_CAR_TUNE_VALUE:
@@ -4157,13 +4157,13 @@ static int __init battery_probe(struct platform_device *dev)
 /********* adc_cdev **********/
 	ret = alloc_chrdev_region(&adc_cali_devno, 0, 1, ADC_CALI_DEVNAME);
 	if (ret)
-		bm_notice("Error: Can't Get Major number for adc_cali\n");
+		bm_err("Error: Can't Get Major number for adc_cali\n");
 	adc_cali_cdev = cdev_alloc();
 	adc_cali_cdev->owner = THIS_MODULE;
 	adc_cali_cdev->ops = &adc_cali_fops;
 	ret = cdev_add(adc_cali_cdev, adc_cali_devno, 1);
 	if (ret)
-		bm_notice("adc_cali Error: cdev_add\n");
+		bm_err("adc_cali Error: cdev_add\n");
 	adc_cali_major = MAJOR(adc_cali_devno);
 	adc_cali_class = class_create(THIS_MODULE, ADC_CALI_DEVNAME);
 	class_dev = (struct class_device *)device_create(adc_cali_class,
diff --git a/drivers/power/supply/mediatek/battery_begonia/mtk_battery_core.c b/drivers/power/supply/mediatek/battery_begonia/mtk_battery_core.c
index 15bba0c55..a815e9bc3 100644
--- a/drivers/power/supply/mediatek/battery_begonia/mtk_battery_core.c
+++ b/drivers/power/supply/mediatek/battery_begonia/mtk_battery_core.c
@@ -352,7 +352,7 @@ int gauge_get_nag_dltv(void)
 /* ============================================================ */
 bool __attribute__ ((weak)) mt_usb_is_device(void)
 {
-	pr_notice_once("%s: usb is not ready\n", __func__);
+	pr_err("%s: usb is not ready\n", __func__);
 	return false;
 }
 
@@ -2167,7 +2167,7 @@ void fg_bat_plugout_int_handler_gm25(void)
 	bool is_bat_exist;
 
 	is_bat_exist = pmic_is_battery_exist();
-	pr_info("%s: bat_exist: %d\n", __func__, is_bat_exist);
+	pr_debug("%s: bat_exist: %d\n", __func__, is_bat_exist);
 
 	if (fg_interrupt_check() == false)
 		return;
@@ -2487,7 +2487,7 @@ void fg_daemon_send_data(
 	prcv = (struct fgd_cmd_param_t_6 *)rcv;
 	pret = (struct fgd_cmd_param_t_6 *)ret;
 
-	bm_trace("%s type:%d, tsize:%d size:%d idx:%d\n",
+	bm_debug("%s type:%d, tsize:%d size:%d idx:%d\n",
 		__func__,
 		prcv->type,
 		prcv->total_size,
@@ -3489,7 +3489,7 @@ void bmd_ctrl_cmd_from_user(void *nl_data, struct fgd_nl_msg_t *ret_msg)
 
 		gauge_set_nag_en(nafg_zcv_en);
 
-		bm_trace(
+		bm_debug(
 			"[fr] FG_DAEMON_CMD_SET_NAG_ZCV_EN = %d\n",
 			nafg_zcv_en);
 	}
@@ -3768,7 +3768,7 @@ void bmd_ctrl_cmd_from_user(void *nl_data, struct fgd_nl_msg_t *ret_msg)
 					sizeof(gm.gdev->fg_hw_info.ncar));
 			}
 
-			bm_trace(
+			bm_debug(
 				"FG_DAEMON_CMD_GET_HW_INFO(NCAR):%d %d, cmdtype:%d\n",
 				gm.bat_cycle_ncar,
 				gm.gdev->fg_hw_info.ncar, cmdtype);
@@ -3779,7 +3779,7 @@ void bmd_ctrl_cmd_from_user(void *nl_data, struct fgd_nl_msg_t *ret_msg)
 				&gm.hw_status, intr_no);
 		}
 
-		bm_trace(
+		bm_debug(
 			"[fr] FG_DAEMON_CMD_GET_HW_INFO = %d\n", intr_no);
 	}
 	break;
diff --git a/drivers/power/supply/mediatek/battery_begonia/mtk_battery_internal.h b/drivers/power/supply/mediatek/battery_begonia/mtk_battery_internal.h
index b5d6c94d3..701703175 100644
--- a/drivers/power/supply/mediatek/battery_begonia/mtk_battery_internal.h
+++ b/drivers/power/supply/mediatek/battery_begonia/mtk_battery_internal.h
@@ -67,14 +67,14 @@
 #define bm_err(fmt, args...)   \
 do {\
 	if (bat_get_debug_level() >= BMLOG_ERROR_LEVEL) {\
-		pr_notice(fmt, ##args); \
+		pr_err(fmt, ##args); \
 	} \
 } while (0)
 
 #define bm_warn(fmt, args...)   \
 do {\
 	if (bat_get_debug_level() >= BMLOG_WARNING_LEVEL) {\
-		pr_notice(fmt, ##args); \
+		pr_warn(fmt, ##args); \
 	}								   \
 } while (0)
 
@@ -88,14 +88,14 @@ do {\
 #define bm_info(fmt, args...)   \
 do {\
 	if (bat_get_debug_level() >= BMLOG_INFO_LEVEL) {\
-		pr_notice(fmt, ##args); \
+		pr_info(fmt, ##args); \
 	}								   \
 } while (0)
 
 #define bm_debug(fmt, args...)   \
 do {\
 	if (bat_get_debug_level() >= BMLOG_DEBUG_LEVEL) {\
-		pr_notice(fmt, ##args); \
+		pr_debug(fmt, ##args); \
 	}								   \
 } while (0)
 
diff --git a/drivers/power/supply/mediatek/battery_begonia/mtk_battery_recovery.c b/drivers/power/supply/mediatek/battery_begonia/mtk_battery_recovery.c
index 76c2a82e8..fe0fdea02 100644
--- a/drivers/power/supply/mediatek/battery_begonia/mtk_battery_recovery.c
+++ b/drivers/power/supply/mediatek/battery_begonia/mtk_battery_recovery.c
@@ -966,13 +966,13 @@ void fgr_construct_battery_profile(int table_idx)
 			high_pseudo100,
 			temperature);
 
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]pseudo1_en:[%d] lowT %d %d %d lowPs1 %d highPs1 %d batterypseudo1_h [%d]\n",
 			pdata->pseudo1_en, low_temp,
 			high_temp, temperature,
 			low_pseudo1, high_pseudo1,
 			batterypseudo1_h);
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]pseudo100_en:[%d] %d lowT %d %d %d low100 %d %d [%d]\n",
 			pdata->pseudo100_en, pdata->pseudo100_en_dis,
 			low_temp, high_temp, temperature,
@@ -992,13 +992,13 @@ void fgr_construct_battery_profile(int table_idx)
 			high_temp, UNIT_TRANS_10 * high_qmax_h,
 			temperature);
 
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]lowT %d %d %d lowQ %d %d qmax_t_0ma_h [%d]\n",
 			low_temp, high_temp, temperature,
 			UNIT_TRANS_10 * low_qmax,
 			UNIT_TRANS_10 * high_qmax,
 			qmax_t_0ma_h);
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]lowT %d %d %d lowQh %d %d qmax_t_Nma_h [%d]\n",
 			low_temp, high_temp, temperature,
 			UNIT_TRANS_10 * low_qmax_h,
@@ -1010,7 +1010,7 @@ void fgr_construct_battery_profile(int table_idx)
 			high_temp, UNIT_TRANS_10 * high_shutdown_zcv,
 			temperature);
 
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]lowT %d %d %d LowShutZCV %d HighShutZCV %d shutdown_hl_zcv [%d]\n",
 			low_temp, high_temp, temperature,
 			UNIT_TRANS_10 * low_shutdown_zcv,
@@ -1031,13 +1031,13 @@ void fgr_construct_battery_profile(int table_idx)
 			high_temp, UNIT_TRANS_10 * high_qmax_h,
 			temperature);
 
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]lowT %d %d %d lowQ %d %d qmax_t_0ma_h [%d]\n",
 			low_temp, high_temp, temperature,
 			UNIT_TRANS_10 * low_qmax,
 			UNIT_TRANS_10 * high_qmax,
 			qmax_t_0ma_h_tb1);
-		bm_trace(
+		bm_debug(
 			"[Profile_Table]lowT %d %d %d lowQh %d %d qmax_t_Nma_h [%d]\n",
 			low_temp, high_temp, temperature,
 			UNIT_TRANS_10 * low_qmax_h,
@@ -1045,11 +1045,11 @@ void fgr_construct_battery_profile(int table_idx)
 			qmax_t_Nma_h_tb1);
 	}
 
-	bm_trace(
+	bm_debug(
 		"[Profile_Table]T_table %d T_table_c %d %d %d is_ascend %d %d\n",
 		T_table, T_table_c, pdata->pseudo1_en,
 		pdata->pseudo100_en, is_ascending, is_descending);
-	bm_trace(
+	bm_debug(
 		"[Profile_Table]Pseudo1_h %d %d, Qmax_T_0mA_H %d,%d qmax_t_0ma_h_tb1 %d %d\n",
 		batterypseudo1_h, batterypseudo100, qmax_t_0ma_h,
 		qmax_t_Nma_h, qmax_t_0ma_h_tb1, qmax_t_Nma_h_tb1);
@@ -1061,7 +1061,7 @@ void fg_construct_table_by_temp(bool update, int table_idx)
 
 	fg_temp = force_get_tbat(true);
 	if (fg_temp != last_temp || update == true) {
-		bm_trace(
+		bm_debug(
 			"[construct_table_by_temp] tempture from(%d)to(%d) Tb:%d",
 			last_temp, fg_temp, table_idx);
 		last_temp = fg_temp;
diff --git a/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_class.c b/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_class.c
index fef1cb0c0..ffe66d4a1 100644
--- a/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_class.c
+++ b/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_class.c
@@ -1049,7 +1049,7 @@ static int __init gauge_class_init(void)
 {
 	gauge_class = class_create(THIS_MODULE, "gauge");
 	if (IS_ERR(gauge_class)) {
-		pr_notice("Unable to create gauge class; errno = %ld\n",
+		pr_err("Unable to create gauge class; errno = %ld\n",
 			PTR_ERR(gauge_class));
 		return PTR_ERR(gauge_class);
 	}
diff --git a/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_coulomb_service.c b/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_coulomb_service.c
index adf0b242b..315f0779d 100644
--- a/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_coulomb_service.c
+++ b/drivers/power/supply/mediatek/battery_begonia/mtk_gauge_coulomb_service.c
@@ -45,14 +45,14 @@ int fix_coverity;
 #define ft_err(fmt, args...)   \
 do {									\
 	if (fgclog_level >= FTLOG_ERROR_LEVEL) {			\
-		pr_notice(fmt, ##args); \
+		pr_err(fmt, ##args); \
 	}								   \
 } while (0)
 
 #define ft_debug(fmt, args...)   \
 do {									\
 	if (fgclog_level >= FTLOG_DEBUG_LEVEL) {		\
-		pr_notice(fmt, ##args); \
+		pr_debug(fmt, ##args); \
 	}								   \
 } while (0)
 
@@ -284,7 +284,7 @@ void gauge_coulomb_start(struct gauge_consumer *coulomb, int car)
 	car_now = gauge_get_coulomb();
 	/* del from old list */
 	if (list_empty(&coulomb->list) != true) {
-		ft_trace("coulomb_start del name:%s s:%ld e:%ld v:%d car:%d\n",
+		ft_debug("coulomb_start del name:%s s:%ld e:%ld v:%d car:%d\n",
 		coulomb->name,
 		coulomb->start, coulomb->end, coulomb->variable, car_now);
 		list_del_init(&coulomb->list);
@@ -383,7 +383,7 @@ void gauge_coulomb_int_handler(void)
 
 	get_monotonic_boottime(&sstart[0]);
 	car = gauge_get_coulomb();
-	ft_trace("[%s] car:%d preCar:%d\n",
+	ft_debug("[%s] car:%d preCar:%d\n",
 		__func__,
 		car, pre_coulomb);
 	get_monotonic_boottime(&sstart[1]);
@@ -399,7 +399,7 @@ void gauge_coulomb_int_handler(void)
 				ptmp = pos;
 				pos = pos->next;
 				list_del_init(ptmp);
-				ft_trace(
+				ft_debug(
 					"[%s]+ %s s:%ld e:%ld car:%d %d int:%d timeout\n",
 					__func__,
 					ptr->name,
@@ -419,7 +419,7 @@ void gauge_coulomb_int_handler(void)
 			pos = coulomb_head_plus.next;
 			ptr = container_of(pos, struct gauge_consumer, list);
 			hw_car = ptr->end - car;
-			ft_trace(
+			ft_debug(
 				"[%s]+ %s %ld %ld %d now:%d dif:%d\n",
 				__func__,
 					ptr->name,
@@ -429,9 +429,9 @@ void gauge_coulomb_int_handler(void)
 			gauge_set_coulomb_interrupt1_ht(hw_car);
 			mutex_hw_coulomb_unlock();
 		} else
-			ft_trace("+ list is empty\n");
+			ft_debug("+ list is empty\n");
 	} else
-		ft_trace("+ list is empty\n");
+		ft_debug("+ list is empty\n");
 
 
 	if (list_empty(&coulomb_head_minus) != true) {
@@ -445,7 +445,7 @@ void gauge_coulomb_int_handler(void)
 				ptmp = pos;
 				pos = pos->next;
 				list_del_init(ptmp);
-				ft_trace(
+				ft_debug(
 					"[%s]- %s s:%ld e:%ld car:%d %d int:%d timeout\n",
 					__func__,
 					ptr->name,
@@ -466,7 +466,7 @@ void gauge_coulomb_int_handler(void)
 			pos = coulomb_head_minus.next;
 			ptr = container_of(pos, struct gauge_consumer, list);
 			hw_car = car - ptr->end;
-			ft_trace(
+			ft_debug(
 				"[%s]- %s %ld %ld %d now:%d dif:%d\n",
 				__func__,
 				ptr->name,
@@ -476,9 +476,9 @@ void gauge_coulomb_int_handler(void)
 			gauge_set_coulomb_interrupt1_lt(hw_car);
 			mutex_hw_coulomb_unlock();
 		} else
-			ft_trace("- list is empty\n");
+			ft_debug("- list is empty\n");
 	} else
-		ft_trace("- list is empty\n");
+		ft_debug("- list is empty\n");
 
 	pre_coulomb = car;
 	get_monotonic_boottime(&sstart[2]);
@@ -495,7 +495,7 @@ static int gauge_coulomb_thread(void *arg)
 		wait_event(wait_que, (coulomb_thread_timeout == true));
 		coulomb_thread_timeout = false;
 		get_monotonic_boottime(&start);
-		ft_trace("[%s]=>\n", __func__);
+		ft_debug("[%s]=>\n", __func__);
 		mutex_coulomb_lock();
 		gauge_coulomb_int_handler();
 		mutex_coulomb_unlock();
@@ -508,7 +508,7 @@ static int gauge_coulomb_thread(void *arg)
 		get_monotonic_boottime(&end);
 		duraction = timespec_sub(end, start);
 
-		ft_trace(
+		ft_debug(
 			"%s time:%d ms %d %d\n",
 			__func__,
 			(int)(duraction.tv_nsec / 1000000),
@@ -524,7 +524,7 @@ static int gauge_coulomb_thread(void *arg)
 
 void gauge_coulomb_service_init(void)
 {
-	ft_trace("gauge coulomb_service_init\n");
+	ft_debug("gauge coulomb_service_init\n");
 	INIT_LIST_HEAD(&coulomb_head_minus);
 	INIT_LIST_HEAD(&coulomb_head_plus);
 	mutex_init(&coulomb_lock);
diff --git a/drivers/power/supply/mediatek/battery_common.c b/drivers/power/supply/mediatek/battery_common.c
index 60e76cb7f..984dfe167 100644
--- a/drivers/power/supply/mediatek/battery_common.c
+++ b/drivers/power/supply/mediatek/battery_common.c
@@ -3971,16 +3971,16 @@ void hv_sw_mode(void)
 
 #if defined(CONFIG_ARCH_MT6735) || defined(CONFIG_ARCH_MT6735M) ||             \
 	defined(CONFIG_ARCH_MT6753)
-		pr_info("HWCID:0x%x\n", pmic_get_register_value(PMIC_HWCID));
-		pr_info("VCORE1_CON9:0x%x\n", upmu_get_reg_value(0x0612));
-		pr_info("DEW_DIO_EN:0x%x\n", upmu_get_reg_value(0x02d4));
-		pr_info("DEW_READ_TEST:0x%x\n", upmu_get_reg_value(0x02d6));
+		pr_debug("HWCID:0x%x\n", pmic_get_register_value(PMIC_HWCID));
+		pr_debug("VCORE1_CON9:0x%x\n", upmu_get_reg_value(0x0612));
+		pr_debug("DEW_DIO_EN:0x%x\n", upmu_get_reg_value(0x02d4));
+		pr_debug("DEW_READ_TEST:0x%x\n", upmu_get_reg_value(0x02d6));
 		pmic_config_interface(0x2d8, 0x1234, 0xffff, 0);
-		pr_info("DEW_WRITE_TEST:0x%x\n", upmu_get_reg_value(0x02d8));
-		pr_info("INT_STATUS0:0x%x\n", upmu_get_reg_value(0x02C4));
-		pr_info("INT_STATUS0:0x%x\n", upmu_get_reg_value(0x02C4));
+		pr_debug("DEW_WRITE_TEST:0x%x\n", upmu_get_reg_value(0x02d8));
+		pr_debug("INT_STATUS0:0x%x\n", upmu_get_reg_value(0x02C4));
+		pr_debug("INT_STATUS0:0x%x\n", upmu_get_reg_value(0x02C4));
 		pmic_config_interface(0x2d8, 0xabcd, 0xffff, 0);
-		pr_info("DEW_WRITE_TEST:0x%x\n", upmu_get_reg_value(0x02d8));
+		pr_debug("DEW_WRITE_TEST:0x%x\n", upmu_get_reg_value(0x02d8));
 
 		pwrap_dump_ap_register();
 #endif
@@ -5301,7 +5301,7 @@ static int mt_batteryNotify_probe(struct platform_device *dev)
 
 	battery_dir = proc_mkdir("mtk_battery_cmd", NULL);
 	if (!battery_dir) {
-		pr_info("[%s]:mkdir /proc/mtk_battery_cmd failed\n", __func__);
+		pr_err("[%s]:mkdir /proc/mtk_battery_cmd failed\n", __func__);
 	} else {
 #if 1
 		proc_create("battery_cmd", 0644, battery_dir,
@@ -5433,14 +5433,14 @@ static int battery_dts_probe(struct platform_device *dev)
 
 	chrdet_irq = platform_get_irq(dev, 0);
 	if (chrdet_irq <= 0)
-		pr_notice("******** don't support irq from dts ********\n");
+		pr_debug("******** don't support irq from dts ********\n");
 	else {
 		ret = request_threaded_irq(chrdet_irq, NULL,
 				ops_chrdet_int_handler,
 				IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
 				"ops_pmic_chrdet", dev);
 		if (ret) {
-			pr_notice("%s: request_threaded_irq err = %d\n",
+			pr_err("%s: request_threaded_irq err = %d\n",
 				__func__, ret);
 			return ret;
 		}
@@ -5564,7 +5564,7 @@ static int __init battery_init(void)
 {
 	int ret;
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 #ifdef CONFIG_OF
 /*  */
@@ -5617,7 +5617,7 @@ static int __init battery_init(void)
 #endif
 	ret = register_pm_notifier(&battery_pm_notifier_block);
 	if (ret)
-		pr_info("[%s] failed to register PM notifier %d\n", __func__,
+		pr_err("[%s] failed to register PM notifier %d\n", __func__,
 			ret);
 
 	battery_log(BAT_LOG_CRTI,
diff --git a/drivers/power/supply/mediatek/battery_common_fg_20.c b/drivers/power/supply/mediatek/battery_common_fg_20.c
index 7eab18f62..8262030a3 100644
--- a/drivers/power/supply/mediatek/battery_common_fg_20.c
+++ b/drivers/power/supply/mediatek/battery_common_fg_20.c
@@ -4803,7 +4803,7 @@ static int mt_batteryNotify_probe(struct platform_device *dev)
 	/* Create mtk_battery_cmd directory */
 	battery_dir = proc_mkdir("mtk_battery_cmd", NULL);
 	if (!battery_dir) {
-		pr_notice("[%s]: mkdir /proc/mtk_battery_cmd failed\n",
+		pr_err("[%s]: mkdir /proc/mtk_battery_cmd failed\n",
 					__func__);
 		goto _out;
 	}
diff --git a/drivers/power/supply/mediatek/battery_meter.c b/drivers/power/supply/mediatek/battery_meter.c
index 896bb1e66..609d5f025 100644
--- a/drivers/power/supply/mediatek/battery_meter.c
+++ b/drivers/power/supply/mediatek/battery_meter.c
@@ -1190,7 +1190,7 @@ int force_get_tbat(enum kal_bool update)
 		pre_bat_temperature_val = bat_temperature_val;
 
 		if (bat_temperature_val > 55)
-			pr_notice("[%s] %d,%d,%d,%d,%d,%d\n",
+			pr_debug("[%s] %d,%d,%d,%d,%d,%d\n",
 				  __func__,
 				  bat_temperature_volt_temp,
 				  bat_temperature_volt, fg_current_state,
@@ -3179,7 +3179,7 @@ void fgauge_algo_run_init(void)
 unsigned char reset_fg_bat_int = KAL_TRUE;
 void fg_bat_int_handler(void)
 {
-	pr_notice("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	reset_fg_bat_int = KAL_TRUE;
 	wake_up_bat2();
 }
diff --git a/drivers/power/supply/mediatek/battery_meter_fg_20.c b/drivers/power/supply/mediatek/battery_meter_fg_20.c
index cf9548e12..8d6d6a605 100644
--- a/drivers/power/supply/mediatek/battery_meter_fg_20.c
+++ b/drivers/power/supply/mediatek/battery_meter_fg_20.c
@@ -476,13 +476,13 @@ void fgauge_get_profile_id(void)
 
 	ret = IMM_GetOneChannelValue_Cali(BATTERY_ID_CHANNEL_NUM, &id_volt);
 	if (ret != 0)
-		bm_info("[%s]id_volt read fail\n", __func__);
+		bm_err("[%s]id_volt read fail\n", __func__);
 	else
-		bm_info("[%s]id_volt = %d\n", __func__, id_volt);
+		bm_debug("[%s]id_volt = %d\n", __func__, id_volt);
 
 	if ((sizeof(g_battery_id_voltage) / sizeof(signed int)) !=
 	    TOTAL_BATTERY_NUMBER) {
-		bm_info("[%s]error! voltage range incorrect!\n",
+		bm_err("[%s]error! voltage range incorrect!\n",
 		__func__);
 		return;
 	}
@@ -496,7 +496,7 @@ void fgauge_get_profile_id(void)
 		}
 	}
 
-	bm_info("[%s]Battery id (%d)\n", __func__, g_fg_battery_id);
+	bm_debug("[%s]Battery id (%d)\n", __func__, g_fg_battery_id);
 }
 #elif defined(MTK_GET_BATTERY_ID_BY_GPIO)
 void fgauge_get_profile_id(void)
@@ -1305,7 +1305,7 @@ signed int fgauge_get_Q_max(signed short temperature)
 			     10);
 	}
 
-	bm_trace("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
+	bm_debug("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
 
 	return ret_Q_max;
 }
@@ -1365,7 +1365,7 @@ signed int fgauge_get_Q_max_high_current(signed short temperature)
 			     10);
 	}
 
-	bm_trace("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
+	bm_debug("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
 
 	return ret_Q_max;
 }
@@ -1463,7 +1463,7 @@ signed int fgauge_get_Q_max(signed short temperature)
 			     10);
 	}
 
-	bm_trace("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
+	bm_debug("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
 
 	return ret_Q_max;
 }
@@ -1529,7 +1529,7 @@ signed int fgauge_get_Q_max_high_current(signed short temperature)
 			     10);
 	}
 
-	bm_trace("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
+	bm_debug("[%s] Q_max = %d\r\n", __func__, ret_Q_max);
 
 	return ret_Q_max;
 }
@@ -1719,7 +1719,7 @@ void fgauge_algo_run_get_init_data(void)
 #endif
 	charging_enable = KAL_TRUE;
 	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-	bm_info("1.[%s](gFG_voltage_init %d, gFG_current_init %d, gFG_Is_Charging_init %d)\n",
+	bm_debug("1.[%s](gFG_voltage_init %d, gFG_current_init %d, gFG_Is_Charging_init %d)\n",
 		__func__, gFG_voltage_init,
 		gFG_current_init, gFG_Is_Charging_init);
 	mt_battery_set_init_vol(gFG_voltage_init);
@@ -1748,7 +1748,7 @@ void fgauge_algo_run_get_init_data(void)
 	gFG_Is_Charging_init = KAL_FALSE;
 	charging_enable = KAL_TRUE;
 	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-	bm_info("1.[%s](gFG_voltage_init %d, gFG_current_init %d, gFG_Is_Charging_init %d)\n",
+	bm_debug("1.[%s](gFG_voltage_init %d, gFG_current_init %d, gFG_Is_Charging_init %d)\n",
 		__func__, gFG_voltage_init,
 		gFG_current_init, gFG_Is_Charging_init);
 }
@@ -2035,10 +2035,10 @@ signed int battery_meter_get_charging_current(void)
 		}
 	}
 
-	bm_trace("[g_Get_I_Charging:BAT_SENSE]\r\n");
+	bm_debug("[g_Get_I_Charging:BAT_SENSE]\r\n");
 	for (i = 0; i < repeat; i++)
-		bm_trace("%d,", ADC_BAT_SENSE_tmp[i]);
-	bm_trace("\r\n");
+		bm_debug("%d,", ADC_BAT_SENSE_tmp[i]);
+	bm_debug("\r\n");
 
 	/* sorting    I_SENSE */
 	for (i = 0; i < repeat; i++) {
@@ -2051,10 +2051,10 @@ signed int battery_meter_get_charging_current(void)
 		}
 	}
 
-	bm_trace("[g_Get_I_Charging:I_SENSE]\r\n");
+	bm_debug("[g_Get_I_Charging:I_SENSE]\r\n");
 	for (i = 0; i < repeat; i++)
-		bm_trace("%d,", ADC_I_SENSE_tmp[i]);
-	bm_trace("\r\n");
+		bm_debug("%d,", ADC_I_SENSE_tmp[i]);
+	bm_debug("\r\n");
 
 	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[0];
 	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[1];
@@ -2062,7 +2062,7 @@ signed int battery_meter_get_charging_current(void)
 	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[19];
 	ADC_BAT_SENSE = ADC_BAT_SENSE_sum / (repeat - 4);
 
-	bm_trace("[g_Get_I_Charging] ADC_BAT_SENSE=%d\r\n", ADC_BAT_SENSE);
+	bm_debug("[g_Get_I_Charging] ADC_BAT_SENSE=%d\r\n", ADC_BAT_SENSE);
 
 	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[0];
 	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[1];
@@ -2070,9 +2070,9 @@ signed int battery_meter_get_charging_current(void)
 	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[19];
 	ADC_I_SENSE = ADC_I_SENSE_sum / (repeat - 4);
 
-	bm_trace("[g_Get_I_Charging] ADC_I_SENSE(Before)=%d\r\n", ADC_I_SENSE);
+	bm_debug("[g_Get_I_Charging] ADC_I_SENSE(Before)=%d\r\n", ADC_I_SENSE);
 
-	bm_trace("[g_Get_I_Charging] ADC_I_SENSE(After)=%d\r\n", ADC_I_SENSE);
+	bm_debug("[g_Get_I_Charging] ADC_I_SENSE(After)=%d\r\n", ADC_I_SENSE);
 
 	if (ADC_I_SENSE > ADC_BAT_SENSE)
 		ICharging = (ADC_I_SENSE - ADC_BAT_SENSE + g_I_SENSE_offset) *
@@ -3395,7 +3395,7 @@ static ssize_t show_FG_daemon_log_level(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	bm_trace("[FG] show FG_daemon_log_level : %d\n", gFG_daemon_log_level);
+	bm_debug("[FG] show FG_daemon_log_level : %d\n", gFG_daemon_log_level);
 	return sprintf(buf, "%d\n", gFG_daemon_log_level);
 }
 
@@ -3429,7 +3429,7 @@ static DEVICE_ATTR(FG_daemon_log_level, 0664, show_FG_daemon_log_level,
 static ssize_t show_FG_daemon_disable(struct device *dev,
 				      struct device_attribute *attr, char *buf)
 {
-	bm_trace("[FG] show FG_daemon_log_level : %d\n", gDisableFG);
+	bm_debug("[FG] show FG_daemon_log_level : %d\n", gDisableFG);
 	return sprintf(buf, "%d\n", gDisableFG);
 }
 
@@ -3528,7 +3528,7 @@ static int battery_meter_probe(struct platform_device *dev)
 	char *temp_strptr;
 #endif
 
-	bm_info("[%s] probe\n", __func__);
+	bm_debug("[%s] probe\n", __func__);
 	/* select battery meter control method */
 	battery_meter_ctrl = bm_ctrl_cmd;
 #if defined(CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
@@ -3654,7 +3654,7 @@ static int battery_meter_suspend(struct platform_device *dev,
 {
 	/* -- hibernation path */
 	if (state.event == PM_EVENT_FREEZE) {
-		pr_notice("[%s] %p:%p\n", __func__, battery_meter_ctrl,
+		pr_debug("[%s] %p:%p\n", __func__, battery_meter_ctrl,
 			&bm_ctrl_cmd);
 		battery_meter_ctrl = bm_ctrl_cmd;
 	}
@@ -3666,7 +3666,7 @@ static int battery_meter_suspend(struct platform_device *dev,
 	if (reset_fg_bat_int == KAL_TRUE) {
 		battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR_ACT,
 				   &fg_bat_int_coulomb_pre);
-		bm_notice(
+		bm_debug(
 			"[%s]enable battery_meter_set_columb_interrupt %d\n",
 			__func__, batt_meter_cust_data.q_max_pos_25);
 		battery_meter_set_columb_interrupt(
@@ -3674,7 +3674,7 @@ static int battery_meter_suspend(struct platform_device *dev,
 		/*battery_meter_set_columb_interrupt(1); */
 		reset_fg_bat_int = KAL_FALSE;
 	} else {
-		bm_notice(
+		bm_debug(
 			"[%s]do not enable battery_meter_set_columb_interrupt %d\n",
 			__func__, batt_meter_cust_data.q_max_pos_25);
 		battery_meter_set_columb_interrupt(0x1ffff);
@@ -3716,7 +3716,7 @@ static int battery_meter_suspend(struct platform_device *dev,
 		battery_meter_reset_sleep_time();
 		battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV,
 				   &g_hw_ocv_before_sleep);
-		bm_info("[%s]sleep_total_time = %d, last_time = %d\n",
+		bm_debug("[%s]sleep_total_time = %d, last_time = %d\n",
 			__func__,
 			(int)g_sleep_total_time.tv_sec, last_time);
 	}
@@ -3743,7 +3743,7 @@ static int battery_meter_resume(struct platform_device *dev)
 		timespec_add(g_sleep_total_time,
 			     mt_battery_get_duration_time_act(SUSPEND_TIME));
 
-	bm_info("[%s] sleep time = %d, duration_time = %d, wake_up_smooth_time %d, g_spm_timer = %d\n",
+	bm_debug("[%s] sleep time = %d, duration_time = %d, wake_up_smooth_time %d, g_spm_timer = %d\n",
 		__func__, (int)g_sleep_total_time.tv_sec,
 		duration_time, wake_up_smooth_time, g_spm_timer);
 
@@ -3766,7 +3766,7 @@ static int battery_meter_resume(struct platform_device *dev)
 	}
 #endif
 
-	bm_info("* %s!! * suspend_time %d smooth_time %d g_spm_timer %d\n",
+	bm_debug("* %s!! * suspend_time %d smooth_time %d g_spm_timer %d\n",
 		__func__,
 		(int)g_sleep_total_time.tv_sec, wake_up_smooth_time,
 		g_spm_timer);
@@ -4413,7 +4413,7 @@ void bmd_ctrl_cmd_from_user(void *nl_data, struct fgd_nl_msg_t *ret_msg)
 
 		memcpy(&rtcvalue, &msg->fgd_data[0], sizeof(rtcvalue));
 		set_rtc_spare_fg_value(rtcvalue);
-		bm_notice("[fg_res] set rtc = %d\n", rtcvalue);
+		bm_debug("[fg_res] set rtc = %d\n", rtcvalue);
 	} break;
 
 	case FG_DAEMON_CMD_SET_POWEROFF: {
@@ -4425,7 +4425,7 @@ void bmd_ctrl_cmd_from_user(void *nl_data, struct fgd_nl_msg_t *ret_msg)
 	case FG_DAEMON_CMD_SET_INIT_FLAG: {
 		memcpy(&init_flag, &msg->fgd_data[0], sizeof(init_flag));
 
-		bm_notice("[fg_res] init_flag = %d\n", init_flag);
+		bm_debug("[fg_res] init_flag = %d\n", init_flag);
 	} break;
 
 	case FG_DAEMON_CMD_IS_KPOC: {
@@ -4565,7 +4565,7 @@ void bmd_ctrl_cmd_from_user(void *nl_data, struct fgd_nl_msg_t *ret_msg)
 
 		memcpy(&NVRAM_CAR_TUNE_VALUE, &msg->fgd_data[0],
 		       sizeof(NVRAM_CAR_TUNE_VALUE));
-		bm_notice("[fg_res] NVRAM_CAR_TUNE_VALUE = %d\n",
+		bm_debug("[fg_res] NVRAM_CAR_TUNE_VALUE = %d\n",
 			  NVRAM_CAR_TUNE_VALUE);
 		batt_meter_cust_data.car_tune_value = NVRAM_CAR_TUNE_VALUE;
 	} break;
@@ -4721,7 +4721,7 @@ int wakeup_fg_algo(int flow_state)
 	update_fg_dbg_tool_value();
 
 	if (gDisableFG) {
-		bm_notice("FG daemon is disabled\n");
+		bm_debug("FG daemon is disabled\n");
 		return -1;
 	}
 
diff --git a/drivers/power/supply/mediatek/charger_begonia/adapter_class.c b/drivers/power/supply/mediatek/charger_begonia/adapter_class.c
index 16352bd4c..61c050acc 100644
--- a/drivers/power/supply/mediatek/charger_begonia/adapter_class.c
+++ b/drivers/power/supply/mediatek/charger_begonia/adapter_class.c
@@ -173,7 +173,7 @@ struct adapter_device *adapter_device_register(const char *name,
 	struct srcu_notifier_head *head;
 	int rc;
 
-	pr_notice("%s: name=%s\n", __func__, name);
+	pr_debug("%s: name=%s\n", __func__, name);
 	adapter_dev = kzalloc(sizeof(*adapter_dev), GFP_KERNEL);
 	if (!adapter_dev)
 		return ERR_PTR(-ENOMEM);
@@ -256,7 +256,7 @@ static int __init adapter_class_init(void)
 {
 	adapter_class = class_create(THIS_MODULE, "Charging Adapter");
 	if (IS_ERR(adapter_class)) {
-		pr_notice("Unable to create Charging Adapter class; errno = %ld\n",
+		pr_err("Unable to create Charging Adapter class; errno = %ld\n",
 			PTR_ERR(adapter_class));
 		return PTR_ERR(adapter_class);
 	}
diff --git a/drivers/power/supply/mediatek/charger_begonia/bq25601.c b/drivers/power/supply/mediatek/charger_begonia/bq25601.c
index 58a3ecc17..3339e2036 100644
--- a/drivers/power/supply/mediatek/charger_begonia/bq25601.c
+++ b/drivers/power/supply/mediatek/charger_begonia/bq25601.c
@@ -126,7 +126,7 @@ unsigned int charging_value_to_parameter(const unsigned int
 	if (val < array_size)
 		return parameter[val];
 
-	pr_info("Can't find the parameter\n");
+	pr_err("Can't find the parameter\n");
 	return parameter[0];
 
 }
@@ -144,7 +144,7 @@ unsigned int charging_parameter_to_value(const unsigned int
 			return i;
 	}
 
-	pr_info("NO register value match\n");
+	pr_err("NO register value match\n");
 	/* TODO: ASSERT(0);    // not find the value */
 	return 0;
 }
@@ -171,7 +171,7 @@ static unsigned int bmt_find_closest_level(const unsigned int *pList,
 			}
 		}
 
-		pr_info("Can't find closest level\n");
+		pr_err("Can't find closest level\n");
 		return pList[0];
 		/* return CHARGE_CURRENT_0_00_MA; */
 	} else {
@@ -181,7 +181,7 @@ static unsigned int bmt_find_closest_level(const unsigned int *pList,
 				return pList[i];
 		}
 
-		pr_info("Can't find closest level\n");
+		pr_err("Can't find closest level\n");
 		return pList[number - 1];
 		/* return CHARGE_CURRENT_0_00_MA; */
 	}
@@ -300,7 +300,7 @@ unsigned int bq25601_read_byte(unsigned char cmd,
 		ret = i2c_transfer(new_client->adapter, msgs, xfers);
 
 		if (ret == -ENXIO) {
-			pr_info("skipping non-existent adapter %s\n",
+			pr_debug("skipping non-existent adapter %s\n",
 				new_client->adapter->name);
 			break;
 		}
@@ -340,7 +340,7 @@ unsigned int bq25601_write_byte(unsigned char cmd,
 		ret = i2c_transfer(new_client->adapter, msgs, xfers);
 
 		if (ret == -ENXIO) {
-			pr_info("skipping non-existent adapter %s\n",
+			pr_debug("skipping non-existent adapter %s\n",
 				new_client->adapter->name);
 			break;
 		}
@@ -399,7 +399,7 @@ unsigned int bq25601_config_interface(unsigned char RegNum,
 
 	/* Check */
 	/* bq25601_read_byte(RegNum, &bq25601_reg); */
-	/* pr_info("[%s] Check Reg[%x]=0x%x\n", __func__,*/
+	/* pr_debug("[%s] Check Reg[%x]=0x%x\n", __func__,*/
 	/* RegNum, bq25601_reg); */
 
 	return ret;
@@ -885,14 +885,14 @@ static int bq25601_dump_register(struct charger_device *chg_dev)
 	unsigned char i = 0;
 	unsigned int ret = 0;
 
-	pr_info("[bq25601] ");
+	pr_debug("[bq25601] ");
 	for (i = 0; i < bq25601_REG_NUM; i++) {
 		ret = bq25601_read_byte(i, &bq25601_reg[i]);
 		if (ret == 0) {
-			pr_info("[bq25601] i2c transfor error\n");
+			pr_err("[bq25601] i2c transfor error\n");
 			return 1;
 		}
-		pr_info("[0x%x]=0x%x ", i, bq25601_reg[i]);
+		pr_debug("[0x%x]=0x%x ", i, bq25601_reg[i]);
 	}
 	pr_debug("\n");
 	return 0;
@@ -916,7 +916,7 @@ static void bq25601_hw_component_detect(void)
 	else
 		g_bq25601_hw_exist = 1;
 
-	pr_info("[%s] exist=%d, Reg[0x0B]=0x%x\n", __func__,
+	pr_debug("[%s] exist=%d, Reg[0x0B]=0x%x\n", __func__,
 		g_bq25601_hw_exist, val);
 }
 
@@ -926,7 +926,7 @@ static int bq25601_enable_charging(struct charger_device *chg_dev,
 {
 	int status = 0;
 
-	pr_info("enable state : %d\n", en);
+	pr_debug("enable state : %d\n", en);
 	if (en) {
 		/* bq25601_config_interface(bq25601_CON3, 0x1, 0x1, 4); */
 		/* enable charging */
@@ -936,7 +936,7 @@ static int bq25601_enable_charging(struct charger_device *chg_dev,
 		/* bq25601_config_interface(bq25601_CON3, 0x0, 0x1, 4); */
 		/* enable charging */
 		bq25601_set_chg_config(en);
-		pr_info("[charging_enable] under test mode: disable charging\n");
+		pr_debug("[charging_enable] under test mode: disable charging\n");
 
 		/*bq25601_set_en_hiz(0x1);*/
 	}
@@ -975,15 +975,15 @@ static int bq25601_set_current(struct charger_device *chg_dev,
 	unsigned int array_size;
 	unsigned int register_value;
 
-	pr_info("&&&& charge_current_value = %d\n", current_value);
+	pr_debug("&&&& charge_current_value = %d\n", current_value);
 	current_value /= 10;
 	array_size = GETARRAYNUM(CS_VTH);
 	set_chr_current = bmt_find_closest_level(CS_VTH, array_size,
 			  current_value);
 	register_value = charging_parameter_to_value(CS_VTH, array_size,
 			 set_chr_current);
-	//pr_info("&&&& charge_register_value = %d\n",register_value);
-	pr_info("&&&& %s register_value = %d\n", __func__,
+	//pr_debug("&&&& charge_register_value = %d\n",register_value);
+	pr_debug("&&&& %s register_value = %d\n", __func__,
 		register_value);
 	bq25601_set_ichg(register_value);
 
@@ -1015,13 +1015,13 @@ static int bq25601_set_input_current(struct charger_device *chg_dev,
 	unsigned int register_value;
 
 	current_value /= 10;
-	pr_info("&&&& current_value = %d\n", current_value);
+	pr_debug("&&&& current_value = %d\n", current_value);
 	array_size = GETARRAYNUM(INPUT_CS_VTH);
 	set_chr_current = bmt_find_closest_level(INPUT_CS_VTH, array_size,
 			  current_value);
 	register_value = charging_parameter_to_value(INPUT_CS_VTH, array_size,
 			 set_chr_current);
-	pr_info("&&&& %s register_value = %d\n", __func__,
+	pr_debug("&&&& %s register_value = %d\n", __func__,
 		register_value);
 	bq25601_set_iinlim(register_value);
 
@@ -1041,7 +1041,7 @@ static int bq25601_set_cv_voltage(struct charger_device *chg_dev,
 	register_value = charging_parameter_to_value(VBAT_CV_VTH, array_size,
 			 set_cv_voltage);
 	bq25601_set_vreg(register_value);
-	pr_info("&&&& cv reg value = %d\n", register_value);
+	pr_debug("&&&& cv reg value = %d\n", register_value);
 
 	return status;
 }
@@ -1051,7 +1051,7 @@ static int bq25601_reset_watch_dog_timer(struct charger_device
 {
 	unsigned int status = true;
 
-	pr_info("charging_reset_watch_dog_timer\n");
+	pr_debug("charging_reset_watch_dog_timer\n");
 
 	bq25601_set_wdt_rst(0x1);	/* Kick watchdog */
 	bq25601_set_watchdog(0x3);	/* WDT 160s */
@@ -1071,7 +1071,7 @@ static int bq25601_set_vindpm_voltage(struct charger_device *chg_dev,
 	vindpm = bmt_find_closest_level(VINDPM_REG, array_size, vindpm);
 	vindpm = charging_parameter_to_value(VINDPM_REG, array_size, vindpm);
 
-	pr_info("%s vindpm =%d\r\n", __func__, vindpm);
+	pr_debug("%s vindpm =%d\r\n", __func__, vindpm);
 
 	//	charging_set_vindpm(vindpm);
 	/*bq25601_set_en_hiz(en);*/
@@ -1099,7 +1099,7 @@ static int bq25601_enable_otg(struct charger_device *chg_dev, bool en)
 {
 	int ret = 0;
 
-	pr_info("%s en = %d\n", __func__, en);
+	pr_debug("%s en = %d\n", __func__, en);
 	if (en) {
 		bq25601_set_chg_config(0);
 		bq25601_set_otg_config(1);
@@ -1173,7 +1173,7 @@ static unsigned int charging_hw_init(void)
 	bq25601_set_watchdog(0x3);	/* WDT 160s */
 	bq25601_set_en_timer(0x0);	/* Enable charge timer */
 	bq25601_set_int_mask(0x0);	/* Disable fault interrupt */
-	pr_info("%s: hw_init down!\n", __func__);
+	pr_debug("%s: hw_init down!\n", __func__);
 	return status;
 }
 
@@ -1183,27 +1183,27 @@ static int bq25601_parse_dt(struct bq25601_info *info,
 	struct device_node *np = dev->of_node;
 	//int bq25601_en_pin = 0;
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	if (!np) {
-		pr_info("%s: no of node\n", __func__);
+		pr_err("%s: no of node\n", __func__);
 		return -ENODEV;
 	}
 
 	if (of_property_read_string(np, "charger_name",
 				    &info->chg_dev_name) < 0) {
 		info->chg_dev_name = "primary_chg";
-		pr_info("%s: no charger name\n", __func__);
+		pr_err("%s: no charger name\n", __func__);
 	}
 
 	if (of_property_read_string(np, "alias_name",
 				    &(info->chg_props.alias_name)) < 0) {
 		info->chg_props.alias_name = "bq25601";
-		pr_info("%s: no alias name\n", __func__);
+		pr_err("%s: no alias name\n", __func__);
 	}
 	/*
 	 * bq25601_en_pin = of_get_named_gpio(np,"gpio_bq25601_en",0);
 	 * if(bq25601_en_pin < 0){
-	 * pr_info("%s: no bq25601_en_pin\n", __func__);
+	 * pr_err("%s: no bq25601_en_pin\n", __func__);
 	 * return -ENODATA;
 	 * }
 	 * gpio_request(bq25601_en_pin,"bq25601_en_pin");
@@ -1225,7 +1225,7 @@ static int bq25601_do_event(struct charger_device *chg_dev, u32 event,
 	if (chg_dev == NULL)
 		return -EINVAL;
 
-	pr_info("%s: event = %d\n", __func__, event);
+	pr_debug("%s: event = %d\n", __func__, event);
 	switch (event) {
 	case EVENT_EOC:
 		charger_dev_notify(chg_dev, CHARGER_DEV_NOTIFY_EOC);
@@ -1281,7 +1281,7 @@ static int bq25601_driver_probe(struct i2c_client *client,
 	int ret = 0;
 	struct bq25601_info *info = NULL;
 
-	pr_info("[%s]\n", __func__);
+	pr_debug("[%s]\n", __func__);
 
 	info = devm_kzalloc(&client->dev, sizeof(struct bq25601_info),
 			    GFP_KERNEL);
@@ -1304,7 +1304,7 @@ static int bq25601_driver_probe(struct i2c_client *client,
 						&bq25601_chg_ops,
 						&info->chg_props);
 	if (IS_ERR_OR_NULL(info->chg_dev)) {
-		pr_info("%s: register charger device  failed\n", __func__);
+		pr_err("%s: register charger device  failed\n", __func__);
 		ret = PTR_ERR(info->chg_dev);
 		return ret;
 	}
@@ -1323,7 +1323,7 @@ unsigned char g_reg_value_bq25601;
 static ssize_t show_bq25601_access(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	pr_info("[%s] 0x%x\n", __func__, g_reg_value_bq25601);
+	pr_debug("[%s] 0x%x\n", __func__, g_reg_value_bq25601);
 	return sprintf(buf, "%u\n", g_reg_value_bq25601);
 }
 
@@ -1336,10 +1336,10 @@ static ssize_t store_bq25601_access(struct device *dev,
 	unsigned int reg_value = 0;
 	unsigned int reg_address = 0;
 
-	pr_info("[%s]\n", __func__);
+	pr_debug("[%s]\n", __func__);
 
 	if (buf != NULL && size != 0) {
-		pr_info("[%s] buf is %s and size is %zu\n", __func__, buf,
+		pr_debug("[%s] buf is %s and size is %zu\n", __func__, buf,
 			size);
 
 		pvalue = (char *)buf;
@@ -1354,7 +1354,7 @@ static ssize_t store_bq25601_access(struct device *dev,
 		if (size > 3) {
 			val = strsep(&pvalue, " ");
 			ret = kstrtou32(val, 16, (unsigned int *)&reg_value);
-			pr_info(
+			pr_debug(
 			"[%s] write bq25601 reg 0x%x with value 0x%x !\n",
 			__func__,
 			(unsigned int) reg_address, reg_value);
@@ -1363,11 +1363,11 @@ static ssize_t store_bq25601_access(struct device *dev,
 		} else {
 			ret = bq25601_read_interface(reg_address,
 					     &g_reg_value_bq25601, 0xFF, 0x0);
-			pr_info(
+			pr_debug(
 			"[%s] read bq25601 reg 0x%x with value 0x%x !\n",
 			__func__,
 			(unsigned int) reg_address, g_reg_value_bq25601);
-			pr_info(
+			pr_debug(
 			"[%s] use \"cat bq25601_access\" to get value\n",
 			__func__);
 		}
@@ -1382,7 +1382,7 @@ static int bq25601_user_space_probe(struct platform_device *dev)
 {
 	int ret_device_file = 0;
 
-	pr_info("******** %s!! ********\n", __func__);
+	pr_debug("******** %s!! ********\n", __func__);
 
 	ret_device_file = device_create_file(&(dev->dev),
 					     &dev_attr_bq25601_access);
@@ -1431,17 +1431,17 @@ static int __init bq25601_init(void)
 
 	/* i2c registeration using DTS instead of boardinfo*/
 #ifdef CONFIG_OF
-	pr_info("[%s] init start with i2c DTS", __func__);
+	pr_debug("[%s] init start with i2c DTS", __func__);
 #else
-	pr_info("[%s] init start. ch=%d\n", __func__, bq25601_BUSNUM);
+	pr_debug("[%s] init start. ch=%d\n", __func__, bq25601_BUSNUM);
 	i2c_register_board_info(bq25601_BUSNUM, &i2c_bq25601, 1);
 #endif
 	if (i2c_add_driver(&bq25601_driver) != 0) {
-		pr_info(
+		pr_err(
 			"[%s] failed to register bq25601 i2c driver.\n",
 			__func__);
 	} else {
-		pr_info(
+		pr_debug(
 			"[%s] Success to register bq25601 i2c driver.\n",
 			__func__);
 	}
@@ -1449,13 +1449,13 @@ static int __init bq25601_init(void)
 	/* bq25601 user space access interface */
 	ret = platform_device_register(&bq25601_user_space_device);
 	if (ret) {
-		pr_info("****[%s] Unable to device register(%d)\n", __func__,
+		pr_err("****[%s] Unable to device register(%d)\n", __func__,
 			ret);
 		return ret;
 	}
 	ret = platform_driver_register(&bq25601_user_space_driver);
 	if (ret) {
-		pr_info("****[%s] Unable to register driver (%d)\n", __func__,
+		pr_err("****[%s] Unable to register driver (%d)\n", __func__,
 			ret);
 		return ret;
 	}
diff --git a/drivers/power/supply/mediatek/charger_begonia/charger_class.c b/drivers/power/supply/mediatek/charger_begonia/charger_class.c
index b15e94bb3..fb4471443 100644
--- a/drivers/power/supply/mediatek/charger_begonia/charger_class.c
+++ b/drivers/power/supply/mediatek/charger_begonia/charger_class.c
@@ -844,7 +844,7 @@ static int __init charger_class_init(void)
 {
 	charger_class = class_create(THIS_MODULE, "switching_charger");
 	if (IS_ERR(charger_class)) {
-		pr_notice("Unable to create charger class; errno = %ld\n",
+		pr_err("Unable to create charger class; errno = %ld\n",
 			PTR_ERR(charger_class));
 		return PTR_ERR(charger_class);
 	}
diff --git a/drivers/power/supply/mediatek/charger_begonia/hl7005.c b/drivers/power/supply/mediatek/charger_begonia/hl7005.c
index 6577778ba..e85392e0d 100644
--- a/drivers/power/supply/mediatek/charger_begonia/hl7005.c
+++ b/drivers/power/supply/mediatek/charger_begonia/hl7005.c
@@ -116,7 +116,7 @@ unsigned int charging_value_to_parameter(const unsigned int *parameter,
 {
 	if (val < array_size)
 		return parameter[val];
-	pr_info("Can't find the parameter\n");
+	pr_err("Can't find the parameter\n");
 	return parameter[0];
 }
 
@@ -133,7 +133,7 @@ unsigned int charging_parameter_to_value(const unsigned int *parameter,
 			return i;
 	}
 
-	pr_info("NO register value match\n");
+	pr_err("NO register value match\n");
 
 	return 0;
 }
@@ -158,7 +158,7 @@ static unsigned int bmt_find_closest_level(const unsigned int *pList,
 				return pList[i];
 			}
 		}
-		pr_info("Can't find closest level\n");
+		pr_err("Can't find closest level\n");
 		return pList[0];
 		/* return 000; */
 	} else {
@@ -166,7 +166,7 @@ static unsigned int bmt_find_closest_level(const unsigned int *pList,
 			if (pList[i] <= level)
 				return pList[i];
 		}
-		pr_info("Can't find closest level\n");
+		pr_err("Can't find closest level\n");
 		return pList[number - 1];
 		/* return 000; */
 	}
@@ -597,7 +597,7 @@ static int hl7005_parse_dt(struct hl7005_info *info, struct device *dev)
 {
 	struct device_node *np = dev->of_node;
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	if (!np) {
 		pr_err("%s: no of node\n", __func__);
@@ -625,7 +625,7 @@ static int hl7005_do_event(struct charger_device *chg_dev, unsigned int event,
 	if (chg_dev == NULL)
 		return -EINVAL;
 
-	pr_info("%s: event = %d\n", __func__, event);
+	pr_debug("%s: event = %d\n", __func__, event);
 
 	switch (event) {
 	case EVENT_EOC:
@@ -669,7 +669,7 @@ static int hl7005_set_cv_voltage(struct charger_device *chg_dev, u32 cv)
 
 	register_value =
 	charging_parameter_to_value(VBAT_CVTH, array_size, set_cv_voltage);
-	pr_info("charging_set_cv_voltage register_value=0x%x %d %d\n",
+	pr_debug("charging_set_cv_voltage register_value=0x%x %d %d\n",
 	 register_value, cv, set_cv_voltage);
 	hl7005_set_oreg(register_value);
 
@@ -940,9 +940,9 @@ static int __init hl7005_init(void)
 {
 
 	if (i2c_add_driver(&hl7005_driver) != 0)
-		pr_info("Failed to register hl7005 i2c driver.\n");
+		pr_err("Failed to register hl7005 i2c driver.\n");
 	else
-		pr_info("Success to register hl7005 i2c driver.\n");
+		pr_debug("Success to register hl7005 i2c driver.\n");
 
 	return 0;
 }
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_charger.c b/drivers/power/supply/mediatek/charger_begonia/mtk_charger.c
index 8e889da3e..edd05efb2 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_charger.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_charger.c
@@ -279,7 +279,7 @@ int charger_manager_enable_high_voltage_charging(
 	else if (en && consumer->hv_charging_disabled == true)
 		consumer->hv_charging_disabled = false;
 	else {
-		pr_info("[%s] already set: %d %d\n", __func__,
+		pr_debug("[%s] already set: %d %d\n", __func__,
 			consumer->hv_charging_disabled, en);
 		return 0;
 	}
@@ -296,7 +296,7 @@ int charger_manager_enable_high_voltage_charging(
 	}
 	mutex_unlock(&consumer_mutex);
 
-	pr_info("%s: user: %s, en = %d\n", __func__, dev_name(consumer->dev),
+	pr_debug("%s: user: %s, en = %d\n", __func__, dev_name(consumer->dev),
 		info->enable_hv_charging);
 	_wake_up_charger(info);
 
@@ -337,7 +337,7 @@ int charger_manager_enable_power_path(struct charger_consumer *consumer,
 		return 0;
 	}
 
-	pr_info("%s: enable power path = %d\n", __func__, en);
+	pr_debug("%s: enable power path = %d\n", __func__, en);
 	return charger_dev_enable_powerpath(chg_dev, en);
 }
 
@@ -606,7 +606,7 @@ int charger_manager_enable_chg_type_det(struct charger_consumer *consumer,
 	struct charger_manager *info = consumer->cm;
 	struct charger_device *chg_dev;
 	int ret = 0;
-	pr_info("%s start\n", __func__);
+	pr_debug("%s start\n", __func__);
 	if (info != NULL) {
 		switch (info->data.bc12_charger) {
 		case MAIN_CHARGER:
@@ -690,13 +690,13 @@ int charger_manager_get_ibus(int *ibus)
 
 int charger_manager_set_input_suspend(int suspend)
 {
-	pr_info("%s suspend: %d.\n", __func__, suspend);
+	pr_debug("%s suspend: %d.\n", __func__, suspend);
 
 	if (pinfo == NULL)
 		return false;
 
 	if (pinfo->is_input_suspend == suspend) {
-		pr_info("%s same setting, return.\n", __func__);
+		pr_debug("%s same setting, return.\n", __func__);
 		return false;
 	}
 
@@ -771,7 +771,7 @@ void charger_manager_set_prop_system_temp_level(int temp_level)
 	if (pinfo->system_temp_level == 0)
 		thermal_icl_ua = -1;
 
-	pr_info("%s, system_temp_level:%d thermal_icl_ua:%d usb_type:%d\n", __func__,
+	pr_debug("%s, system_temp_level:%d thermal_icl_ua:%d usb_type:%d\n", __func__,
 			pinfo->system_temp_level, thermal_icl_ua, pinfo->usb_psy->desc->type);
 
 	_charger_manager_set_input_current_limit(pinfo, TOTAL_CHARGER, thermal_icl_ua);
@@ -969,7 +969,7 @@ void mtk_charger_get_atm_mode(struct charger_manager *info)
 	} else
 		info->atm_enabled = false;
 
-	pr_info("%s: atm_enabled = %d\n", __func__, info->atm_enabled);
+	pr_debug("%s: atm_enabled = %d\n", __func__, info->atm_enabled);
 }
 
 /* internal algorithm common function */
@@ -1049,7 +1049,7 @@ static int smblib_get_quick_charge_type(struct charger_manager *info)
 
 	power_supply_get_property(info->usb_psy,
 			POWER_SUPPLY_PROP_REAL_TYPE, &pval);
-	pr_info("Get real type:%d.\n", pval.intval);
+	pr_debug("Get real type:%d.\n", pval.intval);
 	while (adapter_cap[i].adap_type != 0) {
 		if (pval.intval == adapter_cap[i].adap_type) {
 			return adapter_cap[i].adap_cap;
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_charger_intf.h b/drivers/power/supply/mediatek/charger_begonia/mtk_charger_intf.h
index 758566799..72a07617d 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_charger_intf.h
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_charger_intf.h
@@ -572,7 +572,7 @@ enum usb_state_enum {
 
 bool __attribute__((weak)) is_usb_rdy(void)
 {
-	pr_info("%s is not defined\n", __func__);
+	pr_err("%s is not defined\n", __func__);
 	return false;
 }
 
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_chg_type_det.c b/drivers/power/supply/mediatek/charger_begonia/mtk_chg_type_det.c
index 19655465e..663680f2b 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_chg_type_det.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_chg_type_det.c
@@ -53,7 +53,7 @@
 
 void __attribute__((weak)) fg_charger_in_handler(void)
 {
-	pr_notice("%s not defined\n", __func__);
+	pr_debug("%s not defined\n", __func__);
 }
 
 #ifdef CONFIG_FPGA_EARLY_PORTING
@@ -89,11 +89,11 @@ static void dump_charger_name(enum charger_type type)
 	case APPLE_2_1A_CHARGER:
 	case APPLE_1_0A_CHARGER:
 	case APPLE_0_5A_CHARGER:
-		pr_info("%s: charger type: %d, %s\n", __func__, type,
+		pr_debug("%s: charger type: %d, %s\n", __func__, type,
 			mtk_chg_type_name[type]);
 		break;
 	default:
-		pr_info("%s: charger type: %d, Not Defined!!!\n", __func__,
+		pr_err("%s: charger type: %d, Not Defined!!!\n", __func__,
 			type);
 		break;
 	}
@@ -108,7 +108,7 @@ static int mt_charger_online(struct mt_charger *mtk_chg)
 		boot_mode = get_boot_mode();
 		if (boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT ||
 		    boot_mode == LOW_POWER_OFF_CHARGING_BOOT) {
-			pr_notice("%s: Unplug Charger/USB\n", __func__);
+			pr_debug("%s: Unplug Charger/USB\n", __func__);
 //			kernel_power_off();
 		}
 	}
@@ -146,10 +146,10 @@ static int mt_charger_set_property(struct power_supply *psy,
 	struct mt_charger *mtk_chg = power_supply_get_drvdata(psy);
 	struct chg_type_info *cti;
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	if (!mtk_chg) {
-		pr_notice("%s: no mtk chg data\n", __func__);
+		pr_err("%s: no mtk chg data\n", __func__);
 		return -EINVAL;
 	}
 
@@ -495,7 +495,7 @@ static enum power_supply_property mt_main_properties[] = {
 
 static void tcpc_power_off_work_handler(struct work_struct *work)
 {
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 //	kernel_power_off();
 }
 
@@ -546,7 +546,7 @@ static int pd_tcp_notifier_call(struct notifier_block *pnb,
 		    noti->typec_state.new_state == TYPEC_ATTACHED_CUSTOM_SRC ||
 		    noti->typec_state.new_state == TYPEC_ATTACHED_NORP_SRC)) {
 			cti->cc_orientation = noti->typec_state.polarity;
-			pr_info("%s USB Plug in, pol = %d, state = %d\n", __func__,
+			pr_debug("%s USB Plug in, pol = %d, state = %d\n", __func__,
 					noti->typec_state.polarity, noti->typec_state.new_state);
 			cti->typec_mode = get_source_mode(noti);
 			plug_in_out_handler(cti, true, false);
@@ -556,7 +556,7 @@ static int pd_tcp_notifier_call(struct notifier_block *pnb,
 			&& noti->typec_state.new_state == TYPEC_UNATTACHED) {
 			if (cti->tcpc_kpoc) {
 				vbus = battery_get_vbus();
-				pr_info("%s KPOC Plug out, vbus = %d\n",
+				pr_debug("%s KPOC Plug out, vbus = %d\n",
 					__func__, vbus);
 				queue_work_on(cpumask_first(cpu_online_mask),
 					      cti->pwr_off_wq,
@@ -565,16 +565,16 @@ static int pd_tcp_notifier_call(struct notifier_block *pnb,
 				break;
 			}
 			cti->typec_mode = POWER_SUPPLY_TYPEC_NONE;
-			pr_info("%s USB Plug out\n", __func__);
+			pr_debug("%s USB Plug out\n", __func__);
 			plug_in_out_handler(cti, false, false);
 		} else if (noti->typec_state.old_state == TYPEC_ATTACHED_SRC &&
 			noti->typec_state.new_state == TYPEC_ATTACHED_SNK) {
-			pr_info("%s Source_to_Sink\n", __func__);
+			pr_debug("%s Source_to_Sink\n", __func__);
 			cti->typec_mode = POWER_SUPPLY_TYPEC_SINK;
 			plug_in_out_handler(cti, true, true);
 		}  else if (noti->typec_state.old_state == TYPEC_ATTACHED_SNK &&
 			noti->typec_state.new_state == TYPEC_ATTACHED_SRC) {
-			pr_info("%s Sink_to_Source\n", __func__);
+			pr_debug("%s Sink_to_Source\n", __func__);
 			cti->typec_mode = get_source_mode(noti);
 			plug_in_out_handler(cti, false, true);
 		}
@@ -592,7 +592,7 @@ static int otg_tcp_notifier_call(struct notifier_block *nb,
 
 	switch (event) {
 	case TCP_NOTIFY_TYPEC_STATE:
-		pr_info("%s, TCP_NOTIFY_TYPEC_STATE, old_state=%d, new_state=%d\n",
+		pr_debug("%s, TCP_NOTIFY_TYPEC_STATE, old_state=%d, new_state=%d\n",
 				__func__, noti->typec_state.old_state,
 				noti->typec_state.new_state);
 		if (noti->typec_state.old_state == TYPEC_UNATTACHED &&
@@ -624,7 +624,7 @@ static int chgdet_task_threadfn(void *data)
 
 		cti->tcpc_dev = tcpc_dev_get_by_name("type_c_port0");
 		if (!cti->tcpc_dev) {
-			pr_info("%s get tcpc device type_c_port0 fail\n",
+			pr_err("%s get tcpc device type_c_port0 fail\n",
 				__func__);
 			continue;
 		} else {
@@ -632,14 +632,14 @@ static int chgdet_task_threadfn(void *data)
 			ret = register_tcp_dev_notifier(cti->tcpc_dev,
 				&cti->pd_nb, TCP_NOTIFY_TYPE_ALL);
 			if (ret < 0) {
-				pr_info("%s: register tcpc notifer fail\n",
+				pr_err("%s: register tcpc notifer fail\n",
 					__func__);
 			}
 			cti->otg_nb.notifier_call = otg_tcp_notifier_call;
 			ret = register_tcp_dev_notifier(cti->tcpc_dev,
 				&cti->otg_nb, TCP_NOTIFY_TYPE_ALL);
 			if (ret < 0) {
-				pr_info("%s: register tcpc notifer fail\n",
+				pr_err("%s: register tcpc notifer fail\n",
 					__func__);
 			}
 		}
@@ -647,20 +647,20 @@ static int chgdet_task_threadfn(void *data)
 		cti->chg_consumer = charger_manager_get_by_name(cti->dev,
 			"charger_port1");
 		if (!cti->chg_consumer) {
-			pr_info("%s: get charger consumer device failed\n",
+			pr_err("%s: get charger consumer device failed\n",
 				__func__);
 		}
 
-		pr_info("%s: get tcpc and charger consumer done\n", __func__);
+		pr_debug("%s: get tcpc and charger consumer done\n", __func__);
 		break;
 	}
 
-	pr_info("%s: ++\n", __func__);
+	pr_debug("%s: ++\n", __func__);
 	while (!kthread_should_stop()) {
 		ret = wait_event_interruptible(cti->waitq,
 					     atomic_read(&cti->chgdet_cnt) > 0);
 		if (ret < 0) {
-			pr_info("%s: wait event been interrupted(%d)\n",
+			pr_debug("%s: wait event been interrupted(%d)\n",
 				__func__, ret);
 			continue;
 		}
@@ -669,7 +669,7 @@ static int chgdet_task_threadfn(void *data)
 		atomic_set(&cti->chgdet_cnt, 0);
 		attach = cti->chgdet_en;
 		mutex_unlock(&cti->chgdet_lock);
-		pr_info("%s start bc12\n", __func__);
+		pr_debug("%s start bc12\n", __func__);
 #ifdef CONFIG_MTK_EXTERNAL_CHARGER_TYPE_DETECT
 		if (cti->chg_consumer)
 			charger_manager_enable_chg_type_det(cti->chg_consumer,
@@ -679,7 +679,7 @@ static int chgdet_task_threadfn(void *data)
 #endif
 		pm_relax(cti->dev);
 	}
-	pr_info("%s: --\n", __func__);
+	pr_debug("%s: --\n", __func__);
 	return 0;
 }
 
@@ -777,7 +777,7 @@ static int mt_charger_probe(struct platform_device *pdev)
 	if (ret == KERNEL_POWER_OFF_CHARGING_BOOT ||
 	    ret == LOW_POWER_OFF_CHARGING_BOOT)
 		cti->tcpc_kpoc = true;
-	pr_info("%s KPOC(%d)\n", __func__, cti->tcpc_kpoc);
+	pr_debug("%s KPOC(%d)\n", __func__, cti->tcpc_kpoc);
 
 	/* Init Charger Detection */
 	mutex_init(&cti->chgdet_lock);
@@ -788,7 +788,7 @@ static int mt_charger_probe(struct platform_device *pdev)
 				chgdet_task_threadfn, cti, "chgdet_thread");
 	ret = PTR_ERR_OR_ZERO(cti->chgdet_task);
 	if (ret < 0) {
-		pr_info("%s: create chg det work fail\n", __func__);
+		pr_err("%s: create chg det work fail\n", __func__);
 		return ret;
 	}
 
@@ -803,7 +803,7 @@ static int mt_charger_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, mt_chg);
 	device_init_wakeup(&pdev->dev, true);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	return 0;
 err_usb_psy:
 	power_supply_unregister(mt_chg->ac_psy);
@@ -824,7 +824,7 @@ static int mt_charger_remove(struct platform_device *pdev)
 	power_supply_unregister(mt_charger->usb_psy);
 	power_supply_unregister(mt_charger->main_psy);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	if (cti->chgdet_task) {
 		kthread_stop(cti->chgdet_task);
 		atomic_inc(&cti->chgdet_cnt);
@@ -879,7 +879,7 @@ bool upmu_is_chr_det(void)
 	struct power_supply *psy = power_supply_get_by_name("charger");
 
 	if (!psy) {
-		pr_info("%s: get power supply failed\n", __func__);
+		pr_err("%s: get power supply failed\n", __func__);
 		return -EINVAL;
 	}
 	mtk_chg = power_supply_get_drvdata(psy);
@@ -892,7 +892,7 @@ bool pmic_chrdet_status(void)
 	if (upmu_is_chr_det())
 		return true;
 
-	pr_notice("%s: No charger\n", __func__);
+	pr_debug("%s: No charger\n", __func__);
 	return false;
 }
 
@@ -902,7 +902,7 @@ enum charger_type mt_get_charger_type(void)
 	struct power_supply *psy = power_supply_get_by_name("charger");
 
 	if (!psy) {
-		pr_info("%s: get power supply failed\n", __func__);
+		pr_err("%s: get power supply failed\n", __func__);
 		return -EINVAL;
 	}
 	mtk_chg = power_supply_get_drvdata(psy);
@@ -916,12 +916,12 @@ bool mt_charger_plugin(void)
 	struct chg_type_info *cti;
 
 	if (!psy) {
-		pr_info("%s: get power supply failed\n", __func__);
+		pr_err("%s: get power supply failed\n", __func__);
 		return -EINVAL;
 	}
 	mtk_chg = power_supply_get_drvdata(psy);
 	cti = mtk_chg->cti;
-	pr_info("%s plugin:%d\n", __func__, cti->plugin);
+	pr_debug("%s plugin:%d\n", __func__, cti->plugin);
 
 	return cti->plugin;
 }
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_dual_switch_charging.c b/drivers/power/supply/mediatek/charger_begonia/mtk_dual_switch_charging.c
index f9dec3594..50e053be1 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_dual_switch_charging.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_dual_switch_charging.c
@@ -858,20 +858,20 @@ static int mtk_dual_switch_charging_do_charging(struct charger_manager *info,
 {
 	struct dual_switch_charging_alg_data *swchgalg = info->algorithm_data;
 
-	pr_info("[%s] en:%d %s\n", __func__, en, info->algorithm_name);
+	pr_debug("[%s] en:%d %s\n", __func__, en, info->algorithm_name);
 	if (en) {
 		swchgalg->disable_charging = false;
 		swchgalg->state = CHR_CC;
 		charger_manager_notifier(info, CHARGER_NOTIFY_NORMAL);
 		mtk_pe40_set_is_enable(info, en);
-		pr_info("[%s] CHARGER_NOTIFY_NORMAL\n", __func__);
+		pr_debug("[%s] CHARGER_NOTIFY_NORMAL\n", __func__);
 	} else {
 		/* disable charging might change state, so call it first */
 		_disable_all_charging(info);
 		swchgalg->disable_charging = true;
 		swchgalg->state = CHR_ERROR;
 		charger_manager_notifier(info, CHARGER_NOTIFY_ERROR);
-		pr_info("[%s] CHARGER_NOTIFY_ERROR\n", __func__);
+		pr_err("[%s] CHARGER_NOTIFY_ERROR\n", __func__);
 	}
 
 	return 0;
@@ -949,7 +949,7 @@ static int mtk_dual_switch_chr_cc(struct charger_manager *info)
 		if (info->sw_jeita.pre_sm != TEMP_T2_TO_T3
 		    && info->sw_jeita.sm == TEMP_T2_TO_T3) {
 			/* set to CC state to reset chg2's ichg */
-			pr_info("back to normal temp, reset state\n");
+			pr_debug("back to normal temp, reset state\n");
 			swchgalg->state = CHR_CC;
 		}
 	}
@@ -1041,7 +1041,7 @@ static int mtk_dual_switch_charging_run(struct charger_manager *info)
 	union power_supply_propval val;
 	struct timespec time, time_now;
 
-	pr_info("%s [%d]\n", __func__, swchgalg->state);
+	pr_debug("%s [%d]\n", __func__, swchgalg->state);
 
 	power_supply_get_property(swchgalg->usb_psy,
 			POWER_SUPPLY_PROP_VOLTAGE_NOW, &val);
@@ -1058,10 +1058,10 @@ static int mtk_dual_switch_charging_run(struct charger_manager *info)
 		}
 	} else {
 		info->hvdcp_type = HVDCP_NULL;
-		pr_info("%s pdc is ready, set hvdcp_type null.\n", __func__);
+		pr_debug("%s pdc is ready, set hvdcp_type null.\n", __func__);
 	}
 
-	pr_info("get_hvdcp_type: %d , vbus = %d.\n", info->hvdcp_type, swchgalg->vbus_mv);
+	pr_debug("get_hvdcp_type: %d , vbus = %d.\n", info->hvdcp_type, swchgalg->vbus_mv);
 
 	if (mtk_pdc_check_charger(info) == false &&
 		mtk_is_TA_support_pd_pps(info) == false &&
@@ -1071,7 +1071,7 @@ static int mtk_dual_switch_charging_run(struct charger_manager *info)
 		mtk_pe20_check_charger(info);
 		if (mtk_pe20_get_is_connect(info) == false)
 			mtk_pe_check_charger(info);
-		pr_info("%s start check pe charger.\n", __func__);
+		pr_debug("%s start check pe charger.\n", __func__);
 	}
 
 	if (info->hvdcp_type == HVDCP_3) {
@@ -1091,7 +1091,7 @@ static int mtk_dual_switch_charging_run(struct charger_manager *info)
 
 			charger_dev_set_hvdcp_dpdm(info->chg2_dev);
 		}
-		pr_info("dpdm_status: %d . chg1 enabled: %d. \n", dpdm_status, chg1_enabled);
+		pr_debug("dpdm_status: %d . chg1 enabled: %d. \n", dpdm_status, chg1_enabled);
 	} else if (info->hvdcp_type == HVDCP) {
 		if (swchgalg->vbus_mv < HVDCP2P0_VOLATGE) {
 			/* Disable OVP */
@@ -1208,24 +1208,24 @@ int dual_charger_dev_event(struct notifier_block *nb, unsigned long event,
 	power_supply_get_property(swchgalg->charger_psy,
 			POWER_SUPPLY_PROP_ONLINE, &val);
 	charger_online = val.intval;
-	pr_info("%s: chg_online=%d.\n", charger_online);
+	pr_debug("%s: chg_online=%d.\n", charger_online);
 
 	switch (event) {
 	case CHARGER_DEV_NOTIFY_RECHG:
 		if(charger_online) {
 			charger_manager_notifier(info, CHARGER_NOTIFY_START_CHARGING);
-			pr_info("%s: recharge\n", __func__);
+			pr_debug("%s: recharge\n", __func__);
 		} else {
-			pr_info("%s: stop recharge\n", __func__);
+			pr_debug("%s: stop recharge\n", __func__);
 		}
 		break;
 	case CHARGER_DEV_NOTIFY_SAFETY_TIMEOUT:
 		info->safety_timeout = true;
-		pr_info("%s: safety timer timeout\n", __func__);
+		pr_debug("%s: safety timer timeout\n", __func__);
 		break;
 	case CHARGER_DEV_NOTIFY_VBUS_OVP:
 		info->vbusov_stat = data->vbusov_stat;
-		pr_info("%s: vbus ovp = %d\n", __func__, info->vbusov_stat);
+		pr_debug("%s: vbus ovp = %d\n", __func__, info->vbusov_stat);
 		break;
 	default:
 		return NOTIFY_DONE;
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_linear_charging.c b/drivers/power/supply/mediatek/charger_begonia/mtk_linear_charging.c
index ce32a0d4e..a6c7338b4 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_linear_charging.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_linear_charging.c
@@ -195,7 +195,7 @@ static int mtk_linear_charging_do_charging(struct charger_manager *info,
 {
 	struct linear_charging_alg_data *algo_data = info->algorithm_data;
 
-	pr_info("%s en:%d %s\n", __func__, en, info->algorithm_name);
+	pr_debug("%s en:%d %s\n", __func__, en, info->algorithm_name);
 	if (en) {
 		algo_data->disable_charging = false;
 		algo_data->state = CHR_CC;
@@ -227,7 +227,7 @@ static bool charging_full_check(struct charger_manager *info)
 			full_check_count = 0;
 			chg_full_status = true;
 			charger_dev_do_event(info->chg1_dev, EVENT_EOC, 0);
-			pr_notice("battery full on ichg = %d uA\n",
+			pr_debug("battery full on ichg = %d uA\n",
 				chg_current);
 		}
 	}
@@ -290,7 +290,7 @@ static int mtk_linear_chr_cc(struct charger_manager *info)
 	if (vbat > algo_data->topoff_voltage) {
 		algo_data->state = CHR_TOPOFF;
 		get_monotonic_boottime(&algo_data->topoff_begin_time);
-		pr_notice("enter TOPOFF mode on vbat = %d uV\n", vbat);
+		pr_debug("enter TOPOFF mode on vbat = %d uV\n", vbat);
 	}
 
 	linear_chg_turn_on_charging(info);
@@ -328,7 +328,7 @@ static int mtk_linear_chr_topoff(struct charger_manager *info)
 
 		/* Disable charging */
 		charger_dev_enable(info->chg1_dev, false);
-		pr_notice("%s: disable charging\n", __func__);
+		pr_debug("%s: disable charging\n", __func__);
 	}
 
 	return 0;
@@ -391,7 +391,7 @@ static int mtk_linear_chr_full(struct charger_manager *info)
 		charger_dev_do_event(info->chg1_dev, EVENT_RECHARGE, 0);
 		info->enable_dynamic_cv = true;
 		get_monotonic_boottime(&algo_data->charging_begin_time);
-		pr_notice("battery recharging on vbat = %d uV\n", vbat);
+		pr_debug("battery recharging on vbat = %d uV\n", vbat);
 		info->polling_interval = CHARGING_INTERVAL;
 	}
 
@@ -409,7 +409,7 @@ static int mtk_linear_charging_run(struct charger_manager *info)
 	struct linear_charging_alg_data *algo_data = info->algorithm_data;
 	int ret = 0;
 
-	pr_info("%s [%d], timer=%d %d %d\n", __func__, algo_data->state,
+	pr_debug("%s [%d], timer=%d %d %d\n", __func__, algo_data->state,
 		algo_data->cc_charging_time, algo_data->topoff_charging_time,
 		algo_data->total_charging_time);
 
@@ -451,19 +451,19 @@ static int linear_charger_dev_event(struct notifier_block *nb,
 	switch (event) {
 	case CHARGER_DEV_NOTIFY_EOC:
 		charger_manager_notifier(info, CHARGER_NOTIFY_EOC);
-		pr_info("%s: end of charge\n", __func__);
+		pr_debug("%s: end of charge\n", __func__);
 		break;
 	case CHARGER_DEV_NOTIFY_RECHG:
 		charger_manager_notifier(info, CHARGER_NOTIFY_START_CHARGING);
-		pr_info("%s: recharge\n", __func__);
+		pr_debug("%s: recharge\n", __func__);
 		break;
 	case CHARGER_DEV_NOTIFY_SAFETY_TIMEOUT:
 		info->safety_timeout = true;
-		pr_info("%s: safety timer timeout\n", __func__);
+		pr_debug("%s: safety timer timeout\n", __func__);
 		break;
 	case CHARGER_DEV_NOTIFY_VBUS_OVP:
 		info->vbusov_stat = data->vbusov_stat;
-		pr_info("%s: vbus ovp = %d\n", __func__, info->vbusov_stat);
+		pr_debug("%s: vbus ovp = %d\n", __func__, info->vbusov_stat);
 		break;
 	default:
 		return NOTIFY_DONE;
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_pd_adapter.c b/drivers/power/supply/mediatek/charger_begonia/mtk_pd_adapter.c
index 1600690a9..f07a88aae 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_pd_adapter.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_pd_adapter.c
@@ -421,11 +421,11 @@ static int mtk_pd_adapter_probe(struct platform_device *pdev)
 	info->tcpc = tcpc_dev_get_by_name("type_c_port0");
 	if (info->tcpc == NULL) {
 		if (is_deferred == false) {
-			pr_info("%s: tcpc device not ready, defer\n", __func__);
+			pr_warn("%s: tcpc device not ready, defer\n", __func__);
 			is_deferred = true;
 			ret = -EPROBE_DEFER;
 		} else {
-			pr_info("%s: failed to get tcpc device\n", __func__);
+			pr_err("%s: failed to get tcpc device\n", __func__);
 			ret = -EINVAL;
 		}
 		goto err_get_tcpc_dev;
@@ -435,7 +435,7 @@ static int mtk_pd_adapter_probe(struct platform_device *pdev)
 	ret = register_tcp_dev_notifier(info->tcpc, &info->pd_nb,
 				TCP_NOTIFY_TYPE_USB | TCP_NOTIFY_TYPE_MISC);
 	if (ret < 0) {
-		pr_info("%s: register tcpc notifer fail\n", __func__);
+		pr_err("%s: register tcpc notifer fail\n", __func__);
 		ret = -EINVAL;
 		goto err_get_tcpc_dev;
 	}
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_pdc_intf.c b/drivers/power/supply/mediatek/charger_begonia/mtk_pdc_intf.c
index 07e9c08cd..d246d8d2c 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_pdc_intf.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_pdc_intf.c
@@ -46,7 +46,7 @@ int mtk_pdc_set_mivr(struct charger_manager *info, int uV)
 			ret = charger_dev_set_mivr(info->chg2_dev,
 				uV + info->data.slave_mivr_diff);
 			if (ret < 0)
-				pr_info("%s: chg2 failed, ret = %d\n", __func__,
+				pr_err("%s: chg2 failed, ret = %d\n", __func__,
 					ret);
 		}
 	}
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_pe20_intf.c b/drivers/power/supply/mediatek/charger_begonia/mtk_pe20_intf.c
index 8d02aba4e..e437bbfcd 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_pe20_intf.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_pe20_intf.c
@@ -129,7 +129,7 @@ static int pe20_set_mivr(struct charger_manager *pinfo, int uV)
 			ret = charger_dev_set_mivr(pinfo->chg2_dev,
 				uV + pinfo->data.slave_mivr_diff);
 			if (ret < 0)
-				pr_info("%s: chg2 failed, ret = %d\n", __func__,
+				pr_err("%s: chg2 failed, ret = %d\n", __func__,
 					ret);
 		}
 	}
@@ -358,7 +358,7 @@ static void mtk_pe20_check_cable_impedance(struct charger_manager *pinfo)
 	}
 	charger_dev_set_input_current(pinfo->chg1_dev, pe20->aicr_cable_imp);
 
-	pr_info("%s: set aicr:%dmA, vbat:%dmV, mivr_state:%d\n",
+	pr_debug("%s: set aicr:%dmA, vbat:%dmV, mivr_state:%d\n",
 		__func__, pe20->aicr_cable_imp / 1000,
 		pe20->vbat_orig / 1000, mivr_state);
 	return;
@@ -484,7 +484,7 @@ int mtk_pe20_check_charger(struct charger_manager *pinfo)
 	struct mtk_pe20 *pe20 = &pinfo->pe2;
 
 	if (!pinfo->enable_hv_charging) {
-		pr_info("%s: hv charging is disabled\n", __func__);
+		pr_debug("%s: hv charging is disabled\n", __func__);
 		if (pe20->is_connect) {
 			pe20_leave(pinfo);
 			pe20->to_check_chr_type = true;
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_pe_intf.c b/drivers/power/supply/mediatek/charger_begonia/mtk_pe_intf.c
index 8a304baa8..c480d6a0a 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_pe_intf.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_pe_intf.c
@@ -83,7 +83,7 @@ static int pe_set_mivr(struct charger_manager *pinfo, int uV)
 			ret = charger_dev_set_mivr(pinfo->chg2_dev,
 				uV + pinfo->data.slave_mivr_diff);
 			if (ret < 0)
-				pr_info("%s: chg2 failed, ret = %d\n", __func__,
+				pr_err("%s: chg2 failed, ret = %d\n", __func__,
 					ret);
 		}
 	}
@@ -366,7 +366,7 @@ int mtk_pe_check_charger(struct charger_manager *pinfo)
 	struct mtk_pe *pe = &pinfo->pe;
 
 	if (!pinfo->enable_hv_charging) {
-		pr_info("%s: hv charging is disabled\n", __func__);
+		pr_debug("%s: hv charging is disabled\n", __func__);
 		if (pe->is_connect) {
 			pe_leave(pinfo, true);
 			pe->to_check_chr_type = true;
diff --git a/drivers/power/supply/mediatek/charger_begonia/mtk_switch_charging.c b/drivers/power/supply/mediatek/charger_begonia/mtk_switch_charging.c
index f2098952a..17c045134 100644
--- a/drivers/power/supply/mediatek/charger_begonia/mtk_switch_charging.c
+++ b/drivers/power/supply/mediatek/charger_begonia/mtk_switch_charging.c
@@ -676,11 +676,11 @@ int charger_dev_event(struct notifier_block *nb, unsigned long event, void *v)
 	switch (event) {
 	case CHARGER_DEV_NOTIFY_EOC:
 		charger_manager_notifier(info, CHARGER_NOTIFY_EOC);
-		pr_info("%s: end of charge\n", __func__);
+		pr_debug("%s: end of charge\n", __func__);
 		break;
 	case CHARGER_DEV_NOTIFY_RECHG:
 		charger_manager_notifier(info, CHARGER_NOTIFY_START_CHARGING);
-		pr_info("%s: recharge\n", __func__);
+		pr_debug("%s: recharge\n", __func__);
 		break;
 	case CHARGER_DEV_NOTIFY_SAFETY_TIMEOUT:
 		info->safety_timeout = true;
diff --git a/drivers/power/supply/mediatek/charger_begonia/rt9465.c b/drivers/power/supply/mediatek/charger_begonia/rt9465.c
index 1ace39e52..9dd52e6dd 100644
--- a/drivers/power/supply/mediatek/charger_begonia/rt9465.c
+++ b/drivers/power/supply/mediatek/charger_begonia/rt9465.c
@@ -1577,7 +1577,7 @@ static int rt9465_probe(struct i2c_client *i2c,
 	int ret = 0;
 	struct rt9465_info *info = NULL;
 
-	pr_info("%s (%s)\n", __func__, RT9465_DRV_VERSION);
+	pr_debug("%s (%s)\n", __func__, RT9465_DRV_VERSION);
 
 	info = devm_kzalloc(&i2c->dev, sizeof(struct rt9465_info), GFP_KERNEL);
 	if (!info)
@@ -1644,7 +1644,7 @@ static int rt9465_remove(struct i2c_client *i2c)
 	int ret = 0;
 	struct rt9465_info *info = i2c_get_clientdata(i2c);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	if (info) {
 		if (info->chg_dev)
@@ -1666,7 +1666,7 @@ static void rt9465_shutdown(struct i2c_client *i2c)
 	int ret = 0;
 	struct rt9465_info *info = i2c_get_clientdata(i2c);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	if (info) {
 		ret = rt9465_reset_chip(info);
@@ -1738,9 +1738,9 @@ static int __init rt9465_init(void)
 	int ret = 0;
 
 #ifdef CONFIG_OF
-	pr_info("%s: with dts\n", __func__);
+	pr_debug("%s: with dts\n", __func__);
 #else
-	pr_info("%s: without dts\n", __func__);
+	pr_debug("%s: without dts\n", __func__);
 	i2c_register_board_info(RT9465_BUSNUM, &rt9465_i2c_board_info, 1);
 #endif
 
diff --git a/drivers/power/supply/mediatek/charger_begonia/rt9467.c b/drivers/power/supply/mediatek/charger_begonia/rt9467.c
index f2fc3144d..a5a92b13a 100644
--- a/drivers/power/supply/mediatek/charger_begonia/rt9467.c
+++ b/drivers/power/supply/mediatek/charger_begonia/rt9467.c
@@ -3615,7 +3615,7 @@ static int rt9467_probe(struct i2c_client *client,
 	int ret = 0;
 	struct rt9467_info *info = NULL;
 
-	pr_info("%s(%s)\n", __func__, RT9467_DRV_VERSION);
+	pr_debug("%s(%s)\n", __func__, RT9467_DRV_VERSION);
 
 	info = devm_kzalloc(&client->dev, sizeof(struct rt9467_info),
 		GFP_KERNEL);
@@ -3751,7 +3751,7 @@ static int rt9467_remove(struct i2c_client *client)
 	int ret = 0;
 	struct rt9467_info *info = i2c_get_clientdata(client);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 
 	if (info) {
 #ifdef CONFIG_RT_REGMAP
@@ -3777,11 +3777,11 @@ static void rt9467_shutdown(struct i2c_client *client)
 	int ret = 0;
 	struct rt9467_info *info = i2c_get_clientdata(client);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	if (info) {
 		ret = rt9467_sw_reset(info);
 		if (ret < 0)
-			pr_notice("%s: sw reset fail\n", __func__);
+			pr_err("%s: sw reset fail\n", __func__);
 	}
 }
 
@@ -3848,15 +3848,15 @@ static int __init rt9467_init(void)
 	int ret = 0;
 
 #ifdef CONFIG_OF
-	pr_info("%s: with dts\n", __func__);
+	pr_debug("%s: with dts\n", __func__);
 #else
-	pr_info("%s: without dts\n", __func__);
+	pr_debug("%s: without dts\n", __func__);
 	i2c_register_board_info(RT9467_BUSNUM, &rt9467_i2c_board_info, 1);
 #endif
 
 	ret = i2c_add_driver(&rt9467_i2c_driver);
 	if (ret < 0)
-		pr_notice("%s: register i2c driver fail\n", __func__);
+		pr_err("%s: register i2c driver fail\n", __func__);
 
 	return ret;
 }
diff --git a/drivers/power/supply/mediatek/charger_begonia/rt9471.c b/drivers/power/supply/mediatek/charger_begonia/rt9471.c
index 88e9287cc..645dccf34 100644
--- a/drivers/power/supply/mediatek/charger_begonia/rt9471.c
+++ b/drivers/power/supply/mediatek/charger_begonia/rt9471.c
@@ -2494,7 +2494,7 @@ static void rt9471_shutdown(struct i2c_client *client)
 {
 	struct rt9471_chip *chip = i2c_get_clientdata(client);
 
-	pr_info("%s\n", __func__);
+	pr_debug("%s\n", __func__);
 	if (chip)
 		rt9471_reset_register(chip);
 }
diff --git a/drivers/power/supply/mediatek/charger_begonia/smb1351-charger.c b/drivers/power/supply/mediatek/charger_begonia/smb1351-charger.c
index d270f2418..4598d5779 100644
--- a/drivers/power/supply/mediatek/charger_begonia/smb1351-charger.c
+++ b/drivers/power/supply/mediatek/charger_begonia/smb1351-charger.c
@@ -697,7 +697,7 @@ static int smb1351_psy_chg_type_changed(struct smb1351_charger *chip, bool force
 	if (ret < 0)
 		pr_err("%s: psy type failed, ret = %d\n", __func__, ret);
 	else
-		pr_info("%s: chg_type = %d\n", __func__, chip->chg_type);
+		pr_debug("%s: chg_type = %d\n", __func__, chip->chg_type);
 
 
 	if (cm) {
@@ -722,7 +722,7 @@ static int smb1351_psy_chg_type_changed(struct smb1351_charger *chip, bool force
 
 static int smb1351_set_usbsw_state(struct smb1351_charger *chip, int state)
 {
-	pr_info("%s: state = %s\n", __func__, state ? "usb" : "chg");
+	pr_debug("%s: state = %s\n", __func__, state ? "usb" : "chg");
 
 	/* Switch D+D- to AP/SMB1351 */
 	if (state == USBSW_CHG)
@@ -754,7 +754,7 @@ static int rerun_apsd(struct smb1351_charger *chip)
 static int smb1351_apsd_complete_handler(struct smb1351_charger *chip,
 						u8 status)
 {
-	pr_info("%s: status: %d\n", __func__, status);
+	pr_debug("%s: status: %d\n", __func__, status);
 	schedule_work(&chip->apsd_update_work);
 	return 0;
 }
@@ -762,7 +762,7 @@ static int smb1351_apsd_complete_handler(struct smb1351_charger *chip,
 static int smb1351_usbin_uv_handler(struct smb1351_charger *chip, u8 status)
 {
 
-	pr_info("%s: status: %d\n", __func__, status);
+	pr_debug("%s: status: %d\n", __func__, status);
 
 	/* use this to detect USB insertion only if !apsd */
 	if (chip->disable_apsd) {
@@ -1056,7 +1056,7 @@ static void apsd_update_work(struct work_struct *work)
 			pr_err("Couldn't read STATUS_5 rc = %d\n", rc);
 			goto out;
 		}
-		pr_info("STATUS_5_REG(0x3B)=%x\n", reg);
+		pr_debug("STATUS_5_REG(0x3B)=%x\n", reg);
 
 		switch (reg) {
 		case STATUS_PORT_CDP:
@@ -1064,27 +1064,27 @@ static void apsd_update_work(struct work_struct *work)
 			if (cm->wireless_status == WIRELESS_CDP) {
 				cm->wireless_status = WIRELESS_CHG_CDP;
 				chip->chg_type = APPLE_1_0A_CHARGER;
-				pr_info("wireless_status CHG CDP detected.\n");
+				pr_debug("wireless_status CHG CDP detected.\n");
 			} else if (cm->wireless_status == WIRELESS_SDP) {
 				rerun_apsd_status = 1;
 				cm->wireless_status = WIRELESS_CDP;
-				pr_info("wireless_status cdp detected.\n");
+				pr_debug("wireless_status cdp detected.\n");
 			} else {
 				cm->wireless_status = WIRELESS_NULL;
-				//pr_info("wireless_status cdp set null.\n");
+				//pr_debug("wireless_status cdp set null.\n");
 			}
 			break;
 		case STATUS_PORT_DCP:
 			chip->chg_type = STANDARD_CHARGER;
 			if (cm->wireless_status == WIRELESS_CDP) {
 				cm->wireless_status = WIRELESS_CHG_DCP;
-				pr_info("wireless_status CHG DCP detected.\n");
+				pr_debug("wireless_status CHG DCP detected.\n");
 			} else {
 				cm->wireless_status = WIRELESS_NULL;
-				//pr_info("wireless_status dcp set null.\n");
+				//pr_debug("wireless_status dcp set null.\n");
 			}
 			if (chip->bc12_en) {
-				pr_info("bc12 enabled, schedule hvdcp work.\n");
+				pr_debug("bc12 enabled, schedule hvdcp work.\n");
 				schedule_delayed_work(&chip->chg_hvdcp_det_work,
 							msecs_to_jiffies(HVDCP_NOTIFY_MS));
 			}
@@ -1094,7 +1094,7 @@ static void apsd_update_work(struct work_struct *work)
 			if (cm->rp_lvl == RP_22K_CUR_LVL && cm->ra_detected) {
 				rerun_apsd_status = 1;
 				cm->wireless_status = WIRELESS_SDP;
-				pr_info("wireless_status sdp detected.\n");
+				pr_debug("wireless_status sdp detected.\n");
 			}
 			schedule_delayed_work(&chip->float_chg_det_work, msecs_to_jiffies(SDP_NOTIFY_MS));
 			break;
@@ -1117,7 +1117,7 @@ static void apsd_update_work(struct work_struct *work)
 				chip->rerun_apsd_count < MAX_RERUN_APSD_COUNT)) {
 			chip->rerun_apsd_count++;
 			rerun_apsd(chip);
-			pr_info("rerun_apsd. rerun_apsd_count = %d.\n", chip->rerun_apsd_count);
+			pr_debug("rerun_apsd. rerun_apsd_count = %d.\n", chip->rerun_apsd_count);
 		}
 		if (chip->chg_type != CHARGER_UNKNOWN) {
 			chip->rerun_apsd_count = 0;
@@ -1161,10 +1161,10 @@ static void smb1351_chg_hvdcp_det_work(struct work_struct *work)
 
 		if (cm->wireless_status == WIRELESS_CHG_DCP) {
 			cm->wireless_status = WIRELESS_CHG_HVDCP;
-			pr_info("wireless_status CHG HVDCP detected.\n");
+			pr_debug("wireless_status CHG HVDCP detected.\n");
 		} else {
 			cm->wireless_status = WIRELESS_NULL;
-			pr_info("wireless_status hvdcp set null.\n");
+			pr_debug("wireless_status hvdcp set null.\n");
 		}
 
 		pr_err("QC charger detected. hvdcp= %x.wireless_status = %d\n",
@@ -1190,7 +1190,7 @@ static void smb1351_chg_hvdcp_det_work(struct work_struct *work)
 		if (cm->hvdcp_check_count < HVDCP_CHECK_COUNT_MAX - 1)
 			rerun_apsd(chip);
 		cm->hvdcp_check_count++;
-		pr_info("%s hvdcp_check_count = %d.\n", __func__, cm->hvdcp_check_count);
+		pr_debug("%s hvdcp_check_count = %d.\n", __func__, cm->hvdcp_check_count);
 	}
 }
 
@@ -1386,13 +1386,13 @@ static irqreturn_t smb1351_chg_stat_handler(int irq, void *dev_id)
 	power_supply_get_property(chip->usb_psy,
 			POWER_SUPPLY_PROP_VOLTAGE_NOW, &val);
 
-	pr_info(" %s read vbus : %d. otg_enable:%d. \n",
+	pr_debug(" %s read vbus : %d. otg_enable:%d. \n",
 			__func__, val.intval, chip->otg_enable);
 
 	if (val.intval < VBUS_PLUG_OUT_THRESHOLD) {
 		/*set smb_susp pin low*/
 		gpio_direction_output(chip->suspend_gpio, 0);
-	    pr_info("vbus is low, set suspend to 0,return. \n");
+	    pr_debug("vbus is low, set suspend to 0,return. \n");
 		chip->shutdown_status = true;
 		mutex_unlock(&chip->irq_complete);
 		return IRQ_HANDLED;
@@ -1615,7 +1615,7 @@ static int set_reg(void *data, u64 val)
 	u8 temp = 0;
 
 	temp = (u8) val;
-	//pr_info("temp: 0x%x, val: 0x%x\n", temp, val);
+	//pr_debug("temp: 0x%x, val: 0x%x\n", temp, val);
 	rc = smb1351_write_reg(chip, chip->peek_poke_address, temp);
 	if (rc) {
 		pr_err("Couldn't write 0x%02x to 0x%02x rc= %d\n",
@@ -2366,7 +2366,7 @@ static int smb1351_plug_out(struct charger_device *chg_dev)
 	struct smb1351_charger *chip = dev_get_drvdata(&chg_dev->dev);
 	struct charger_manager *cm = chip->chg_consumer->cm;
 	int rc;
-	pr_info("%s \n", __func__);
+	pr_debug("%s \n", __func__);
 
 	chip->hvdcp_type = HVDCP_NULL;
 	chip->hvdcp_dpdm_status = 0;
@@ -2389,7 +2389,7 @@ static int smb1351_plug_in(struct charger_device *chg_dev)
 {
 	struct smb1351_charger *chip = dev_get_drvdata(&chg_dev->dev);
 	int rc;
-	pr_info("%s \n", __func__);
+	pr_debug("%s \n", __func__);
 	/* Enable SW conn therm Regulation */
 	rc = smblib_set_sw_conn_therm_regulation(chip, true);
 	if (rc < 0)
@@ -2432,7 +2432,7 @@ static int smb1351_enable_hvdcp_det(struct charger_device *chg_dev, bool enable)
 {
 	struct smb1351_charger *chip = dev_get_drvdata(&chg_dev->dev);
 
-	pr_info("%s. en = %d\n", __func__, enable);
+	pr_debug("%s. en = %d\n", __func__, enable);
 	_smb1351_enable_hvdcp_det(chip, enable);
 
 	return 0;
@@ -2498,7 +2498,7 @@ static int smb1351_check_hv_charging(struct charger_device *chg_dev)
 
 
 	if (pre_hv_charging_status != cm->enable_hv_charging) {
-		pr_info("%s: hv charging is %s, pre_status is %d\n", __func__,
+		pr_debug("%s: hv charging is %s, pre_status is %d\n", __func__,
 			cm->enable_hv_charging ? "enable" : "disable", pre_hv_charging_status);
 		pre_hv_charging_status = cm->enable_hv_charging;
 	} else {
@@ -2532,7 +2532,7 @@ static int smb1351_check_hv_charging(struct charger_device *chg_dev)
 			/* Re-run APSD */
 			rerun_apsd(chip);
 			chip->is_connect = false;
-			pr_info("%s: disable hvdcp\n", __func__);
+			pr_debug("%s: disable hvdcp\n", __func__);
 		}
 
 	} else {
@@ -2552,7 +2552,7 @@ static int smb1351_check_hv_charging(struct charger_device *chg_dev)
 			rerun_apsd(chip);
 
 			cm->hvdcp_check_count = 0;
-			pr_info("%s: enable hvdcp\n", __func__);
+			pr_debug("%s: enable hvdcp\n", __func__);
 			return 1;
 		}
 	}
@@ -2563,7 +2563,7 @@ static int smb1351_enable_otg(struct charger_device *chg_dev, bool en)
 {
 	struct smb1351_charger *chip = dev_get_drvdata(&chg_dev->dev);
 
-	pr_info("%s. en = %d\n", __func__, en);
+	pr_debug("%s. en = %d\n", __func__, en);
 
 	chip->otg_enable = en;
 	return 0;
@@ -2600,7 +2600,7 @@ static int smb1351_enable_chg_type_det(struct charger_device *chg_dev, bool en)
 	u8 reg, mask = 0;
 	const int max_wait_cnt = 200;
 
-	pr_info("%s: en = %d\n", __func__, en);
+	pr_debug("%s: en = %d\n", __func__, en);
 	/*set smb_susp pin high*/
 	gpio_direction_output(chip->suspend_gpio, 1);
 
@@ -2622,9 +2622,9 @@ static int smb1351_enable_chg_type_det(struct charger_device *chg_dev, bool en)
 	for (i = 0; i < max_wait_cnt; i++) {
 		if (is_usb_rdy())
 			break;
-		pr_info("%s: CDP block\n", __func__);
+		pr_debug("%s: CDP block\n", __func__);
 		if (!chip->tcpc_attach) {
-			pr_info("%s: plug out", __func__);
+			pr_debug("%s: plug out", __func__);
 			goto out;
 		}
 		msleep(100);
@@ -2632,7 +2632,7 @@ static int smb1351_enable_chg_type_det(struct charger_device *chg_dev, bool en)
 	if (i == max_wait_cnt)
 		pr_err("%s: CDP timeout\n", __func__);
 	else
-		pr_info("%s: CDP free\n", __func__);
+		pr_debug("%s: CDP free\n", __func__);
 
 	smb1351_set_usbsw_state(chip, USBSW_CHG);
 	msleep(30);
@@ -2678,7 +2678,7 @@ static int smb1351_enable_chg_type_det(struct charger_device *chg_dev, bool en)
 
 out:
 	mutex_unlock(&chip->chgdet_lock);
-	pr_info("%s: out.\n", __func__);
+	pr_debug("%s: out.\n", __func__);
 	if (en)
 		dump_regs(chip);
 	return ret;
@@ -2831,7 +2831,7 @@ static int smb1351_charger_probe(struct i2c_client *client,
 
 	/* STAT irq configuration */
 	if (client->irq) {
-		pr_info("%s: registering IRQ: %d\n", __func__, client->irq);
+		pr_debug("%s: registering IRQ: %d\n", __func__, client->irq);
 		rc = devm_request_threaded_irq(&client->dev, client->irq, NULL,
 				smb1351_chg_stat_handler,
 				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
@@ -2846,7 +2846,7 @@ static int smb1351_charger_probe(struct i2c_client *client,
 	chip->chg_consumer = charger_manager_get_by_name(chip->dev,
 			"charger_port1");
 	if (!chip->chg_consumer) {
-			pr_info("%s: get charger consumer device failed\n",
+			pr_err("%s: get charger consumer device failed\n",
 				__func__);
 	}
 
@@ -2871,7 +2871,7 @@ static int smb1351_charger_probe(struct i2c_client *client,
 	INIT_DELAYED_WORK(&chip->chg_hvdcp_det_work, smb1351_chg_hvdcp_det_work);
 	INIT_DELAYED_WORK(&chip->float_chg_det_work, smb1351_float_chg_det_work);
 	INIT_DELAYED_WORK(&chip->conn_therm_work, smblib_conn_therm_work);
-	pr_info("smb1351 parallel successfully probed.\n");
+	pr_debug("smb1351 parallel successfully probed.\n");
 
 	return 0;
 }
@@ -2880,7 +2880,7 @@ static int smb1351_charger_remove(struct i2c_client *client)
 {
 	struct smb1351_charger *chip = i2c_get_clientdata(client);
 
-	pr_info("%s: remove\n", __func__);
+	pr_debug("%s: remove\n", __func__);
 
 	_smb1351_enable_hvdcp_det(chip, true);
 	devm_free_irq(&client->dev, client->irq, chip);
@@ -2897,7 +2897,7 @@ static void smb1351_charger_shutdown(struct i2c_client *client)
 {
 	struct smb1351_charger *chip = i2c_get_clientdata(client);
 
-	pr_info("%s: shutdown\n", __func__);
+	pr_debug("%s: shutdown\n", __func__);
 
 	_smb1351_enable_hvdcp_det(chip, true);
 	devm_free_irq(&client->dev, client->irq, chip);
diff --git a/drivers/power/supply/mediatek/misc/mtk_gauge_time_service.c b/drivers/power/supply/mediatek/misc/mtk_gauge_time_service.c
index 7a8614629..7a6774cf7 100644
--- a/drivers/power/supply/mediatek/misc/mtk_gauge_time_service.c
+++ b/drivers/power/supply/mediatek/misc/mtk_gauge_time_service.c
@@ -42,14 +42,14 @@ static struct timespec gtimer_suspend_time;
 #define ft_err(fmt, args...)   \
 do {									\
 	if (ftlog_level >= FTLOG_ERROR_LEVEL) {			\
-		pr_notice(fmt, ##args); \
+		pr_err(fmt, ##args); \
 	}								   \
 } while (0)
 
 #define ft_debug(fmt, args...)   \
 do {									\
 	if (ftlog_level >= FTLOG_DEBUG_LEVEL) {		\
-		pr_notice(fmt, ##args); \
+		pr_debug(fmt, ##args); \
 	}								   \
 } while (0)
 
@@ -213,14 +213,14 @@ static void gtimer_handler(void)
 
 	hrtimer_cancel(&gtimer_kthread_timer);
 
-	ft_info("%s\n", __func__);
+	ft_debug("%s\n", __func__);
 	for (pos = phead->next; pos != phead;) {
 		struct list_head *ptmp;
 
 		get_monotonic_boottime(&time);
 		ptr = container_of(pos, struct gtimer, list);
 
-		ft_info("%s name:%s %ld %ld %d %d\n",
+		ft_debug("%s name:%s %ld %ld %d %d\n",
 			__func__,
 		ptr->name, time.tv_sec,
 		ptr->endtime.tv_sec, ptr->interval,
diff --git a/drivers/power/supply/mediatek/mtk_pep20_intf.c b/drivers/power/supply/mediatek/mtk_pep20_intf.c
index 9e8e7868f..9b97ec737 100644
--- a/drivers/power/supply/mediatek/mtk_pep20_intf.c
+++ b/drivers/power/supply/mediatek/mtk_pep20_intf.c
@@ -385,7 +385,7 @@ int mtk_pep20_check_charger(void)
 	int ret = 0;
 
 	if (!mtk_chr_is_hv_charging_enable()) {
-		pr_info("%s: hv charging is disabled\n", __func__);
+		pr_debug("%s: hv charging is disabled\n", __func__);
 		if (pep20_is_connect) {
 			pep20_leave();
 			pep20_to_check_chr_type = true;
@@ -463,7 +463,7 @@ int mtk_pep20_start_algorithm(void)
 	u32 size;
 
 	if (!mtk_chr_is_hv_charging_enable()) {
-		pr_info("%s: hv charging is disabled\n", __func__);
+		pr_debug("%s: hv charging is disabled\n", __func__);
 		if (pep20_is_connect) {
 			pep20_leave();
 			pep20_to_check_chr_type = true;
diff --git a/drivers/power/supply/mediatek/mtk_pep_intf.c b/drivers/power/supply/mediatek/mtk_pep_intf.c
index 880895e05..da5725bf8 100644
--- a/drivers/power/supply/mediatek/mtk_pep_intf.c
+++ b/drivers/power/supply/mediatek/mtk_pep_intf.c
@@ -358,7 +358,7 @@ int mtk_pep_check_charger(void)
 	int ret = 0;
 
 	if (!mtk_chr_is_hv_charging_enable()) {
-		pr_info("%s: hv charging is disabled\n", __func__);
+		pr_debug("%s: hv charging is disabled\n", __func__);
 		if (pep_is_connect) {
 			pep_leave(true);
 			pep_to_check_chr_type = true;
@@ -436,7 +436,7 @@ int mtk_pep_start_algorithm(void)
 	int ret = 0, chr_volt;
 
 	if (!mtk_chr_is_hv_charging_enable()) {
-		pr_info("%s: hv charging is disabled\n", __func__);
+		pr_debug("%s: hv charging is disabled\n", __func__);
 		if (pep_is_connect) {
 			pep_leave(true);
 			pep_to_check_chr_type = true;
diff --git a/drivers/thermal/cpu_cooling.c b/drivers/thermal/cpu_cooling.c
index eba1f4ef3..f9d07eeab 100644
--- a/drivers/thermal/cpu_cooling.c
+++ b/drivers/thermal/cpu_cooling.c
@@ -31,6 +31,7 @@
 #include <linux/slab.h>
 #include <linux/cpu.h>
 #include <linux/cpu_cooling.h>
+#include <linux/of_device.h>
 
 #include <trace/events/thermal.h>
 
@@ -149,10 +150,10 @@ static int cpufreq_thermal_notifier(struct notifier_block *nb,
 				    unsigned long event, void *data)
 {
 	struct cpufreq_policy *policy = data;
-	unsigned long clipped_freq;
+	unsigned long clipped_freq = ULONG_MAX;
 	struct cpufreq_cooling_device *cpufreq_cdev;
 
-	if (event != CPUFREQ_ADJUST)
+	if (event != CPUFREQ_THERMAL)
 		return NOTIFY_DONE;
 
 	mutex_lock(&cooling_list_lock);
@@ -175,13 +176,11 @@ static int cpufreq_thermal_notifier(struct notifier_block *nb,
 		 * But, if clipped_freq is greater than policy->max, we don't
 		 * need to do anything.
 		 */
-		clipped_freq = cpufreq_cdev->clipped_freq;
-
-		if (policy->max > clipped_freq)
-				cpufreq_verify_within_limits(policy, 0, clipped_freq);
-		break;
+		if (clipped_freq > cpufreq_cdev->clipped_freq)
+			clipped_freq = cpufreq_cdev->clipped_freq;
 	}
 	mutex_unlock(&cooling_list_lock);
+	cpufreq_verify_within_limits(policy, 0, clipped_freq);
 
 	return NOTIFY_OK;
 }
@@ -452,16 +451,45 @@ static int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,
 
 	/* Check if the old cooling action is same as new cooling action */
 	if (cpufreq_cdev->cpufreq_state == state)
-		return 0;
+		return cpufreq_cdev->max_level;
 	clip_freq = cpufreq_cdev->freq_table[state].frequency;
 	cpufreq_cdev->cpufreq_state = state;
 	cpufreq_cdev->clipped_freq = clip_freq;
 
+	get_online_cpus();
 	cpufreq_update_policy(cpufreq_cdev->policy->cpu);
+	put_online_cpus();
 
 	return 0;
 }
 
+void cpu_limits_set_level(unsigned int cpu, unsigned int max_freq)
+{
+	struct cpufreq_cooling_device *cpufreq_cdev;
+	struct thermal_cooling_device *cdev;
+	unsigned int cdev_cpu;
+	unsigned int level;
+
+	list_for_each_entry(cpufreq_cdev, &cpufreq_cdev_list, node) {
+		sscanf(cpufreq_cdev->cdev->type, "thermal-cpufreq-%d", &cdev_cpu);
+		if (cdev_cpu == cpu) {
+			for (level = 0; level <= cpufreq_cdev->max_level; level++) {
+				int target_freq = cpufreq_cdev->freq_table[level].frequency;
+				if (max_freq >= target_freq) {
+
+					cdev = cpufreq_cdev->cdev;
+					if (cdev)
+						cdev->ops->set_cur_state(cdev, level);
+
+					break;
+				}
+			}
+
+			break;
+		}
+	}
+}
+
 /**
  * cpufreq_get_requested_power() - get the current power
  * @cdev:	&thermal_cooling_device pointer
@@ -870,6 +898,33 @@ cpufreq_power_cooling_register(struct cpufreq_policy *policy, u32 capacitance,
 }
 EXPORT_SYMBOL(cpufreq_power_cooling_register);
 
+int cpufreq_platform_cooling_register(void)
+{
+	struct cpumask *clip_cpus;
+	struct device_node *cpu_node;
+	struct cpufreq_policy *policy;
+	int cpu;
+
+	for_each_cpu(cpu, cpu_online_mask) {
+		policy = cpufreq_cpu_get(cpu);
+		if (!policy) {
+			pr_err("no policy for cpu%d\n", cpu);
+			continue;
+		}
+
+		clip_cpus = policy->related_cpus;
+		cpu_node = of_cpu_device_node_get(cpumask_first(policy->cpus));
+		if (!cpu_node) {
+			pr_err("no cpu node\n");
+			continue;
+		}
+		__cpufreq_cooling_register(cpu_node, policy, 0, NULL);
+	}
+
+	return 0;
+
+}
+
 /**
  * of_cpufreq_power_cooling_register() - create cpufreq cooling device with power extensions
  * @np:	a valid struct device_node to the cooling device device tree node
@@ -940,3 +995,5 @@ void cpufreq_cooling_unregister(struct thermal_cooling_device *cdev)
 	kfree(cpufreq_cdev);
 }
 EXPORT_SYMBOL_GPL(cpufreq_cooling_unregister);
+
+late_initcall(cpufreq_platform_cooling_register);
diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c
index 7beefd1c4..e35dc8cb6 100644
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@ -26,11 +26,19 @@
 #include <net/genetlink.h>
 #include <linux/suspend.h>
 
+#include <linux/cpu_cooling.h>
+#ifdef CONFIG_FB
+#include <linux/fb.h>
+#include <linux/notifier.h>
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/thermal.h>
 
 #include "thermal_core.h"
 #include "thermal_hwmon.h"
+#include "../misc/mediatek/base/power/include/ppm_v3/mtk_ppm_api.h"
+#define CPU_LIMITS_PARAM_NUM    2
 
 MODULE_AUTHOR("Zhang Rui");
 MODULE_DESCRIPTION("Generic thermal management sysfs support");
@@ -52,6 +60,21 @@ static bool power_off_triggered;
 
 static struct thermal_governor *def_governor;
 
+#ifdef CONFIG_FB
+struct screen_monitor {
+	struct notifier_block thermal_notifier;
+	int screen_state;
+};
+struct screen_monitor sm;
+#endif
+static atomic_t switch_mode = ATOMIC_INIT(-1);
+static atomic_t temp_state = ATOMIC_INIT(0);
+static atomic_t lighter_event = ATOMIC_INIT(0);
+static char boost_buf[128];
+static struct device thermal_message_dev;
+const char *board_sensor;
+static char board_sensor_temp[128];
+
 /*
  * Governor section: set of functions to handle thermal governors
  *
@@ -1155,6 +1178,251 @@ exit:
 	mutex_unlock(&thermal_list_lock);
 }
 
+static ssize_t
+thermal_sconfig_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+       return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&switch_mode));
+}
+
+static ssize_t
+thermal_sconfig_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+       int val = -1;
+
+       val = simple_strtol(buf, NULL, 10);
+
+       atomic_set(&switch_mode, val);
+
+       return len;
+}
+
+static DEVICE_ATTR(sconfig, 0664,
+		thermal_sconfig_show, thermal_sconfig_store);
+static ssize_t
+thermal_boost_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+       return snprintf(buf, PAGE_SIZE, boost_buf);
+}
+
+static ssize_t
+thermal_boost_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+       int ret;
+       ret = snprintf(boost_buf, PAGE_SIZE, buf);
+       return len;
+}
+
+static DEVICE_ATTR(boost, 0644,
+		thermal_boost_show, thermal_boost_store);
+static ssize_t
+thermal_temp_state_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+       return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&temp_state));
+}
+
+static ssize_t
+thermal_temp_state_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+       int val = -1;
+
+       val = simple_strtol(buf, NULL, 10);
+
+       atomic_set(&temp_state, val);
+
+       return len;
+}
+
+static DEVICE_ATTR(temp_state, 0664,
+		thermal_temp_state_show, thermal_temp_state_store);
+static ssize_t
+thermal_lighter_event_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+       return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&lighter_event));
+}
+
+static ssize_t
+thermal_lighter_event_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+       int val = -1;
+
+       val = simple_strtol(buf, NULL, 10);
+
+       atomic_set(&lighter_event, val);
+
+       return len;
+}
+
+static DEVICE_ATTR(lighter_event, 0664,
+		thermal_lighter_event_show, thermal_lighter_event_store);
+static ssize_t
+cpu_limits_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+       return 0;
+}
+
+static ssize_t
+cpu_limits_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+	unsigned int cpu;
+	unsigned int max;
+
+	if (sscanf(buf, "cpu%u %u", &cpu, &max) != CPU_LIMITS_PARAM_NUM) {
+		pr_err("input param error, can not prase param\n");
+		return -EINVAL;
+	}
+	if (cpu >= 0 && cpu <= 5)
+		cpu = 0;
+	else
+		cpu = 1;
+
+	mt_ppm_sysboost_set_freq_limit(BOOST_BY_XM_THERMAL, cpu, -1, max);
+
+	return len;
+}
+
+static DEVICE_ATTR(cpu_limits, 0664,
+		cpu_limits_show, cpu_limits_store);
+#ifdef CONFIG_FB
+static ssize_t
+thermal_screen_state_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", sm.screen_state);
+}
+
+static DEVICE_ATTR(screen_state, 0664,
+		thermal_screen_state_show, NULL);
+#endif
+
+static ssize_t
+thermal_board_sensor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (!board_sensor)
+		board_sensor = "invalid";
+
+	return snprintf(buf, PAGE_SIZE, "%s", board_sensor);
+}
+
+static DEVICE_ATTR(board_sensor, 0664,
+		thermal_board_sensor_show, NULL);
+
+static ssize_t
+thermal_board_sensor_temp_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+       return snprintf(buf, PAGE_SIZE, board_sensor_temp);
+}
+
+static ssize_t
+thermal_board_sensor_temp_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+       snprintf(board_sensor_temp, PAGE_SIZE, buf);
+
+       return len;
+}
+
+static DEVICE_ATTR(board_sensor_temp, 0664,
+		thermal_board_sensor_temp_show, thermal_board_sensor_temp_store);
+
+static int create_thermal_message_node(void)
+{
+       int ret = 0;
+
+       thermal_message_dev.class = &thermal_class;
+
+       dev_set_name(&thermal_message_dev, "thermal_message");
+       ret = device_register(&thermal_message_dev);
+       if (!ret) {
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_sconfig.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create sconfig node failed\n");
+
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_boost.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create boost node failed\n");
+
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_temp_state.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create temp state node failed\n");
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_lighter_event.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create lighter event node failed\n");
+
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_cpu_limits.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create cpu limits node failed\n");
+#ifdef CONFIG_FB
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_screen_state.attr);
+		if (ret < 0)
+			pr_warn("Thermal: create screen state node failed\n");
+#endif
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_board_sensor.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create board sensor node failed\n");
+
+		ret = sysfs_create_file(&thermal_message_dev.kobj, &dev_attr_board_sensor_temp.attr);
+		if (ret < 0)
+		       pr_warn("Thermal: create board sensor temp node failed\n");
+       }
+
+       return ret;
+}
+
+static void destroy_thermal_message_node(void)
+{
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_board_sensor_temp.attr);
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_board_sensor.attr);
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_cpu_limits.attr);
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_temp_state.attr);
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_lighter_event.attr);
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_boost.attr);
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_sconfig.attr);
+#ifdef CONFIG_FB
+       sysfs_remove_file(&thermal_message_dev.kobj, &dev_attr_screen_state.attr);
+#endif
+       device_unregister(&thermal_message_dev);
+}
+#ifdef CONFIG_FB
+static int screen_state_for_thermal_callback(struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct fb_event *evdata = data;
+	unsigned int blank;
+
+	if (val != FB_EARLY_EVENT_BLANK || !evdata || !evdata->data)
+		return 0;
+
+	blank = *(int *)(evdata->data);
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+		sm.screen_state = 0;
+		pr_warn("%s: FB_BLANK_POWERDOWN\n", __func__);
+		break;
+	case FB_BLANK_UNBLANK:
+		sm.screen_state = 1;
+		pr_warn("%s: FB_BLANK_UNBLANK\n", __func__);
+		break;
+	default:
+		break;
+	}
+
+	sysfs_notify(&thermal_message_dev.kobj, NULL, "screen_state");
+
+	return NOTIFY_OK;
+}
+#endif
+
 /**
  * thermal_zone_device_register() - register a new thermal zone device
  * @type:	the thermal zone device type
@@ -1544,7 +1812,19 @@ static int __init thermal_init(void)
 	result = class_register(&thermal_class);
 	if (result)
 		goto unregister_governors;
-	
+
+#ifdef CONFIG_FB
+	sm.thermal_notifier.notifier_call = screen_state_for_thermal_callback;
+	if (fb_register_client(&sm.thermal_notifier) < 0) {
+		pr_warn("Thermal: register screen state callback failed\n");
+	}
+#endif
+
+	result = create_thermal_message_node();
+	if (result)
+		pr_warn("Thermal: create thermal message node failed, return %d\n",
+				result);
+
 	result = genetlink_init();
 	if (result)
 		goto unregister_class;
@@ -1576,11 +1856,15 @@ error:
 
 static void __exit thermal_exit(void)
 {
+#ifdef CONFIG_FB
+        fb_unregister_client(&sm.thermal_notifier);
+#endif
 	unregister_pm_notifier(&thermal_pm_nb);
 	of_thermal_destroy_zones();
 	genetlink_exit();
 	class_unregister(&thermal_class);
 	thermal_unregister_governors();
+	destroy_thermal_message_node();
 	ida_destroy(&thermal_tz_ida);
 	ida_destroy(&thermal_cdev_ida);
 	mutex_destroy(&thermal_list_lock);
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ba88eb18b..5b6c0555f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -2,6 +2,7 @@
  * linux/include/linux/cpufreq.h
  *
  * Copyright (C) 2001 Russell King
+ * Copyright (C) 2021 XiaoMi, Inc.
  *           (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -429,6 +430,7 @@ static inline void cpufreq_resume(void) {}
 /* Policy Notifiers  */
 #define CPUFREQ_ADJUST			(0)
 #define CPUFREQ_NOTIFY			(1)
+#define CPUFREQ_THERMAL			(2)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 41cc62895..80f3418cd 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -3337,7 +3337,7 @@ static void addrconf_dev_config(struct net_device *dev)
 	    (dev->type != ARPHRD_IPGRE) &&
 	    (dev->type != ARPHRD_TUNNEL) &&
 	    (dev->type != ARPHRD_NONE) &&
-	    (dev->type != ARPHRD_PUREIP)) {
+	    (dev->type != ARPHRD_RAWIP)) {
 		/* Alas, we support only Ethernet autoconfiguration. */
 		idev = __in6_dev_get(dev);
 		if (!IS_ERR_OR_NULL(idev) && dev->flags & IFF_UP &&
@@ -3351,7 +3351,7 @@ static void addrconf_dev_config(struct net_device *dev)
 		return;
 
 	/* mobile device doesn't need auto-linklocal addr */
-	if (dev->type == ARPHRD_PUREIP)
+	if (dev->type == ARPHRD_RAWIP)
 		return;
 
 	/* this device type has no EUI support */
diff --git a/net/sched/cls_bpf.c b/net/sched/cls_bpf.c
index 3a499530f..4a87b2b6f 100644
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@ -100,6 +100,8 @@ static int cls_bpf_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 		if (tc_skip_sw(prog->gen_flags)) {
 			filter_res = prog->exts_integrated ? TC_ACT_UNSPEC : 0;
 		} else if (at_ingress) {
+			if ((strncmp(skb->dev->name, "ccmni", 2) == 0))
+				skb->mac_len = 0;
 			/* It is safe to push/pull even if skb_shared() */
 			__skb_push(skb, skb->mac_len);
 			bpf_compute_data_end(skb);
-- 
2.51.2

